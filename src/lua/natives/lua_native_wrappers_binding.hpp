#pragma once
#include "natives.hpp"

namespace lua::native
{
	void LUA_NATIVE_SYSTEM_WAIT( int ms) { invoke<void )
	{
		SYSTEM::WAIT(invoke<void);
	}

	int LUA_NATIVE_SYSTEM_START_NEW_SCRIPT( const char* scriptName, int stackSize) { return invoke<int )
	{
		auto retval = SYSTEM::START_NEW_SCRIPT(scriptName, invoke<int);
		return retval;
	}

	std::tuple<int, Any> LUA_NATIVE_SYSTEM_START_NEW_SCRIPT_WITH_ARGS( const char* scriptName, Any args, int argCount, int stackSize) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = SYSTEM::START_NEW_SCRIPT_WITH_ARGS(scriptName, &args, argCount, invoke<int);
		std::get<1>(return_values) = args;

		return return_values;
	}

	int LUA_NATIVE_SYSTEM_START_NEW_SCRIPT_WITH_NAME_HASH( unsigned scriptHash, int stackSize) { return invoke<int )
	{
		auto retval = SYSTEM::START_NEW_SCRIPT_WITH_NAME_HASH(scriptHash, invoke<int);
		return retval;
	}

	std::tuple<int, Any> LUA_NATIVE_SYSTEM_START_NEW_SCRIPT_WITH_NAME_HASH_AND_ARGS( unsigned scriptHash, Any args, int argCount, int stackSize) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = SYSTEM::START_NEW_SCRIPT_WITH_NAME_HASH_AND_ARGS(scriptHash, &args, argCount, invoke<int);
		std::get<1>(return_values) = args;

		return return_values;
	}

	int LUA_NATIVE_SYSTEM_TIMERA(  )
	{
		auto retval = SYSTEM::TIMERA();
		return retval;
	}

	int LUA_NATIVE_SYSTEM_TIMERB(  )
	{
		auto retval = SYSTEM::TIMERB();
		return retval;
	}

	void LUA_NATIVE_SYSTEM_SETTIMERA( int value) { invoke<void )
	{
		SYSTEM::SETTIMERA(invoke<void);
	}

	void LUA_NATIVE_SYSTEM_SETTIMERB( int value) { invoke<void )
	{
		SYSTEM::SETTIMERB(invoke<void);
	}

	float LUA_NATIVE_SYSTEM_TIMESTEP(  )
	{
		auto retval = SYSTEM::TIMESTEP();
		return retval;
	}

	float LUA_NATIVE_SYSTEM_SIN( float value) { return invoke<float )
	{
		auto retval = SYSTEM::SIN(invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_COS( float value) { return invoke<float )
	{
		auto retval = SYSTEM::COS(invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_SQRT( float value) { return invoke<float )
	{
		auto retval = SYSTEM::SQRT(invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_POW( float base, float exponent) { return invoke<float )
	{
		auto retval = SYSTEM::POW(base, invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_LOG10( float value) { return invoke<float )
	{
		auto retval = SYSTEM::LOG10(invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_VMAG( float x, float y, float z) { return invoke<float )
	{
		auto retval = SYSTEM::VMAG(x, y, invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_VMAG2( float x, float y, float z) { return invoke<float )
	{
		auto retval = SYSTEM::VMAG2(x, y, invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_VDIST( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<float )
	{
		auto retval = SYSTEM::VDIST(x1, y1, z1, x2, y2, invoke<float);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_VDIST2( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<float )
	{
		auto retval = SYSTEM::VDIST2(x1, y1, z1, x2, y2, invoke<float);
		return retval;
	}

	int LUA_NATIVE_SYSTEM_SHIFT_LEFT( int value, int bitShift) { return invoke<int )
	{
		auto retval = SYSTEM::SHIFT_LEFT(value, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SYSTEM_SHIFT_RIGHT( int value, int bitShift) { return invoke<int )
	{
		auto retval = SYSTEM::SHIFT_RIGHT(value, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SYSTEM_FLOOR( float value) { return invoke<int )
	{
		auto retval = SYSTEM::FLOOR(invoke<int);
		return retval;
	}

	int LUA_NATIVE_SYSTEM_CEIL( float value) { return invoke<int )
	{
		auto retval = SYSTEM::CEIL(invoke<int);
		return retval;
	}

	int LUA_NATIVE_SYSTEM_ROUND( float value) { return invoke<int )
	{
		auto retval = SYSTEM::ROUND(invoke<int);
		return retval;
	}

	float LUA_NATIVE_SYSTEM_TO_FLOAT( int value) { return invoke<float )
	{
		auto retval = SYSTEM::TO_FLOAT(invoke<float);
		return retval;
	}

	void LUA_NATIVE_SYSTEM_SET_THIS_THREAD_PRIORITY( int priority) { invoke<void )
	{
		SYSTEM::SET_THIS_THREAD_PRIORITY(invoke<void);
	}

	bool LUA_NATIVE_APP_APP_DATA_VALID(  )
	{
		auto retval = (bool)APP::APP_DATA_VALID();
		return retval;
	}

	int LUA_NATIVE_APP_APP_GET_INT( const char* property) { return invoke<int )
	{
		auto retval = APP::APP_GET_INT(invoke<int);
		return retval;
	}

	float LUA_NATIVE_APP_APP_GET_FLOAT( const char* property) { return invoke<float )
	{
		auto retval = APP::APP_GET_FLOAT(invoke<float);
		return retval;
	}

	const char* LUA_NATIVE_APP_APP_GET_STRING( const char* property) { return invoke<const char* )
	{
		auto retval = APP::APP_GET_STRING(char*);
		return retval;
	}

	void LUA_NATIVE_APP_APP_SET_INT( const char* property, int value) { invoke<void )
	{
		APP::APP_SET_INT(property, invoke<void);
	}

	void LUA_NATIVE_APP_APP_SET_FLOAT( const char* property, float value) { invoke<void )
	{
		APP::APP_SET_FLOAT(property, invoke<void);
	}

	void LUA_NATIVE_APP_APP_SET_STRING( const char* property, const char* value) { invoke<void )
	{
		APP::APP_SET_STRING(property, invoke<void);
	}

	void LUA_NATIVE_APP_APP_SET_APP( const char* appName) { invoke<void )
	{
		APP::APP_SET_APP(invoke<void);
	}

	void LUA_NATIVE_APP_APP_SET_BLOCK( const char* blockName) { invoke<void )
	{
		APP::APP_SET_BLOCK(invoke<void);
	}

	void LUA_NATIVE_APP_APP_CLEAR_BLOCK(  )
	{
		APP::APP_CLEAR_BLOCK();
	}

	void LUA_NATIVE_APP_APP_CLOSE_APP(  )
	{
		APP::APP_CLOSE_APP();
	}

	void LUA_NATIVE_APP_APP_CLOSE_BLOCK(  )
	{
		APP::APP_CLOSE_BLOCK();
	}

	bool LUA_NATIVE_APP_APP_HAS_LINKED_SOCIAL_CLUB_ACCOUNT(  )
	{
		auto retval = (bool)APP::APP_HAS_LINKED_SOCIAL_CLUB_ACCOUNT();
		return retval;
	}

	bool LUA_NATIVE_APP_APP_HAS_SYNCED_DATA( const char* appName) { return invoke<BOOL )
	{
		auto retval = (bool)APP::APP_HAS_SYNCED_DATA(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_APP_APP_SAVE_DATA(  )
	{
		APP::APP_SAVE_DATA();
	}

	int LUA_NATIVE_APP_APP_GET_DELETED_FILE_STATUS(  )
	{
		auto retval = APP::APP_GET_DELETED_FILE_STATUS();
		return retval;
	}

	bool LUA_NATIVE_APP_APP_DELETE_APP_DATA( const char* appName) { return invoke<BOOL )
	{
		auto retval = (bool)APP::APP_DELETE_APP_DATA(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_PLAY_PED_RINGTONE( const char* ringtoneName, int ped, bool p2) { invoke<void )
	{
		AUDIO::PLAY_PED_RINGTONE(ringtoneName, ped, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_PED_RINGTONE_PLAYING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_PED_RINGTONE_PLAYING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_STOP_PED_RINGTONE( int ped) { invoke<void )
	{
		AUDIO::STOP_PED_RINGTONE(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_MOBILE_PHONE_CALL_ONGOING(  )
	{
		auto retval = (bool)AUDIO::IS_MOBILE_PHONE_CALL_ONGOING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_MOBILE_INTERFERENCE_ACTIVE(  )
	{
		auto retval = (bool)AUDIO::IS_MOBILE_INTERFERENCE_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_AUDIO_CREATE_NEW_SCRIPTED_CONVERSATION(  )
	{
		AUDIO::CREATE_NEW_SCRIPTED_CONVERSATION();
	}

	void LUA_NATIVE_AUDIO_ADD_LINE_TO_CONVERSATION( int index, const char* p1, const char* p2, int p3, int p4, bool p5, bool p6, bool p7, bool p8, int p9, bool p10, bool p11, bool p12) { invoke<void )
	{
		AUDIO::ADD_LINE_TO_CONVERSATION(index, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, invoke<void);
	}

	void LUA_NATIVE_AUDIO_ADD_PED_TO_CONVERSATION( int index, int ped, const char* p2) { invoke<void )
	{
		AUDIO::ADD_PED_TO_CONVERSATION(index, ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_POSITION_FOR_NULL_CONV_PED( Any p0, float p1, float p2, float p3) { invoke<void )
	{
		AUDIO::SET_POSITION_FOR_NULL_CONV_PED(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_ENTITY_FOR_NULL_CONV_PED( int p0, int entity) { invoke<void )
	{
		AUDIO::SET_ENTITY_FOR_NULL_CONV_PED(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_MICROPHONE_POSITION( bool toggle, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) { invoke<void )
	{
		AUDIO::SET_MICROPHONE_POSITION(toggle, x1, y1, z1, x2, y2, z2, x3, y3, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_CONVERSATION_AUDIO_CONTROLLED_BY_ANIM( bool p0) { invoke<void )
	{
		AUDIO::SET_CONVERSATION_AUDIO_CONTROLLED_BY_ANIM(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_CONVERSATION_AUDIO_PLACEHOLDER( bool p0) { invoke<void )
	{
		AUDIO::SET_CONVERSATION_AUDIO_PLACEHOLDER(invoke<void);
	}

	void LUA_NATIVE_AUDIO_START_SCRIPT_PHONE_CONVERSATION( bool p0, bool p1) { invoke<void )
	{
		AUDIO::START_SCRIPT_PHONE_CONVERSATION(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PRELOAD_SCRIPT_PHONE_CONVERSATION( bool p0, bool p1) { invoke<void )
	{
		AUDIO::PRELOAD_SCRIPT_PHONE_CONVERSATION(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_START_SCRIPT_CONVERSATION( bool p0, bool p1, bool p2, bool p3) { invoke<void )
	{
		AUDIO::START_SCRIPT_CONVERSATION(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PRELOAD_SCRIPT_CONVERSATION( bool p0, bool p1, bool p2, bool p3) { invoke<void )
	{
		AUDIO::PRELOAD_SCRIPT_CONVERSATION(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_AUDIO_START_PRELOADED_CONVERSATION(  )
	{
		AUDIO::START_PRELOADED_CONVERSATION();
	}

	bool LUA_NATIVE_AUDIO_GET_IS_PRELOADED_CONVERSATION_READY(  )
	{
		auto retval = (bool)AUDIO::GET_IS_PRELOADED_CONVERSATION_READY();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_SCRIPTED_CONVERSATION_ONGOING(  )
	{
		auto retval = (bool)AUDIO::IS_SCRIPTED_CONVERSATION_ONGOING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_SCRIPTED_CONVERSATION_LOADED(  )
	{
		auto retval = (bool)AUDIO::IS_SCRIPTED_CONVERSATION_LOADED();
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_CURRENT_SCRIPTED_CONVERSATION_LINE(  )
	{
		auto retval = AUDIO::GET_CURRENT_SCRIPTED_CONVERSATION_LINE();
		return retval;
	}

	void LUA_NATIVE_AUDIO_PAUSE_SCRIPTED_CONVERSATION( bool p0) { invoke<void )
	{
		AUDIO::PAUSE_SCRIPTED_CONVERSATION(invoke<void);
	}

	void LUA_NATIVE_AUDIO_RESTART_SCRIPTED_CONVERSATION(  )
	{
		AUDIO::RESTART_SCRIPTED_CONVERSATION();
	}

	int LUA_NATIVE_AUDIO_STOP_SCRIPTED_CONVERSATION( bool p0) { return invoke<int )
	{
		auto retval = AUDIO::STOP_SCRIPTED_CONVERSATION(invoke<int);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SKIP_TO_NEXT_SCRIPTED_CONVERSATION_LINE(  )
	{
		AUDIO::SKIP_TO_NEXT_SCRIPTED_CONVERSATION_LINE();
	}

	void LUA_NATIVE_AUDIO_INTERRUPT_CONVERSATION( int ped, const char* voiceline, const char* speaker) { invoke<void )
	{
		AUDIO::INTERRUPT_CONVERSATION(ped, voiceline, invoke<void);
	}

	void LUA_NATIVE_AUDIO_INTERRUPT_CONVERSATION_AND_PAUSE( int ped, const char* p1, const char* speaker) { invoke<void )
	{
		AUDIO::INTERRUPT_CONVERSATION_AND_PAUSE(ped, p1, invoke<void);
	}

	std::tuple<int, Any p0) { return> LUA_NATIVE_AUDIO_GET_VARIATION_CHOSEN_FOR_SCRIPTED_LINE( Any p0) { return invoke<int )
	{
		std::tuple<int, Any p0) { return> return_values;
		std::get<0>(return_values) = AUDIO::GET_VARIATION_CHOSEN_FOR_SCRIPTED_LINE(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_AUDIO_SET_NO_DUCKING_FOR_CONVERSATION( bool p0) { invoke<void )
	{
		AUDIO::SET_NO_DUCKING_FOR_CONVERSATION(invoke<void);
	}

	void LUA_NATIVE_AUDIO_REGISTER_SCRIPT_WITH_AUDIO( int p0) { invoke<void )
	{
		AUDIO::REGISTER_SCRIPT_WITH_AUDIO(invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNREGISTER_SCRIPT_WITH_AUDIO(  )
	{
		AUDIO::UNREGISTER_SCRIPT_WITH_AUDIO();
	}

	bool LUA_NATIVE_AUDIO_REQUEST_MISSION_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::REQUEST_MISSION_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_REQUEST_AMBIENT_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::REQUEST_AMBIENT_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_REQUEST_SCRIPT_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::REQUEST_SCRIPT_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_HINT_MISSION_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::HINT_MISSION_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_HINT_AMBIENT_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::HINT_AMBIENT_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_HINT_SCRIPT_AUDIO_BANK( const char* audioBank, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::HINT_SCRIPT_AUDIO_BANK(audioBank, p1, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_RELEASE_MISSION_AUDIO_BANK(  )
	{
		AUDIO::RELEASE_MISSION_AUDIO_BANK();
	}

	void LUA_NATIVE_AUDIO_RELEASE_AMBIENT_AUDIO_BANK(  )
	{
		AUDIO::RELEASE_AMBIENT_AUDIO_BANK();
	}

	void LUA_NATIVE_AUDIO_RELEASE_NAMED_SCRIPT_AUDIO_BANK( const char* audioBank) { invoke<void )
	{
		AUDIO::RELEASE_NAMED_SCRIPT_AUDIO_BANK(invoke<void);
	}

	void LUA_NATIVE_AUDIO_RELEASE_SCRIPT_AUDIO_BANK(  )
	{
		AUDIO::RELEASE_SCRIPT_AUDIO_BANK();
	}

	void LUA_NATIVE_AUDIO_UNHINT_AMBIENT_AUDIO_BANK(  )
	{
		AUDIO::UNHINT_AMBIENT_AUDIO_BANK();
	}

	void LUA_NATIVE_AUDIO_UNHINT_SCRIPT_AUDIO_BANK(  )
	{
		AUDIO::UNHINT_SCRIPT_AUDIO_BANK();
	}

	void LUA_NATIVE_AUDIO_UNHINT_NAMED_SCRIPT_AUDIO_BANK( const char* audioBank) { invoke<void )
	{
		AUDIO::UNHINT_NAMED_SCRIPT_AUDIO_BANK(invoke<void);
	}

	int LUA_NATIVE_AUDIO_GET_SOUND_ID(  )
	{
		auto retval = AUDIO::GET_SOUND_ID();
		return retval;
	}

	void LUA_NATIVE_AUDIO_RELEASE_SOUND_ID( int soundId) { invoke<void )
	{
		AUDIO::RELEASE_SOUND_ID(invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_SOUND( int soundId, const char* audioName, const char* audioRef, bool p3, Any p4, bool p5) { invoke<void )
	{
		AUDIO::PLAY_SOUND(soundId, audioName, audioRef, p3, p4, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_SOUND_FRONTEND( int soundId, const char* audioName, const char* audioRef, bool p3) { invoke<void )
	{
		AUDIO::PLAY_SOUND_FRONTEND(soundId, audioName, audioRef, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_DEFERRED_SOUND_FRONTEND( const char* soundName, const char* soundsetName) { invoke<void )
	{
		AUDIO::PLAY_DEFERRED_SOUND_FRONTEND(soundName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_SOUND_FROM_ENTITY( int soundId, const char* audioName, int entity, const char* audioRef, bool isNetwork, Any p5) { invoke<void )
	{
		AUDIO::PLAY_SOUND_FROM_ENTITY(soundId, audioName, entity, audioRef, isNetwork, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_SOUND_FROM_ENTITY_HASH( int soundId, unsigned model, int entity, unsigned soundSetHash, Any p4, Any p5) { invoke<void )
	{
		AUDIO::PLAY_SOUND_FROM_ENTITY_HASH(soundId, model, entity, soundSetHash, p4, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_SOUND_FROM_COORD( int soundId, const char* audioName, float x, float y, float z, const char* audioRef, bool isNetwork, int range, bool p8) { invoke<void )
	{
		AUDIO::PLAY_SOUND_FROM_COORD(soundId, audioName, x, y, z, audioRef, isNetwork, range, invoke<void);
	}

	void LUA_NATIVE_AUDIO_UPDATE_SOUND_COORD( int soundId, float x, float y, float z) { invoke<void )
	{
		AUDIO::UPDATE_SOUND_COORD(soundId, x, y, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_SOUND( int soundId) { invoke<void )
	{
		AUDIO::STOP_SOUND(invoke<void);
	}

	int LUA_NATIVE_AUDIO_GET_NETWORK_ID_FROM_SOUND_ID( int soundId) { return invoke<int )
	{
		auto retval = AUDIO::GET_NETWORK_ID_FROM_SOUND_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_SOUND_ID_FROM_NETWORK_ID( int netId) { return invoke<int )
	{
		auto retval = AUDIO::GET_SOUND_ID_FROM_NETWORK_ID(invoke<int);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VARIABLE_ON_SOUND( int soundId, const char* variable, float p2) { invoke<void )
	{
		AUDIO::SET_VARIABLE_ON_SOUND(soundId, variable, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VARIABLE_ON_STREAM( const char* variable, float p1) { invoke<void )
	{
		AUDIO::SET_VARIABLE_ON_STREAM(variable, invoke<void);
	}

	void LUA_NATIVE_AUDIO_OVERRIDE_UNDERWATER_STREAM( const char* p0, bool p1) { invoke<void )
	{
		AUDIO::OVERRIDE_UNDERWATER_STREAM(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VARIABLE_ON_UNDER_WATER_STREAM( const char* variableName, float value) { invoke<void )
	{
		AUDIO::SET_VARIABLE_ON_UNDER_WATER_STREAM(variableName, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_HAS_SOUND_FINISHED( int soundId) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::HAS_SOUND_FINISHED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_PLAY_PED_AMBIENT_SPEECH_NATIVE( int ped, const char* speechName, const char* speechParam, Any p3) { invoke<void )
	{
		AUDIO::PLAY_PED_AMBIENT_SPEECH_NATIVE(ped, speechName, speechParam, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_PED_AMBIENT_SPEECH_AND_CLONE_NATIVE( int ped, const char* speechName, const char* speechParam, Any p3) { invoke<void )
	{
		AUDIO::PLAY_PED_AMBIENT_SPEECH_AND_CLONE_NATIVE(ped, speechName, speechParam, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_PED_AMBIENT_SPEECH_WITH_VOICE_NATIVE( int ped, const char* speechName, const char* voiceName, const char* speechParam, bool p4) { invoke<void )
	{
		AUDIO::PLAY_PED_AMBIENT_SPEECH_WITH_VOICE_NATIVE(ped, speechName, voiceName, speechParam, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_AMBIENT_SPEECH_FROM_POSITION_NATIVE( const char* speechName, const char* voiceName, float x, float y, float z, const char* speechParam) { invoke<void )
	{
		AUDIO::PLAY_AMBIENT_SPEECH_FROM_POSITION_NATIVE(speechName, voiceName, x, y, z, invoke<void);
	}

	void LUA_NATIVE_AUDIO_OVERRIDE_TREVOR_RAGE( const char* voiceEffect) { invoke<void )
	{
		AUDIO::OVERRIDE_TREVOR_RAGE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_RESET_TREVOR_RAGE(  )
	{
		AUDIO::RESET_TREVOR_RAGE();
	}

	void LUA_NATIVE_AUDIO_SET_PLAYER_ANGRY( int ped, bool toggle) { invoke<void )
	{
		AUDIO::SET_PLAYER_ANGRY(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_PAIN( int ped, int painID, int p1, Any p3) { invoke<void )
	{
		AUDIO::PLAY_PAIN(ped, painID, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_RELEASE_WEAPON_AUDIO(  )
	{
		AUDIO::RELEASE_WEAPON_AUDIO();
	}

	void LUA_NATIVE_AUDIO_ACTIVATE_AUDIO_SLOWMO_MODE( const char* mode) { invoke<void )
	{
		AUDIO::ACTIVATE_AUDIO_SLOWMO_MODE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_DEACTIVATE_AUDIO_SLOWMO_MODE( const char* mode) { invoke<void )
	{
		AUDIO::DEACTIVATE_AUDIO_SLOWMO_MODE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_VOICE_NAME( int ped, const char* name) { invoke<void )
	{
		AUDIO::SET_AMBIENT_VOICE_NAME(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_VOICE_NAME_HASH( int ped, unsigned hash) { invoke<void )
	{
		AUDIO::SET_AMBIENT_VOICE_NAME_HASH(ped, invoke<void);
	}

	unsigned LUA_NATIVE_AUDIO_GET_AMBIENT_VOICE_NAME_HASH( int ped) { return invoke<unsigned )
	{
		auto retval = AUDIO::GET_AMBIENT_VOICE_NAME_HASH(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_PED_VOICE_FULL( int ped) { invoke<void )
	{
		AUDIO::SET_PED_VOICE_FULL(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_RACE_AND_VOICE_GROUP( int ped, int p1, unsigned voiceGroup) { invoke<void )
	{
		AUDIO::SET_PED_RACE_AND_VOICE_GROUP(ped, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_VOICE_GROUP( int ped, unsigned voiceGroupHash) { invoke<void )
	{
		AUDIO::SET_PED_VOICE_GROUP(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_VOICE_GROUP_FROM_RACE_TO_PVG( int ped, unsigned voiceGroupHash) { invoke<void )
	{
		AUDIO::SET_PED_VOICE_GROUP_FROM_RACE_TO_PVG(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_GENDER( int ped, bool p1) { invoke<void )
	{
		AUDIO::SET_PED_GENDER(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_CURRENT_PLAYING_SPEECH( int ped) { invoke<void )
	{
		AUDIO::STOP_CURRENT_PLAYING_SPEECH(invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_CURRENT_PLAYING_AMBIENT_SPEECH( int ped) { invoke<void )
	{
		AUDIO::STOP_CURRENT_PLAYING_AMBIENT_SPEECH(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_AMBIENT_SPEECH_PLAYING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_AMBIENT_SPEECH_PLAYING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_SCRIPTED_SPEECH_PLAYING( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_SCRIPTED_SPEECH_PLAYING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_ANY_SPEECH_PLAYING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_ANY_SPEECH_PLAYING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_ANY_POSITIONAL_SPEECH_PLAYING(  )
	{
		auto retval = (bool)AUDIO::IS_ANY_POSITIONAL_SPEECH_PLAYING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_DOES_CONTEXT_EXIST_FOR_THIS_PED( int ped, const char* speechName, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::DOES_CONTEXT_EXIST_FOR_THIS_PED(ped, speechName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_PED_IN_CURRENT_CONVERSATION( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_PED_IN_CURRENT_CONVERSATION(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_PED_IS_DRUNK( int ped, bool toggle) { invoke<void )
	{
		AUDIO::SET_PED_IS_DRUNK(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_ANIMAL_VOCALIZATION( int pedHandle, int p1, const char* speechName) { invoke<void )
	{
		AUDIO::PLAY_ANIMAL_VOCALIZATION(pedHandle, p1, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_ANIMAL_VOCALIZATION_PLAYING( int pedHandle) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_ANIMAL_VOCALIZATION_PLAYING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_ANIMAL_MOOD( int animal, int mood) { invoke<void )
	{
		AUDIO::SET_ANIMAL_MOOD(animal, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_MOBILE_PHONE_RADIO_ACTIVE(  )
	{
		auto retval = (bool)AUDIO::IS_MOBILE_PHONE_RADIO_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_MOBILE_PHONE_RADIO_STATE( bool state) { invoke<void )
	{
		AUDIO::SET_MOBILE_PHONE_RADIO_STATE(invoke<void);
	}

	int LUA_NATIVE_AUDIO_GET_PLAYER_RADIO_STATION_INDEX(  )
	{
		auto retval = AUDIO::GET_PLAYER_RADIO_STATION_INDEX();
		return retval;
	}

	const char* LUA_NATIVE_AUDIO_GET_PLAYER_RADIO_STATION_NAME(  )
	{
		auto retval = AUDIO::GET_PLAYER_RADIO_STATION_NAME();
		return retval;
	}

	const char* LUA_NATIVE_AUDIO_GET_RADIO_STATION_NAME( int radioStation) { return invoke<const char* )
	{
		auto retval = AUDIO::GET_RADIO_STATION_NAME(char*);
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_PLAYER_RADIO_STATION_GENRE(  )
	{
		auto retval = AUDIO::GET_PLAYER_RADIO_STATION_GENRE();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_RADIO_RETUNING(  )
	{
		auto retval = (bool)AUDIO::IS_RADIO_RETUNING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_RADIO_FADED_OUT(  )
	{
		auto retval = (bool)AUDIO::IS_RADIO_FADED_OUT();
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_RETUNE_UP(  )
	{
		AUDIO::SET_RADIO_RETUNE_UP();
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_RETUNE_DOWN(  )
	{
		AUDIO::SET_RADIO_RETUNE_DOWN();
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_TO_STATION_NAME( const char* stationName) { invoke<void )
	{
		AUDIO::SET_RADIO_TO_STATION_NAME(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEH_RADIO_STATION( int vehicle, const char* radioStation) { invoke<void )
	{
		AUDIO::SET_VEH_RADIO_STATION(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEH_HAS_NORMAL_RADIO( int vehicle) { invoke<void )
	{
		AUDIO::SET_VEH_HAS_NORMAL_RADIO(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_VEHICLE_RADIO_ON( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_VEHICLE_RADIO_ON(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VEH_FORCED_RADIO_THIS_FRAME( int vehicle) { invoke<void )
	{
		AUDIO::SET_VEH_FORCED_RADIO_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_EMITTER_RADIO_STATION( const char* emitterName, const char* radioStation, Any p2) { invoke<void )
	{
		AUDIO::SET_EMITTER_RADIO_STATION(emitterName, radioStation, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_STATIC_EMITTER_ENABLED( const char* emitterName, bool toggle) { invoke<void )
	{
		AUDIO::SET_STATIC_EMITTER_ENABLED(emitterName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_LINK_STATIC_EMITTER_TO_ENTITY( const char* emitterName, int entity) { invoke<void )
	{
		AUDIO::LINK_STATIC_EMITTER_TO_ENTITY(emitterName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_TO_STATION_INDEX( int radioStation) { invoke<void )
	{
		AUDIO::SET_RADIO_TO_STATION_INDEX(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_FRONTEND_RADIO_ACTIVE( bool active) { invoke<void )
	{
		AUDIO::SET_FRONTEND_RADIO_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNLOCK_MISSION_NEWS_STORY( int newsStory) { invoke<void )
	{
		AUDIO::UNLOCK_MISSION_NEWS_STORY(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_MISSION_NEWS_STORY_UNLOCKED( int newsStory) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_MISSION_NEWS_STORY_UNLOCKED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_AUDIBLE_MUSIC_TRACK_TEXT_ID(  )
	{
		auto retval = AUDIO::GET_AUDIBLE_MUSIC_TRACK_TEXT_ID();
		return retval;
	}

	void LUA_NATIVE_AUDIO_PLAY_END_CREDITS_MUSIC( bool play) { invoke<void )
	{
		AUDIO::PLAY_END_CREDITS_MUSIC(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SKIP_RADIO_FORWARD(  )
	{
		AUDIO::SKIP_RADIO_FORWARD();
	}

	void LUA_NATIVE_AUDIO_FREEZE_RADIO_STATION( const char* radioStation) { invoke<void )
	{
		AUDIO::FREEZE_RADIO_STATION(invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNFREEZE_RADIO_STATION( const char* radioStation) { invoke<void )
	{
		AUDIO::UNFREEZE_RADIO_STATION(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_AUTO_UNFREEZE( bool toggle) { invoke<void )
	{
		AUDIO::SET_RADIO_AUTO_UNFREEZE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_INITIAL_PLAYER_STATION( const char* radioStation) { invoke<void )
	{
		AUDIO::SET_INITIAL_PLAYER_STATION(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_USER_RADIO_CONTROL_ENABLED( bool toggle) { invoke<void )
	{
		AUDIO::SET_USER_RADIO_CONTROL_ENABLED(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_TRACK( const char* radioStation, const char* radioTrack) { invoke<void )
	{
		AUDIO::SET_RADIO_TRACK(radioStation, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_TRACK_WITH_START_OFFSET( const char* radioStationName, const char* mixName, int p2) { invoke<void )
	{
		AUDIO::SET_RADIO_TRACK_WITH_START_OFFSET(radioStationName, mixName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_NEXT_RADIO_TRACK( const char* radioName, const char* radioTrack, const char* p2, const char* p3) { invoke<void )
	{
		AUDIO::SET_NEXT_RADIO_TRACK(radioName, radioTrack, p2, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_RADIO_LOUD( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_VEHICLE_RADIO_LOUD(vehicle, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_CAN_VEHICLE_RECEIVE_CB_RADIO( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::CAN_VEHICLE_RECEIVE_CB_RADIO(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_MOBILE_RADIO_ENABLED_DURING_GAMEPLAY( bool toggle) { invoke<void )
	{
		AUDIO::SET_MOBILE_RADIO_ENABLED_DURING_GAMEPLAY(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_DOES_PLAYER_VEH_HAVE_RADIO(  )
	{
		auto retval = (bool)AUDIO::DOES_PLAYER_VEH_HAVE_RADIO();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_PLAYER_VEH_RADIO_ENABLE(  )
	{
		auto retval = (bool)AUDIO::IS_PLAYER_VEH_RADIO_ENABLE();
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_RADIO_ENABLED( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_VEHICLE_RADIO_ENABLED(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_POSITIONED_PLAYER_VEHICLE_RADIO_EMITTER_ENABLED( Any p0) { invoke<void )
	{
		AUDIO::SET_POSITIONED_PLAYER_VEHICLE_RADIO_EMITTER_ENABLED(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_CUSTOM_RADIO_TRACK_LIST( const char* radioStation, const char* trackListName, bool p2) { invoke<void )
	{
		AUDIO::SET_CUSTOM_RADIO_TRACK_LIST(radioStation, trackListName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_CLEAR_CUSTOM_RADIO_TRACK_LIST( const char* radioStation) { invoke<void )
	{
		AUDIO::CLEAR_CUSTOM_RADIO_TRACK_LIST(invoke<void);
	}

	int LUA_NATIVE_AUDIO_GET_NUM_UNLOCKED_RADIO_STATIONS(  )
	{
		auto retval = AUDIO::GET_NUM_UNLOCKED_RADIO_STATIONS();
		return retval;
	}

	int LUA_NATIVE_AUDIO_FIND_RADIO_STATION_INDEX( unsigned stationNameHash) { return invoke<int )
	{
		auto retval = AUDIO::FIND_RADIO_STATION_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_STATION_MUSIC_ONLY( const char* radioStation, bool toggle) { invoke<void )
	{
		AUDIO::SET_RADIO_STATION_MUSIC_ONLY(radioStation, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_FRONTEND_FADE_TIME( float fadeTime) { invoke<void )
	{
		AUDIO::SET_RADIO_FRONTEND_FADE_TIME(invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNLOCK_RADIO_STATION_TRACK_LIST( const char* radioStation, const char* trackListName) { invoke<void )
	{
		AUDIO::UNLOCK_RADIO_STATION_TRACK_LIST(radioStation, invoke<void);
	}

	void LUA_NATIVE_AUDIO_LOCK_RADIO_STATION_TRACK_LIST( const char* radioStation, const char* trackListName) { invoke<void )
	{
		AUDIO::LOCK_RADIO_STATION_TRACK_LIST(radioStation, invoke<void);
	}

	void LUA_NATIVE_AUDIO_UPDATE_UNLOCKABLE_DJ_RADIO_TRACKS( bool enableMixes) { invoke<void )
	{
		AUDIO::UPDATE_UNLOCKABLE_DJ_RADIO_TRACKS(invoke<void);
	}

	void LUA_NATIVE_AUDIO_LOCK_RADIO_STATION( const char* radioStationName, bool toggle) { invoke<void )
	{
		AUDIO::LOCK_RADIO_STATION(radioStationName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_STATION_AS_FAVOURITE( const char* radioStation, bool toggle) { invoke<void )
	{
		AUDIO::SET_RADIO_STATION_AS_FAVOURITE(radioStation, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_RADIO_STATION_FAVOURITED( const char* radioStation) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_RADIO_STATION_FAVOURITED(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, float, float, int out3) { return> LUA_NATIVE_AUDIO_GET_NEXT_AUDIBLE_BEAT( float out1, float out2, int out3) { return invoke<BOOL )
	{
		std::tuple<bool, float, float, int out3) { return> return_values;
		std::get<0>(return_values) = (bool)AUDIO::GET_NEXT_AUDIBLE_BEAT(&out1, &out2, &invoke<BOOL);
		std::get<1>(return_values) = out1;
		std::get<2>(return_values) = out2;
		std::get<3>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_AUDIO_FORCE_MUSIC_TRACK_LIST( const char* radioStation, const char* trackListName, int milliseconds) { invoke<void )
	{
		AUDIO::FORCE_MUSIC_TRACK_LIST(radioStation, trackListName, invoke<void);
	}

	int LUA_NATIVE_AUDIO_GET_CURRENT_TRACK_PLAY_TIME( const char* radioStationName) { return invoke<int )
	{
		auto retval = AUDIO::GET_CURRENT_TRACK_PLAY_TIME(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_AUDIO_GET_CURRENT_TRACK_SOUND_NAME( const char* radioStationName) { return invoke<unsigned )
	{
		auto retval = AUDIO::GET_CURRENT_TRACK_SOUND_NAME(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_MISSILE_WARNING_ENABLED( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_VEHICLE_MISSILE_WARNING_ENABLED(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_ZONE_STATE( const char* zoneName, bool p1, bool p2) { invoke<void )
	{
		AUDIO::SET_AMBIENT_ZONE_STATE(zoneName, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_CLEAR_AMBIENT_ZONE_STATE( const char* zoneName, bool p1) { invoke<void )
	{
		AUDIO::CLEAR_AMBIENT_ZONE_STATE(zoneName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_ZONE_LIST_STATE( const char* ambientZone, bool p1, bool p2) { invoke<void )
	{
		AUDIO::SET_AMBIENT_ZONE_LIST_STATE(ambientZone, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_CLEAR_AMBIENT_ZONE_LIST_STATE( const char* ambientZone, bool p1) { invoke<void )
	{
		AUDIO::CLEAR_AMBIENT_ZONE_LIST_STATE(ambientZone, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_ZONE_STATE_PERSISTENT( const char* ambientZone, bool p1, bool p2) { invoke<void )
	{
		AUDIO::SET_AMBIENT_ZONE_STATE_PERSISTENT(ambientZone, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AMBIENT_ZONE_LIST_STATE_PERSISTENT( const char* ambientZone, bool p1, bool p2) { invoke<void )
	{
		AUDIO::SET_AMBIENT_ZONE_LIST_STATE_PERSISTENT(ambientZone, p1, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_AMBIENT_ZONE_ENABLED( const char* ambientZone) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_AMBIENT_ZONE_ENABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_REFRESH_CLOSEST_OCEAN_SHORELINE(  )
	{
		AUDIO::REFRESH_CLOSEST_OCEAN_SHORELINE();
	}

	void LUA_NATIVE_AUDIO_SET_CUTSCENE_AUDIO_OVERRIDE( const char* name) { invoke<void )
	{
		AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VARIABLE_ON_SYNCH_SCENE_AUDIO( const char* variableName, float value) { invoke<void )
	{
		AUDIO::SET_VARIABLE_ON_SYNCH_SCENE_AUDIO(variableName, invoke<void);
	}

	int LUA_NATIVE_AUDIO_PLAY_POLICE_REPORT( const char* name, float p1) { return invoke<int )
	{
		auto retval = AUDIO::PLAY_POLICE_REPORT(name, invoke<int);
		return retval;
	}

	void LUA_NATIVE_AUDIO_CANCEL_ALL_POLICE_REPORTS(  )
	{
		AUDIO::CANCEL_ALL_POLICE_REPORTS();
	}

	void LUA_NATIVE_AUDIO_BLIP_SIREN( int vehicle) { invoke<void )
	{
		AUDIO::BLIP_SIREN(invoke<void);
	}

	void LUA_NATIVE_AUDIO_OVERRIDE_VEH_HORN( int vehicle, bool override, int hornHash) { invoke<void )
	{
		AUDIO::OVERRIDE_VEH_HORN(vehicle, override, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_HORN_ACTIVE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_HORN_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_AGGRESSIVE_HORNS( bool toggle) { invoke<void )
	{
		AUDIO::SET_AGGRESSIVE_HORNS(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_RADIO_POSITION_AUDIO_MUTE( bool p0) { invoke<void )
	{
		AUDIO::SET_RADIO_POSITION_AUDIO_MUTE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_CONVERSATIONS_PERSIST( bool p0, bool p1) { invoke<void )
	{
		AUDIO::SET_VEHICLE_CONVERSATIONS_PERSIST(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_CONVERSATIONS_PERSIST_NEW( bool p0, bool p1, bool p2) { invoke<void )
	{
		AUDIO::SET_VEHICLE_CONVERSATIONS_PERSIST_NEW(p0, p1, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_STREAM_PLAYING(  )
	{
		auto retval = (bool)AUDIO::IS_STREAM_PLAYING();
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_STREAM_PLAY_TIME(  )
	{
		auto retval = AUDIO::GET_STREAM_PLAY_TIME();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_LOAD_STREAM( const char* streamName, const char* soundSet) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::LOAD_STREAM(streamName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_LOAD_STREAM_WITH_START_OFFSET( const char* streamName, int startOffset, const char* soundSet) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::LOAD_STREAM_WITH_START_OFFSET(streamName, startOffset, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_PLAY_STREAM_FROM_PED( int ped) { invoke<void )
	{
		AUDIO::PLAY_STREAM_FROM_PED(invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_STREAM_FROM_VEHICLE( int vehicle) { invoke<void )
	{
		AUDIO::PLAY_STREAM_FROM_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_STREAM_FROM_OBJECT( Object object) { invoke<void )
	{
		AUDIO::PLAY_STREAM_FROM_OBJECT(invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_STREAM_FRONTEND(  )
	{
		AUDIO::PLAY_STREAM_FRONTEND();
	}

	void LUA_NATIVE_AUDIO_PLAY_STREAM_FROM_POSITION( float x, float y, float z) { invoke<void )
	{
		AUDIO::PLAY_STREAM_FROM_POSITION(x, y, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_STREAM(  )
	{
		AUDIO::STOP_STREAM();
	}

	void LUA_NATIVE_AUDIO_STOP_PED_SPEAKING( int ped, bool shaking) { invoke<void )
	{
		AUDIO::STOP_PED_SPEAKING(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_BLOCK_ALL_SPEECH_FROM_PED( int ped, bool p1, bool p2) { invoke<void )
	{
		AUDIO::BLOCK_ALL_SPEECH_FROM_PED(ped, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_PED_SPEAKING_SYNCED( int ped, bool p1) { invoke<void )
	{
		AUDIO::STOP_PED_SPEAKING_SYNCED(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_DISABLE_PED_PAIN_AUDIO( int ped, bool toggle) { invoke<void )
	{
		AUDIO::DISABLE_PED_PAIN_AUDIO(ped, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_AMBIENT_SPEECH_DISABLED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_AMBIENT_SPEECH_DISABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_BLOCK_SPEECH_CONTEXT_GROUP( const char* p0, int p1) { invoke<void )
	{
		AUDIO::BLOCK_SPEECH_CONTEXT_GROUP(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNBLOCK_SPEECH_CONTEXT_GROUP( const char* p0) { invoke<void )
	{
		AUDIO::UNBLOCK_SPEECH_CONTEXT_GROUP(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_SIREN_WITH_NO_DRIVER( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_SIREN_WITH_NO_DRIVER(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_SIREN_BYPASS_MP_DRIVER_CHECK( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_SIREN_BYPASS_MP_DRIVER_CHECK(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_TRIGGER_SIREN_AUDIO( int vehicle) { invoke<void )
	{
		AUDIO::TRIGGER_SIREN_AUDIO(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_HORN_PERMANENTLY_ON( int vehicle) { invoke<void )
	{
		AUDIO::SET_HORN_PERMANENTLY_ON(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_HORN_ENABLED( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_HORN_ENABLED(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AUDIO_VEHICLE_PRIORITY( int vehicle, Any p1) { invoke<void )
	{
		AUDIO::SET_AUDIO_VEHICLE_PRIORITY(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_HORN_PERMANENTLY_ON_TIME( int vehicle, float time) { invoke<void )
	{
		AUDIO::SET_HORN_PERMANENTLY_ON_TIME(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_USE_SIREN_AS_HORN( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::USE_SIREN_AS_HORN(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_FORCE_USE_AUDIO_GAME_OBJECT( int vehicle, const char* audioName) { invoke<void )
	{
		AUDIO::FORCE_USE_AUDIO_GAME_OBJECT(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PRELOAD_VEHICLE_AUDIO_BANK( unsigned vehicleModel) { invoke<void )
	{
		AUDIO::PRELOAD_VEHICLE_AUDIO_BANK(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_STARTUP_REV_SOUND( int vehicle, const char* p1, const char* p2) { invoke<void )
	{
		AUDIO::SET_VEHICLE_STARTUP_REV_SOUND(vehicle, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_RESET_VEHICLE_STARTUP_REV_SOUND( int vehicle) { invoke<void )
	{
		AUDIO::RESET_VEHICLE_STARTUP_REV_SOUND(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_FORCE_REVERSE_WARNING( Any p0, Any p1) { invoke<void )
	{
		AUDIO::SET_VEHICLE_FORCE_REVERSE_WARNING(p0, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_VEHICLE_AUDIBLY_DAMAGED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_VEHICLE_AUDIBLY_DAMAGED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_AUDIO_ENGINE_DAMAGE_FACTOR( int vehicle, float damageFactor) { invoke<void )
	{
		AUDIO::SET_VEHICLE_AUDIO_ENGINE_DAMAGE_FACTOR(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_AUDIO_BODY_DAMAGE_FACTOR( int vehicle, float intensity) { invoke<void )
	{
		AUDIO::SET_VEHICLE_AUDIO_BODY_DAMAGE_FACTOR(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_ENABLE_VEHICLE_FANBELT_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::ENABLE_VEHICLE_FANBELT_DAMAGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_ENABLE_VEHICLE_EXHAUST_POPS( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::ENABLE_VEHICLE_EXHAUST_POPS(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_BOOST_ACTIVE( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_VEHICLE_BOOST_ACTIVE(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PLAYER_VEHICLE_ALARM_AUDIO_ACTIVE( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::SET_PLAYER_VEHICLE_ALARM_AUDIO_ACTIVE(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_SCRIPT_UPDATE_DOOR_AUDIO( unsigned doorHash, bool toggle) { invoke<void )
	{
		AUDIO::SET_SCRIPT_UPDATE_DOOR_AUDIO(doorHash, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_VEHICLE_DOOR_OPEN_SOUND( int vehicle, int doorId) { invoke<void )
	{
		AUDIO::PLAY_VEHICLE_DOOR_OPEN_SOUND(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_VEHICLE_DOOR_CLOSE_SOUND( int vehicle, int doorId) { invoke<void )
	{
		AUDIO::PLAY_VEHICLE_DOOR_CLOSE_SOUND(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_ENABLE_STALL_WARNING_SOUNDS( int vehicle, bool toggle) { invoke<void )
	{
		AUDIO::ENABLE_STALL_WARNING_SOUNDS(vehicle, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_GAME_IN_CONTROL_OF_MUSIC(  )
	{
		auto retval = (bool)AUDIO::IS_GAME_IN_CONTROL_OF_MUSIC();
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_GPS_ACTIVE( bool active) { invoke<void )
	{
		AUDIO::SET_GPS_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_PLAY_MISSION_COMPLETE_AUDIO( const char* audioName) { invoke<void )
	{
		AUDIO::PLAY_MISSION_COMPLETE_AUDIO(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_MISSION_COMPLETE_PLAYING(  )
	{
		auto retval = (bool)AUDIO::IS_MISSION_COMPLETE_PLAYING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_MISSION_COMPLETE_READY_FOR_UI(  )
	{
		auto retval = (bool)AUDIO::IS_MISSION_COMPLETE_READY_FOR_UI();
		return retval;
	}

	void LUA_NATIVE_AUDIO_BLOCK_DEATH_JINGLE( bool toggle) { invoke<void )
	{
		AUDIO::BLOCK_DEATH_JINGLE(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_START_AUDIO_SCENE( const char* scene) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::START_AUDIO_SCENE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_STOP_AUDIO_SCENE( const char* scene) { invoke<void )
	{
		AUDIO::STOP_AUDIO_SCENE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_AUDIO_SCENES(  )
	{
		AUDIO::STOP_AUDIO_SCENES();
	}

	bool LUA_NATIVE_AUDIO_IS_AUDIO_SCENE_ACTIVE( const char* scene) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_AUDIO_SCENE_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_AUDIO_SCENE_VARIABLE( const char* scene, const char* variable, float value) { invoke<void )
	{
		AUDIO::SET_AUDIO_SCENE_VARIABLE(scene, variable, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AUDIO_SCRIPT_CLEANUP_TIME( int time) { invoke<void )
	{
		AUDIO::SET_AUDIO_SCRIPT_CLEANUP_TIME(invoke<void);
	}

	void LUA_NATIVE_AUDIO_ADD_ENTITY_TO_AUDIO_MIX_GROUP( int entity, const char* groupName, float p2) { invoke<void )
	{
		AUDIO::ADD_ENTITY_TO_AUDIO_MIX_GROUP(entity, groupName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_REMOVE_ENTITY_FROM_AUDIO_MIX_GROUP( int entity, float p1) { invoke<void )
	{
		AUDIO::REMOVE_ENTITY_FROM_AUDIO_MIX_GROUP(entity, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_AUDIO_IS_MUSIC_PLAYING(  )
	{
		auto retval = (bool)AUDIO::AUDIO_IS_MUSIC_PLAYING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_AUDIO_IS_SCRIPTED_MUSIC_PLAYING(  )
	{
		auto retval = (bool)AUDIO::AUDIO_IS_SCRIPTED_MUSIC_PLAYING();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_PREPARE_MUSIC_EVENT( const char* eventName) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::PREPARE_MUSIC_EVENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_CANCEL_MUSIC_EVENT( const char* eventName) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::CANCEL_MUSIC_EVENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_TRIGGER_MUSIC_EVENT( const char* eventName) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::TRIGGER_MUSIC_EVENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_IS_MUSIC_ONESHOT_PLAYING(  )
	{
		auto retval = (bool)AUDIO::IS_MUSIC_ONESHOT_PLAYING();
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_MUSIC_PLAYTIME(  )
	{
		auto retval = AUDIO::GET_MUSIC_PLAYTIME();
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_GLOBAL_RADIO_SIGNAL_LEVEL( Any p0) { invoke<void )
	{
		AUDIO::SET_GLOBAL_RADIO_SIGNAL_LEVEL(invoke<void);
	}

	void LUA_NATIVE_AUDIO_RECORD_BROKEN_GLASS( float x, float y, float z, float radius) { invoke<void )
	{
		AUDIO::RECORD_BROKEN_GLASS(x, y, z, invoke<void);
	}

	void LUA_NATIVE_AUDIO_CLEAR_ALL_BROKEN_GLASS(  )
	{
		AUDIO::CLEAR_ALL_BROKEN_GLASS();
	}

	void LUA_NATIVE_AUDIO_SCRIPT_OVERRIDES_WIND_ELEVATION( bool p0, Any p1) { invoke<void )
	{
		AUDIO::SCRIPT_OVERRIDES_WIND_ELEVATION(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_WALLA_DENSITY( float p0, float p1) { invoke<void )
	{
		AUDIO::SET_PED_WALLA_DENSITY(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_INTERIOR_WALLA_DENSITY( float p0, float p1) { invoke<void )
	{
		AUDIO::SET_PED_INTERIOR_WALLA_DENSITY(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_FORCE_PED_PANIC_WALLA(  )
	{
		AUDIO::FORCE_PED_PANIC_WALLA();
	}

	bool LUA_NATIVE_AUDIO_PREPARE_ALARM( const char* alarmName) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::PREPARE_ALARM(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_START_ALARM( const char* alarmName, bool p2) { invoke<void )
	{
		AUDIO::START_ALARM(alarmName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_ALARM( const char* alarmName, bool toggle) { invoke<void )
	{
		AUDIO::STOP_ALARM(alarmName, invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_ALL_ALARMS( bool stop) { invoke<void )
	{
		AUDIO::STOP_ALL_ALARMS(invoke<void);
	}

	bool LUA_NATIVE_AUDIO_IS_ALARM_PLAYING( const char* alarmName) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::IS_ALARM_PLAYING(invoke<BOOL);
		return retval;
	}

	unsigned LUA_NATIVE_AUDIO_GET_VEHICLE_DEFAULT_HORN( int vehicle) { return invoke<unsigned )
	{
		auto retval = AUDIO::GET_VEHICLE_DEFAULT_HORN(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_AUDIO_GET_VEHICLE_DEFAULT_HORN_IGNORE_MODS( int vehicle) { return invoke<unsigned )
	{
		auto retval = AUDIO::GET_VEHICLE_DEFAULT_HORN_IGNORE_MODS(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_AUDIO_RESET_PED_AUDIO_FLAGS( int ped) { invoke<void )
	{
		AUDIO::RESET_PED_AUDIO_FLAGS(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_FOOTSTEPS_EVENTS_ENABLED( int ped, bool toggle) { invoke<void )
	{
		AUDIO::SET_PED_FOOTSTEPS_EVENTS_ENABLED(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PED_CLOTH_EVENTS_ENABLED( int ped, bool toggle) { invoke<void )
	{
		AUDIO::SET_PED_CLOTH_EVENTS_ENABLED(ped, invoke<void);
	}

	void LUA_NATIVE_AUDIO_OVERRIDE_PLAYER_GROUND_MATERIAL( unsigned hash, bool toggle) { invoke<void )
	{
		AUDIO::OVERRIDE_PLAYER_GROUND_MATERIAL(hash, invoke<void);
	}

	void LUA_NATIVE_AUDIO_USE_FOOTSTEP_SCRIPT_SWEETENERS( int ped, bool p1, unsigned hash) { invoke<void )
	{
		AUDIO::USE_FOOTSTEP_SCRIPT_SWEETENERS(ped, p1, invoke<void);
	}

	void LUA_NATIVE_AUDIO_OVERRIDE_MICROPHONE_SETTINGS( unsigned hash, bool toggle) { invoke<void )
	{
		AUDIO::OVERRIDE_MICROPHONE_SETTINGS(hash, invoke<void);
	}

	void LUA_NATIVE_AUDIO_FREEZE_MICROPHONE(  )
	{
		AUDIO::FREEZE_MICROPHONE();
	}

	void LUA_NATIVE_AUDIO_DISTANT_COP_CAR_SIRENS( bool value) { invoke<void )
	{
		AUDIO::DISTANT_COP_CAR_SIRENS(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_SIREN_CAN_BE_CONTROLLED_BY_AUDIO( int vehicle, bool p1) { invoke<void )
	{
		AUDIO::SET_SIREN_CAN_BE_CONTROLLED_BY_AUDIO(vehicle, invoke<void);
	}

	void LUA_NATIVE_AUDIO_ENABLE_STUNT_JUMP_AUDIO(  )
	{
		AUDIO::ENABLE_STUNT_JUMP_AUDIO();
	}

	void LUA_NATIVE_AUDIO_SET_AUDIO_FLAG( const char* flagName, bool toggle) { invoke<void )
	{
		AUDIO::SET_AUDIO_FLAG(flagName, invoke<void);
	}

	bool LUA_NATIVE_AUDIO_PREPARE_SYNCHRONIZED_AUDIO_EVENT( const char* audioEvent, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::PREPARE_SYNCHRONIZED_AUDIO_EVENT(audioEvent, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_PREPARE_SYNCHRONIZED_AUDIO_EVENT_FOR_SCENE( int sceneID, const char* audioEvent) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::PREPARE_SYNCHRONIZED_AUDIO_EVENT_FOR_SCENE(sceneID, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_PLAY_SYNCHRONIZED_AUDIO_EVENT( int sceneID) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::PLAY_SYNCHRONIZED_AUDIO_EVENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_AUDIO_STOP_SYNCHRONIZED_AUDIO_EVENT( int sceneID) { return invoke<BOOL )
	{
		auto retval = (bool)AUDIO::STOP_SYNCHRONIZED_AUDIO_EVENT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_AUDIO_INIT_SYNCH_SCENE_AUDIO_WITH_POSITION( const char* audioEvent, float x, float y, float z) { invoke<void )
	{
		AUDIO::INIT_SYNCH_SCENE_AUDIO_WITH_POSITION(audioEvent, x, y, invoke<void);
	}

	void LUA_NATIVE_AUDIO_INIT_SYNCH_SCENE_AUDIO_WITH_ENTITY( const char* audioEvent, int entity) { invoke<void )
	{
		AUDIO::INIT_SYNCH_SCENE_AUDIO_WITH_ENTITY(audioEvent, invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_AUDIO_SPECIAL_EFFECT_MODE( int mode) { invoke<void )
	{
		AUDIO::SET_AUDIO_SPECIAL_EFFECT_MODE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_SET_PORTAL_SETTINGS_OVERRIDE( const char* p0, const char* p1) { invoke<void )
	{
		AUDIO::SET_PORTAL_SETTINGS_OVERRIDE(p0, invoke<void);
	}

	void LUA_NATIVE_AUDIO_REMOVE_PORTAL_SETTINGS_OVERRIDE( const char* p0) { invoke<void )
	{
		AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_SMOKE_GRENADE_EXPLOSION_SOUNDS(  )
	{
		AUDIO::STOP_SMOKE_GRENADE_EXPLOSION_SOUNDS();
	}

	int LUA_NATIVE_AUDIO_GET_MUSIC_VOL_SLIDER(  )
	{
		auto retval = AUDIO::GET_MUSIC_VOL_SLIDER();
		return retval;
	}

	void LUA_NATIVE_AUDIO_REQUEST_TENNIS_BANKS( int ped) { invoke<void )
	{
		AUDIO::REQUEST_TENNIS_BANKS(invoke<void);
	}

	void LUA_NATIVE_AUDIO_UNREQUEST_TENNIS_BANKS(  )
	{
		AUDIO::UNREQUEST_TENNIS_BANKS();
	}

	void LUA_NATIVE_AUDIO_SET_SKIP_MINIGUN_SPIN_UP_AUDIO( bool p0) { invoke<void )
	{
		AUDIO::SET_SKIP_MINIGUN_SPIN_UP_AUDIO(invoke<void);
	}

	void LUA_NATIVE_AUDIO_STOP_CUTSCENE_AUDIO(  )
	{
		AUDIO::STOP_CUTSCENE_AUDIO();
	}

	bool LUA_NATIVE_AUDIO_HAS_LOADED_MP_DATA_SET(  )
	{
		auto retval = (bool)AUDIO::HAS_LOADED_MP_DATA_SET();
		return retval;
	}

	bool LUA_NATIVE_AUDIO_HAS_LOADED_SP_DATA_SET(  )
	{
		auto retval = (bool)AUDIO::HAS_LOADED_SP_DATA_SET();
		return retval;
	}

	int LUA_NATIVE_AUDIO_GET_VEHICLE_HORN_SOUND_INDEX( int vehicle) { return invoke<int )
	{
		auto retval = AUDIO::GET_VEHICLE_HORN_SOUND_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_AUDIO_SET_VEHICLE_HORN_SOUND_INDEX( int vehicle, int value) { invoke<void )
	{
		AUDIO::SET_VEHICLE_HORN_SOUND_INDEX(vehicle, invoke<void);
	}

	void LUA_NATIVE_BRAIN_ADD_SCRIPT_TO_RANDOM_PED( const char* name, unsigned model, float p2, float p3) { invoke<void )
	{
		BRAIN::ADD_SCRIPT_TO_RANDOM_PED(name, model, p2, invoke<void);
	}

	void LUA_NATIVE_BRAIN_REGISTER_OBJECT_SCRIPT_BRAIN( const char* scriptName, unsigned modelHash, int p2, float activationRange, int p4, int p5) { invoke<void )
	{
		BRAIN::REGISTER_OBJECT_SCRIPT_BRAIN(scriptName, modelHash, p2, activationRange, p4, invoke<void);
	}

	bool LUA_NATIVE_BRAIN_IS_OBJECT_WITHIN_BRAIN_ACTIVATION_RANGE( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)BRAIN::IS_OBJECT_WITHIN_BRAIN_ACTIVATION_RANGE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_BRAIN_REGISTER_WORLD_POINT_SCRIPT_BRAIN( const char* scriptName, float activationRange, int p2) { invoke<void )
	{
		BRAIN::REGISTER_WORLD_POINT_SCRIPT_BRAIN(scriptName, activationRange, invoke<void);
	}

	bool LUA_NATIVE_BRAIN_IS_WORLD_POINT_WITHIN_BRAIN_ACTIVATION_RANGE(  )
	{
		auto retval = (bool)BRAIN::IS_WORLD_POINT_WITHIN_BRAIN_ACTIVATION_RANGE();
		return retval;
	}

	void LUA_NATIVE_BRAIN_ENABLE_SCRIPT_BRAIN_SET( int brainSet) { invoke<void )
	{
		BRAIN::ENABLE_SCRIPT_BRAIN_SET(invoke<void);
	}

	void LUA_NATIVE_BRAIN_DISABLE_SCRIPT_BRAIN_SET( int brainSet) { invoke<void )
	{
		BRAIN::DISABLE_SCRIPT_BRAIN_SET(invoke<void);
	}

	void LUA_NATIVE_BRAIN_REACTIVATE_ALL_WORLD_BRAINS_THAT_ARE_WAITING_TILL_OUT_OF_RANGE(  )
	{
		BRAIN::REACTIVATE_ALL_WORLD_BRAINS_THAT_ARE_WAITING_TILL_OUT_OF_RANGE();
	}

	void LUA_NATIVE_BRAIN_REACTIVATE_ALL_OBJECT_BRAINS_THAT_ARE_WAITING_TILL_OUT_OF_RANGE(  )
	{
		BRAIN::REACTIVATE_ALL_OBJECT_BRAINS_THAT_ARE_WAITING_TILL_OUT_OF_RANGE();
	}

	void LUA_NATIVE_BRAIN_REACTIVATE_NAMED_WORLD_BRAINS_WAITING_TILL_OUT_OF_RANGE( const char* scriptName) { invoke<void )
	{
		BRAIN::REACTIVATE_NAMED_WORLD_BRAINS_WAITING_TILL_OUT_OF_RANGE(invoke<void);
	}

	void LUA_NATIVE_BRAIN_REACTIVATE_NAMED_OBJECT_BRAINS_WAITING_TILL_OUT_OF_RANGE( const char* scriptName) { invoke<void )
	{
		BRAIN::REACTIVATE_NAMED_OBJECT_BRAINS_WAITING_TILL_OUT_OF_RANGE(invoke<void);
	}

	void LUA_NATIVE_CAM_RENDER_SCRIPT_CAMS( bool render, bool ease, int easeTime, bool p3, bool p4, Any p5) { invoke<void )
	{
		CAM::RENDER_SCRIPT_CAMS(render, ease, easeTime, p3, p4, invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_RENDERING_SCRIPT_CAMS_USING_CATCH_UP( bool render, float p1, int p2, Any p3) { invoke<void )
	{
		CAM::STOP_RENDERING_SCRIPT_CAMS_USING_CATCH_UP(render, p1, p2, invoke<void);
	}

	int LUA_NATIVE_CAM_CREATE_CAM( const char* camName, bool p1) { return invoke<int )
	{
		auto retval = CAM::CREATE_CAM(camName, invoke<int);
		return retval;
	}

	int LUA_NATIVE_CAM_CREATE_CAM_WITH_PARAMS( const char* camName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fov, bool p8, int p9) { return invoke<int )
	{
		auto retval = CAM::CREATE_CAM_WITH_PARAMS(camName, posX, posY, posZ, rotX, rotY, rotZ, fov, p8, invoke<int);
		return retval;
	}

	int LUA_NATIVE_CAM_CREATE_CAMERA( unsigned camHash, bool p1) { return invoke<int )
	{
		auto retval = CAM::CREATE_CAMERA(camHash, invoke<int);
		return retval;
	}

	int LUA_NATIVE_CAM_CREATE_CAMERA_WITH_PARAMS( unsigned camHash, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fov, bool p8, Any p9) { return invoke<int )
	{
		auto retval = CAM::CREATE_CAMERA_WITH_PARAMS(camHash, posX, posY, posZ, rotX, rotY, rotZ, fov, p8, invoke<int);
		return retval;
	}

	void LUA_NATIVE_CAM_DESTROY_CAM( int cam, bool bScriptHostCam) { invoke<void )
	{
		CAM::DESTROY_CAM(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_DESTROY_ALL_CAMS( bool bScriptHostCam) { invoke<void )
	{
		CAM::DESTROY_ALL_CAMS(invoke<void);
	}

	bool LUA_NATIVE_CAM_DOES_CAM_EXIST( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::DOES_CAM_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_ACTIVE( int cam, bool active) { invoke<void )
	{
		CAM::SET_CAM_ACTIVE(cam, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CAM_ACTIVE( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_CAM_RENDERING( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_RENDERING(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_CAM_GET_RENDERING_CAM(  )
	{
		auto retval = CAM::GET_RENDERING_CAM();
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_CAM_COORD( int cam) { return invoke<Vector3 )
	{
		auto retval = CAM::GET_CAM_COORD(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_CAM_ROT( int cam, int rotationOrder) { return invoke<Vector3 )
	{
		auto retval = CAM::GET_CAM_ROT(cam, invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_FOV( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_FOV(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_NEAR_CLIP( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_NEAR_CLIP(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_FAR_CLIP( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_FAR_CLIP(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_NEAR_DOF( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_NEAR_DOF(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_FAR_DOF( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_FAR_DOF(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_DOF_STRENGTH( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_DOF_STRENGTH(invoke<float);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_PARAMS( int cam, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fieldOfView, Any p8, int p9, int p10, int p11) { invoke<void )
	{
		CAM::SET_CAM_PARAMS(cam, posX, posY, posZ, rotX, rotY, rotZ, fieldOfView, p8, p9, p10, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_COORD( int cam, float posX, float posY, float posZ) { invoke<void )
	{
		CAM::SET_CAM_COORD(cam, posX, posY, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_ROT( int cam, float rotX, float rotY, float rotZ, int rotationOrder) { invoke<void )
	{
		CAM::SET_CAM_ROT(cam, rotX, rotY, rotZ, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_FOV( int cam, float fieldOfView) { invoke<void )
	{
		CAM::SET_CAM_FOV(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_NEAR_CLIP( int cam, float nearClip) { invoke<void )
	{
		CAM::SET_CAM_NEAR_CLIP(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_FAR_CLIP( int cam, float farClip) { invoke<void )
	{
		CAM::SET_CAM_FAR_CLIP(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_FORCE_CAM_FAR_CLIP( int cam, float p1) { invoke<void )
	{
		CAM::FORCE_CAM_FAR_CLIP(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_MOTION_BLUR_STRENGTH( int cam, float strength) { invoke<void )
	{
		CAM::SET_CAM_MOTION_BLUR_STRENGTH(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_NEAR_DOF( int cam, float nearDOF) { invoke<void )
	{
		CAM::SET_CAM_NEAR_DOF(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_FAR_DOF( int cam, float farDOF) { invoke<void )
	{
		CAM::SET_CAM_FAR_DOF(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_STRENGTH( int cam, float dofStrength) { invoke<void )
	{
		CAM::SET_CAM_DOF_STRENGTH(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_PLANES( int cam, float p1, float p2, float p3, float p4) { invoke<void )
	{
		CAM::SET_CAM_DOF_PLANES(cam, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_USE_SHALLOW_DOF_MODE( int cam, bool toggle) { invoke<void )
	{
		CAM::SET_CAM_USE_SHALLOW_DOF_MODE(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_USE_HI_DOF(  )
	{
		CAM::SET_USE_HI_DOF();
	}

	void LUA_NATIVE_CAM_SET_USE_HI_DOF_ON_SYNCED_SCENE_THIS_UPDATE(  )
	{
		CAM::SET_USE_HI_DOF_ON_SYNCED_SCENE_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_OVERRIDDEN_FOCUS_DISTANCE( int camera, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_OVERRIDDEN_FOCUS_DISTANCE(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_OVERRIDDEN_FOCUS_DISTANCE_BLEND_LEVEL( Any p0, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_OVERRIDDEN_FOCUS_DISTANCE_BLEND_LEVEL(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_FNUMBER_OF_LENS( int camera, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_FNUMBER_OF_LENS(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_FOCAL_LENGTH_MULTIPLIER( int camera, float multiplier) { invoke<void )
	{
		CAM::SET_CAM_DOF_FOCAL_LENGTH_MULTIPLIER(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_FOCUS_DISTANCE_BIAS( int camera, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_FOCUS_DISTANCE_BIAS(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_MAX_NEAR_IN_FOCUS_DISTANCE( int camera, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_MAX_NEAR_IN_FOCUS_DISTANCE(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_MAX_NEAR_IN_FOCUS_DISTANCE_BLEND_LEVEL( int camera, float p1) { invoke<void )
	{
		CAM::SET_CAM_DOF_MAX_NEAR_IN_FOCUS_DISTANCE_BLEND_LEVEL(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DOF_SHOULD_KEEP_LOOK_AT_TARGET_IN_FOCUS( int camera, bool state) { invoke<void )
	{
		CAM::SET_CAM_DOF_SHOULD_KEEP_LOOK_AT_TARGET_IN_FOCUS(camera, invoke<void);
	}

	void LUA_NATIVE_CAM_ATTACH_CAM_TO_ENTITY( int cam, int entity, float xOffset, float yOffset, float zOffset, bool isRelative) { invoke<void )
	{
		CAM::ATTACH_CAM_TO_ENTITY(cam, entity, xOffset, yOffset, zOffset, invoke<void);
	}

	void LUA_NATIVE_CAM_ATTACH_CAM_TO_PED_BONE( int cam, int ped, int boneIndex, float x, float y, float z, bool heading) { invoke<void )
	{
		CAM::ATTACH_CAM_TO_PED_BONE(cam, ped, boneIndex, x, y, z, invoke<void);
	}

	void LUA_NATIVE_CAM_HARD_ATTACH_CAM_TO_PED_BONE( int cam, int ped, int boneIndex, float p3, float p4, float p5, float p6, float p7, float p8, bool p9) { invoke<void )
	{
		CAM::HARD_ATTACH_CAM_TO_PED_BONE(cam, ped, boneIndex, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_CAM_HARD_ATTACH_CAM_TO_ENTITY( int cam, int entity, float xRot, float yRot, float zRot, float xOffset, float yOffset, float zOffset, bool isRelative) { invoke<void )
	{
		CAM::HARD_ATTACH_CAM_TO_ENTITY(cam, entity, xRot, yRot, zRot, xOffset, yOffset, zOffset, invoke<void);
	}

	void LUA_NATIVE_CAM_ATTACH_CAM_TO_VEHICLE_BONE( int cam, int vehicle, int boneIndex, bool relativeRotation, float rotX, float rotY, float rotZ, float offsetX, float offsetY, float offsetZ, bool fixedDirection) { invoke<void )
	{
		CAM::ATTACH_CAM_TO_VEHICLE_BONE(cam, vehicle, boneIndex, relativeRotation, rotX, rotY, rotZ, offsetX, offsetY, offsetZ, invoke<void);
	}

	void LUA_NATIVE_CAM_DETACH_CAM( int cam) { invoke<void )
	{
		CAM::DETACH_CAM(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_INHERIT_ROLL_VEHICLE( int cam, bool p1) { invoke<void )
	{
		CAM::SET_CAM_INHERIT_ROLL_VEHICLE(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_POINT_CAM_AT_COORD( int cam, float x, float y, float z) { invoke<void )
	{
		CAM::POINT_CAM_AT_COORD(cam, x, y, invoke<void);
	}

	void LUA_NATIVE_CAM_POINT_CAM_AT_ENTITY( int cam, int entity, float p2, float p3, float p4, bool p5) { invoke<void )
	{
		CAM::POINT_CAM_AT_ENTITY(cam, entity, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_CAM_POINT_CAM_AT_PED_BONE( int cam, int ped, int boneIndex, float x, float y, float z, bool p6) { invoke<void )
	{
		CAM::POINT_CAM_AT_PED_BONE(cam, ped, boneIndex, x, y, z, invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_CAM_POINTING( int cam) { invoke<void )
	{
		CAM::STOP_CAM_POINTING(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_AFFECTS_AIMING( int cam, bool toggle) { invoke<void )
	{
		CAM::SET_CAM_AFFECTS_AIMING(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_CONTROLS_MINI_MAP_HEADING( int cam, bool toggle) { invoke<void )
	{
		CAM::SET_CAM_CONTROLS_MINI_MAP_HEADING(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_IS_INSIDE_VEHICLE( int cam, bool toggle) { invoke<void )
	{
		CAM::SET_CAM_IS_INSIDE_VEHICLE(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_ALLOW_MOTION_BLUR_DECAY( Any p0, bool p1) { invoke<void )
	{
		CAM::ALLOW_MOTION_BLUR_DECAY(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_DEBUG_NAME( int camera, const char* name) { invoke<void )
	{
		CAM::SET_CAM_DEBUG_NAME(camera, invoke<void);
	}

	int LUA_NATIVE_CAM_GET_DEBUG_CAM(  )
	{
		auto retval = CAM::GET_DEBUG_CAM();
		return retval;
	}

	void LUA_NATIVE_CAM_ADD_CAM_SPLINE_NODE( int camera, float x, float y, float z, float xRot, float yRot, float zRot, int length, int smoothingStyle, int rotationOrder) { invoke<void )
	{
		CAM::ADD_CAM_SPLINE_NODE(camera, x, y, z, xRot, yRot, zRot, length, smoothingStyle, invoke<void);
	}

	void LUA_NATIVE_CAM_ADD_CAM_SPLINE_NODE_USING_CAMERA_FRAME( int cam, int cam2, int length, int p3) { invoke<void )
	{
		CAM::ADD_CAM_SPLINE_NODE_USING_CAMERA_FRAME(cam, cam2, length, invoke<void);
	}

	void LUA_NATIVE_CAM_ADD_CAM_SPLINE_NODE_USING_CAMERA( int cam, int cam2, int length, int p3) { invoke<void )
	{
		CAM::ADD_CAM_SPLINE_NODE_USING_CAMERA(cam, cam2, length, invoke<void);
	}

	void LUA_NATIVE_CAM_ADD_CAM_SPLINE_NODE_USING_GAMEPLAY_FRAME( int cam, int length, int p2) { invoke<void )
	{
		CAM::ADD_CAM_SPLINE_NODE_USING_GAMEPLAY_FRAME(cam, length, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_PHASE( int cam, float p1) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_PHASE(cam, invoke<void);
	}

	float LUA_NATIVE_CAM_GET_CAM_SPLINE_PHASE( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_SPLINE_PHASE(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_CAM_SPLINE_NODE_PHASE( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_SPLINE_NODE_PHASE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_DURATION( int cam, int timeDuration) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_DURATION(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_SMOOTHING_STYLE( int cam, int smoothingStyle) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_SMOOTHING_STYLE(cam, invoke<void);
	}

	int LUA_NATIVE_CAM_GET_CAM_SPLINE_NODE_INDEX( int cam) { return invoke<int )
	{
		auto retval = CAM::GET_CAM_SPLINE_NODE_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_NODE_EASE( int cam, int easingFunction, int p2, float p3) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_NODE_EASE(cam, easingFunction, p2, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_NODE_VELOCITY_SCALE( int cam, int p1, float scale) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_NODE_VELOCITY_SCALE(cam, p1, invoke<void);
	}

	void LUA_NATIVE_CAM_OVERRIDE_CAM_SPLINE_VELOCITY( int cam, int p1, float p2, float p3) { invoke<void )
	{
		CAM::OVERRIDE_CAM_SPLINE_VELOCITY(cam, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CAM_OVERRIDE_CAM_SPLINE_MOTION_BLUR( int cam, int p1, float p2, float p3) { invoke<void )
	{
		CAM::OVERRIDE_CAM_SPLINE_MOTION_BLUR(cam, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CAM_SPLINE_NODE_EXTRA_FLAGS( int cam, int p1, int flags) { invoke<void )
	{
		CAM::SET_CAM_SPLINE_NODE_EXTRA_FLAGS(cam, p1, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CAM_SPLINE_PAUSED( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_SPLINE_PAUSED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_ACTIVE_WITH_INTERP( int camTo, int camFrom, int duration, int easeLocation, int easeRotation) { invoke<void )
	{
		CAM::SET_CAM_ACTIVE_WITH_INTERP(camTo, camFrom, duration, easeLocation, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CAM_INTERPOLATING( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_INTERPOLATING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SHAKE_CAM( int cam, const char* type, float amplitude) { invoke<void )
	{
		CAM::SHAKE_CAM(cam, type, invoke<void);
	}

	void LUA_NATIVE_CAM_ANIMATED_SHAKE_CAM( int cam, const char* p1, const char* p2, const char* p3, float amplitude) { invoke<void )
	{
		CAM::ANIMATED_SHAKE_CAM(cam, p1, p2, p3, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CAM_SHAKING( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_SHAKING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_SHAKE_AMPLITUDE( int cam, float amplitude) { invoke<void )
	{
		CAM::SET_CAM_SHAKE_AMPLITUDE(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_CAM_SHAKING( int cam, bool p1) { invoke<void )
	{
		CAM::STOP_CAM_SHAKING(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SHAKE_SCRIPT_GLOBAL( const char* p0, float p1) { invoke<void )
	{
		CAM::SHAKE_SCRIPT_GLOBAL(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_ANIMATED_SHAKE_SCRIPT_GLOBAL( const char* p0, const char* p1, const char* p2, float p3) { invoke<void )
	{
		CAM::ANIMATED_SHAKE_SCRIPT_GLOBAL(p0, p1, p2, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_SCRIPT_GLOBAL_SHAKING(  )
	{
		auto retval = (bool)CAM::IS_SCRIPT_GLOBAL_SHAKING();
		return retval;
	}

	void LUA_NATIVE_CAM_STOP_SCRIPT_GLOBAL_SHAKING( bool p0) { invoke<void )
	{
		CAM::STOP_SCRIPT_GLOBAL_SHAKING(invoke<void);
	}

	void LUA_NATIVE_CAM_TRIGGER_VEHICLE_PART_BROKEN_CAMERA_SHAKE( int vehicle, int p1, float p2) { invoke<void )
	{
		CAM::TRIGGER_VEHICLE_PART_BROKEN_CAMERA_SHAKE(vehicle, p1, invoke<void);
	}

	bool LUA_NATIVE_CAM_PLAY_CAM_ANIM( int cam, const char* animName, const char* animDictionary, float x, float y, float z, float xRot, float yRot, float zRot, bool p9, int p10) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::PLAY_CAM_ANIM(cam, animName, animDictionary, x, y, z, xRot, yRot, zRot, p9, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_CAM_PLAYING_ANIM( int cam, const char* animName, const char* animDictionary) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CAM_PLAYING_ANIM(cam, animName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_ANIM_CURRENT_PHASE( int cam, float phase) { invoke<void )
	{
		CAM::SET_CAM_ANIM_CURRENT_PHASE(cam, invoke<void);
	}

	float LUA_NATIVE_CAM_GET_CAM_ANIM_CURRENT_PHASE( int cam) { return invoke<float )
	{
		auto retval = CAM::GET_CAM_ANIM_CURRENT_PHASE(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_CAM_PLAY_SYNCHRONIZED_CAM_ANIM( Any p0, Any p1, const char* animName, const char* animDictionary) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::PLAY_SYNCHRONIZED_CAM_ANIM(p0, p1, animName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FLY_CAM_HORIZONTAL_RESPONSE( int cam, float p1, float p2, float p3) { invoke<void )
	{
		CAM::SET_FLY_CAM_HORIZONTAL_RESPONSE(cam, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FLY_CAM_VERTICAL_RESPONSE( int cam, float p1, float p2, float p3) { invoke<void )
	{
		CAM::SET_FLY_CAM_VERTICAL_RESPONSE(cam, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FLY_CAM_MAX_HEIGHT( int cam, float height) { invoke<void )
	{
		CAM::SET_FLY_CAM_MAX_HEIGHT(cam, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FLY_CAM_COORD_AND_CONSTRAIN( int cam, float x, float y, float z) { invoke<void )
	{
		CAM::SET_FLY_CAM_COORD_AND_CONSTRAIN(cam, x, y, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FLY_CAM_VERTICAL_CONTROLS_THIS_UPDATE( int cam) { invoke<void )
	{
		CAM::SET_FLY_CAM_VERTICAL_CONTROLS_THIS_UPDATE(invoke<void);
	}

	bool LUA_NATIVE_CAM_WAS_FLY_CAM_CONSTRAINED_ON_PREVIOUS_UDPATE( int cam) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::WAS_FLY_CAM_CONSTRAINED_ON_PREVIOUS_UDPATE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_SCREEN_FADED_OUT(  )
	{
		auto retval = (bool)CAM::IS_SCREEN_FADED_OUT();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_SCREEN_FADED_IN(  )
	{
		auto retval = (bool)CAM::IS_SCREEN_FADED_IN();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_SCREEN_FADING_OUT(  )
	{
		auto retval = (bool)CAM::IS_SCREEN_FADING_OUT();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_SCREEN_FADING_IN(  )
	{
		auto retval = (bool)CAM::IS_SCREEN_FADING_IN();
		return retval;
	}

	void LUA_NATIVE_CAM_DO_SCREEN_FADE_IN( int duration) { invoke<void )
	{
		CAM::DO_SCREEN_FADE_IN(invoke<void);
	}

	void LUA_NATIVE_CAM_DO_SCREEN_FADE_OUT( int duration) { invoke<void )
	{
		CAM::DO_SCREEN_FADE_OUT(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_WIDESCREEN_BORDERS( bool p0, int p1) { invoke<void )
	{
		CAM::SET_WIDESCREEN_BORDERS(p0, invoke<void);
	}

	bool LUA_NATIVE_CAM_ARE_WIDESCREEN_BORDERS_ACTIVE(  )
	{
		auto retval = (bool)CAM::ARE_WIDESCREEN_BORDERS_ACTIVE();
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_GAMEPLAY_CAM_COORD(  )
	{
		auto retval = CAM::GET_GAMEPLAY_CAM_COORD();
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_GAMEPLAY_CAM_ROT( int rotationOrder) { return invoke<Vector3 )
	{
		auto retval = CAM::GET_GAMEPLAY_CAM_ROT(invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_GAMEPLAY_CAM_FOV(  )
	{
		auto retval = CAM::GET_GAMEPLAY_CAM_FOV();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_MOTION_BLUR_SCALING_THIS_UPDATE( float p0) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_MOTION_BLUR_SCALING_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_MAX_MOTION_BLUR_STRENGTH_THIS_UPDATE( float p0) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_MAX_MOTION_BLUR_STRENGTH_THIS_UPDATE(invoke<void);
	}

	float LUA_NATIVE_CAM_GET_GAMEPLAY_CAM_RELATIVE_HEADING(  )
	{
		auto retval = CAM::GET_GAMEPLAY_CAM_RELATIVE_HEADING();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_RELATIVE_HEADING( float heading) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_RELATIVE_HEADING(invoke<void);
	}

	float LUA_NATIVE_CAM_GET_GAMEPLAY_CAM_RELATIVE_PITCH(  )
	{
		auto retval = CAM::GET_GAMEPLAY_CAM_RELATIVE_PITCH();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_RELATIVE_PITCH( float angle, float scalingFactor) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_RELATIVE_PITCH(angle, invoke<void);
	}

	void LUA_NATIVE_CAM_RESET_GAMEPLAY_CAM_FULL_ATTACH_PARENT_TRANSFORM_TIMER(  )
	{
		CAM::RESET_GAMEPLAY_CAM_FULL_ATTACH_PARENT_TRANSFORM_TIMER();
	}

	void LUA_NATIVE_CAM_FORCE_CAMERA_RELATIVE_HEADING_AND_PITCH( float roll, float pitch, float yaw) { invoke<void )
	{
		CAM::FORCE_CAMERA_RELATIVE_HEADING_AND_PITCH(roll, pitch, invoke<void);
	}

	void LUA_NATIVE_CAM_FORCE_BONNET_CAMERA_RELATIVE_HEADING_AND_PITCH( float p0, float p1) { invoke<void )
	{
		CAM::FORCE_BONNET_CAMERA_RELATIVE_HEADING_AND_PITCH(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_SHOOTER_CAMERA_HEADING( float yaw) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_SHOOTER_CAMERA_HEADING(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_SHOOTER_CAMERA_PITCH( float pitch) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_SHOOTER_CAMERA_PITCH(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_SCRIPTED_CAMERA_IS_FIRST_PERSON_THIS_FRAME( bool p0) { invoke<void )
	{
		CAM::SET_SCRIPTED_CAMERA_IS_FIRST_PERSON_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_CAM_SHAKE_GAMEPLAY_CAM( const char* shakeName, float intensity) { invoke<void )
	{
		CAM::SHAKE_GAMEPLAY_CAM(shakeName, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_GAMEPLAY_CAM_SHAKING(  )
	{
		auto retval = (bool)CAM::IS_GAMEPLAY_CAM_SHAKING();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_SHAKE_AMPLITUDE( float amplitude) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_SHAKE_AMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_GAMEPLAY_CAM_SHAKING( bool p0) { invoke<void )
	{
		CAM::STOP_GAMEPLAY_CAM_SHAKING(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_FOLLOW_PED_THIS_UPDATE( int ped) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_FOLLOW_PED_THIS_UPDATE(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_GAMEPLAY_CAM_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_GAMEPLAY_CAM_RENDERING();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_INTERPOLATING_FROM_SCRIPT_CAMS(  )
	{
		auto retval = (bool)CAM::IS_INTERPOLATING_FROM_SCRIPT_CAMS();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_INTERPOLATING_TO_SCRIPT_CAMS(  )
	{
		auto retval = (bool)CAM::IS_INTERPOLATING_TO_SCRIPT_CAMS();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_ALTITUDE_FOV_SCALING_STATE( bool p0) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_ALTITUDE_FOV_SCALING_STATE(invoke<void);
	}

	void LUA_NATIVE_CAM_DISABLE_GAMEPLAY_CAM_ALTITUDE_FOV_SCALING_THIS_UPDATE(  )
	{
		CAM::DISABLE_GAMEPLAY_CAM_ALTITUDE_FOV_SCALING_THIS_UPDATE();
	}

	bool LUA_NATIVE_CAM_IS_GAMEPLAY_CAM_LOOKING_BEHIND(  )
	{
		auto retval = (bool)CAM::IS_GAMEPLAY_CAM_LOOKING_BEHIND();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_IGNORE_ENTITY_COLLISION_THIS_UPDATE( int entity) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_IGNORE_ENTITY_COLLISION_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_DISABLE_CAM_COLLISION_FOR_OBJECT( int entity) { invoke<void )
	{
		CAM::DISABLE_CAM_COLLISION_FOR_OBJECT(invoke<void);
	}

	void LUA_NATIVE_CAM_BYPASS_CAMERA_COLLISION_BUOYANCY_TEST_THIS_UPDATE(  )
	{
		CAM::BYPASS_CAMERA_COLLISION_BUOYANCY_TEST_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_CAM_ENTITY_TO_LIMIT_FOCUS_OVER_BOUNDING_SPHERE_THIS_UPDATE( int entity) { invoke<void )
	{
		CAM::SET_GAMEPLAY_CAM_ENTITY_TO_LIMIT_FOCUS_OVER_BOUNDING_SPHERE_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_DISABLE_FIRST_PERSON_CAMERA_WATER_CLIPPING_TEST_THIS_UPDATE(  )
	{
		CAM::DISABLE_FIRST_PERSON_CAMERA_WATER_CLIPPING_TEST_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_CAM_IGNORE_ATTACH_PARENT_MOVEMENT_THIS_UPDATE(  )
	{
		CAM::SET_FOLLOW_CAM_IGNORE_ATTACH_PARENT_MOVEMENT_THIS_UPDATE();
	}

	bool LUA_NATIVE_CAM_IS_SPHERE_VISIBLE( float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_SPHERE_VISIBLE(x, y, z, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_FOLLOW_PED_CAM_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_FOLLOW_PED_CAM_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_CAM_SET_FOLLOW_PED_CAM_THIS_UPDATE( const char* camName, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE(camName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_USE_SCRIPT_CAM_FOR_AMBIENT_POPULATION_ORIGIN_THIS_FRAME( bool p0, bool p1) { invoke<void )
	{
		CAM::USE_SCRIPT_CAM_FOR_AMBIENT_POPULATION_ORIGIN_THIS_FRAME(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_PED_CAM_LADDER_ALIGN_THIS_UPDATE(  )
	{
		CAM::SET_FOLLOW_PED_CAM_LADDER_ALIGN_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_THIRD_PERSON_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE( float minimum, float maximum) { invoke<void )
	{
		CAM::SET_THIRD_PERSON_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE(minimum, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_THIRD_PERSON_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE( float minimum, float maximum) { invoke<void )
	{
		CAM::SET_THIRD_PERSON_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE(minimum, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_THIRD_PERSON_CAM_ORBIT_DISTANCE_LIMITS_THIS_UPDATE( float p0, float distance) { invoke<void )
	{
		CAM::SET_THIRD_PERSON_CAM_ORBIT_DISTANCE_LIMITS_THIS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_IN_VEHICLE_CAM_STATE_THIS_UPDATE( int p0, int p1) { invoke<void )
	{
		CAM::SET_IN_VEHICLE_CAM_STATE_THIS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_DISABLE_ON_FOOT_FIRST_PERSON_VIEW_THIS_UPDATE(  )
	{
		CAM::DISABLE_ON_FOOT_FIRST_PERSON_VIEW_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_DISABLE_FIRST_PERSON_FLASH_EFFECT_THIS_UPDATE(  )
	{
		CAM::DISABLE_FIRST_PERSON_FLASH_EFFECT_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_BLOCK_FIRST_PERSON_ORIENTATION_RESET_THIS_UPDATE(  )
	{
		CAM::BLOCK_FIRST_PERSON_ORIENTATION_RESET_THIS_UPDATE();
	}

	int LUA_NATIVE_CAM_GET_FOLLOW_PED_CAM_ZOOM_LEVEL(  )
	{
		auto retval = CAM::GET_FOLLOW_PED_CAM_ZOOM_LEVEL();
		return retval;
	}

	int LUA_NATIVE_CAM_GET_FOLLOW_PED_CAM_VIEW_MODE(  )
	{
		auto retval = CAM::GET_FOLLOW_PED_CAM_VIEW_MODE();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_PED_CAM_VIEW_MODE( int viewMode) { invoke<void )
	{
		CAM::SET_FOLLOW_PED_CAM_VIEW_MODE(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_FOLLOW_VEHICLE_CAM_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_FOLLOW_VEHICLE_CAM_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_VEHICLE_CAM_HIGH_ANGLE_MODE_THIS_UPDATE( bool p0) { invoke<void )
	{
		CAM::SET_FOLLOW_VEHICLE_CAM_HIGH_ANGLE_MODE_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_VEHICLE_CAM_HIGH_ANGLE_MODE_EVERY_UPDATE( bool p0, bool p1) { invoke<void )
	{
		CAM::SET_FOLLOW_VEHICLE_CAM_HIGH_ANGLE_MODE_EVERY_UPDATE(p0, invoke<void);
	}

	bool LUA_NATIVE_CAM_SET_TABLE_GAMES_CAMERA_THIS_UPDATE( unsigned hash) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::SET_TABLE_GAMES_CAMERA_THIS_UPDATE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_CAM_GET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL(  )
	{
		auto retval = CAM::GET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL( int zoomLevel) { invoke<void )
	{
		CAM::SET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL(invoke<void);
	}

	int LUA_NATIVE_CAM_GET_FOLLOW_VEHICLE_CAM_VIEW_MODE(  )
	{
		auto retval = CAM::GET_FOLLOW_VEHICLE_CAM_VIEW_MODE();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_VEHICLE_CAM_VIEW_MODE( int viewMode) { invoke<void )
	{
		CAM::SET_FOLLOW_VEHICLE_CAM_VIEW_MODE(invoke<void);
	}

	int LUA_NATIVE_CAM_GET_CAM_VIEW_MODE_FOR_CONTEXT( int context) { return invoke<int )
	{
		auto retval = CAM::GET_CAM_VIEW_MODE_FOR_CONTEXT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CAM_VIEW_MODE_FOR_CONTEXT( int context, int viewMode) { invoke<void )
	{
		CAM::SET_CAM_VIEW_MODE_FOR_CONTEXT(context, invoke<void);
	}

	int LUA_NATIVE_CAM_GET_CAM_ACTIVE_VIEW_MODE_CONTEXT(  )
	{
		auto retval = CAM::GET_CAM_ACTIVE_VIEW_MODE_CONTEXT();
		return retval;
	}

	void LUA_NATIVE_CAM_USE_VEHICLE_CAM_STUNT_SETTINGS_THIS_UPDATE(  )
	{
		CAM::USE_VEHICLE_CAM_STUNT_SETTINGS_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_USE_DEDICATED_STUNT_CAMERA_THIS_UPDATE( const char* camName) { invoke<void )
	{
		CAM::USE_DEDICATED_STUNT_CAMERA_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_FORCE_VEHICLE_CAM_STUNT_SETTINGS_THIS_UPDATE(  )
	{
		CAM::FORCE_VEHICLE_CAM_STUNT_SETTINGS_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_FOLLOW_VEHICLE_CAM_SEAT_THIS_UPDATE( int seatIndex) { invoke<void )
	{
		CAM::SET_FOLLOW_VEHICLE_CAM_SEAT_THIS_UPDATE(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_AIM_CAM_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_AIM_CAM_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_AIM_CAM_ACTIVE_IN_ACCURATE_MODE(  )
	{
		auto retval = (bool)CAM::IS_AIM_CAM_ACTIVE_IN_ACCURATE_MODE();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_FIRST_PERSON_AIM_CAM_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_FIRST_PERSON_AIM_CAM_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_CAM_DISABLE_AIM_CAM_THIS_UPDATE(  )
	{
		CAM::DISABLE_AIM_CAM_THIS_UPDATE();
	}

	float LUA_NATIVE_CAM_GET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR(  )
	{
		auto retval = CAM::GET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR( float zoomFactor) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR_LIMITS_THIS_UPDATE( float p0, float p1) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_AIM_CAM_ZOOM_FACTOR_LIMITS_THIS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_AIM_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE( float p0, float p1) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_AIM_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_AIM_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE( float p0, float p1) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_AIM_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_AIM_CAM_NEAR_CLIP_THIS_UPDATE( float p0) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_AIM_CAM_NEAR_CLIP_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_THIRD_PERSON_AIM_CAM_NEAR_CLIP_THIS_UPDATE( float p0) { invoke<void )
	{
		CAM::SET_THIRD_PERSON_AIM_CAM_NEAR_CLIP_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_ALLOW_CUSTOM_VEHICLE_DRIVE_BY_CAM_THIS_UPDATE( bool p0) { invoke<void )
	{
		CAM::SET_ALLOW_CUSTOM_VEHICLE_DRIVE_BY_CAM_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_FORCE_TIGHTSPACE_CUSTOM_FRAMING_THIS_UPDATE(  )
	{
		CAM::FORCE_TIGHTSPACE_CUSTOM_FRAMING_THIS_UPDATE();
	}

	Vector3 LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_COORD(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_COORD();
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_ROT( int rotationOrder) { return invoke<Vector3 )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_ROT(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_CAM_GET_FINAL_RENDERED_REMOTE_PLAYER_CAM_ROT( int player, int rotationOrder) { return invoke<Vector3 )
	{
		auto retval = CAM::GET_FINAL_RENDERED_REMOTE_PLAYER_CAM_ROT(player, invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_FOV(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_FOV();
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_REMOTE_PLAYER_CAM_FOV( int player) { return invoke<float )
	{
		auto retval = CAM::GET_FINAL_RENDERED_REMOTE_PLAYER_CAM_FOV(invoke<float);
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_NEAR_CLIP(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_NEAR_CLIP();
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_FAR_CLIP(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_FAR_CLIP();
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_NEAR_DOF(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_NEAR_DOF();
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_FAR_DOF(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_FAR_DOF();
		return retval;
	}

	float LUA_NATIVE_CAM_GET_FINAL_RENDERED_CAM_MOTION_BLUR_STRENGTH(  )
	{
		auto retval = CAM::GET_FINAL_RENDERED_CAM_MOTION_BLUR_STRENGTH();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_COORD_HINT( float x, float y, float z, int duration, int blendOutDuration, int blendInDuration, int p6) { invoke<void )
	{
		CAM::SET_GAMEPLAY_COORD_HINT(x, y, z, duration, blendOutDuration, blendInDuration, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_PED_HINT( int ped, float x1, float y1, float z1, bool p4, int duration, int blendOutDuration, int blendInDuration) { invoke<void )
	{
		CAM::SET_GAMEPLAY_PED_HINT(ped, x1, y1, z1, p4, duration, blendOutDuration, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_VEHICLE_HINT( int vehicle, float offsetX, float offsetY, float offsetZ, bool p4, int time, int easeInTime, int easeOutTime) { invoke<void )
	{
		CAM::SET_GAMEPLAY_VEHICLE_HINT(vehicle, offsetX, offsetY, offsetZ, p4, time, easeInTime, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_OBJECT_HINT( Object object, float xOffset, float yOffset, float zOffset, bool p4, int time, int easeInTime, int easeOutTime) { invoke<void )
	{
		CAM::SET_GAMEPLAY_OBJECT_HINT(object, xOffset, yOffset, zOffset, p4, time, easeInTime, invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_ENTITY_HINT( int entity, float xOffset, float yOffset, float zOffset, bool p4, int time, int easeInTime, int easeOutTime, int p8) { invoke<void )
	{
		CAM::SET_GAMEPLAY_ENTITY_HINT(entity, xOffset, yOffset, zOffset, p4, time, easeInTime, easeOutTime, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_GAMEPLAY_HINT_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_GAMEPLAY_HINT_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_CAM_STOP_GAMEPLAY_HINT( bool p0) { invoke<void )
	{
		CAM::STOP_GAMEPLAY_HINT(invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_GAMEPLAY_HINT_BEING_CANCELLED_THIS_UPDATE( bool p0) { invoke<void )
	{
		CAM::STOP_GAMEPLAY_HINT_BEING_CANCELLED_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_CODE_GAMEPLAY_HINT( bool p0) { invoke<void )
	{
		CAM::STOP_CODE_GAMEPLAY_HINT(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CODE_GAMEPLAY_HINT_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_CODE_GAMEPLAY_HINT_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_FOV( float FOV) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_FOV(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_FOLLOW_DISTANCE_SCALAR( float value) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_FOLLOW_DISTANCE_SCALAR(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_BASE_ORBIT_PITCH_OFFSET( float value) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_BASE_ORBIT_PITCH_OFFSET(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_CAMERA_RELATIVE_SIDE_OFFSET( float xOffset) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_CAMERA_RELATIVE_SIDE_OFFSET(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_CAMERA_RELATIVE_VERTICAL_OFFSET( float yOffset) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_CAMERA_RELATIVE_VERTICAL_OFFSET(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_GAMEPLAY_HINT_CAMERA_BLEND_TO_FOLLOW_PED_MEDIUM_VIEW_MODE( bool toggle) { invoke<void )
	{
		CAM::SET_GAMEPLAY_HINT_CAMERA_BLEND_TO_FOLLOW_PED_MEDIUM_VIEW_MODE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CINEMATIC_BUTTON_ACTIVE( bool p0) { invoke<void )
	{
		CAM::SET_CINEMATIC_BUTTON_ACTIVE(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_CAM_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_CAM_RENDERING();
		return retval;
	}

	void LUA_NATIVE_CAM_SHAKE_CINEMATIC_CAM( const char* shakeType, float amount) { invoke<void )
	{
		CAM::SHAKE_CINEMATIC_CAM(shakeType, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_CAM_SHAKING(  )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_CAM_SHAKING();
		return retval;
	}

	void LUA_NATIVE_CAM_SET_CINEMATIC_CAM_SHAKE_AMPLITUDE( float p0) { invoke<void )
	{
		CAM::SET_CINEMATIC_CAM_SHAKE_AMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_CAM_STOP_CINEMATIC_CAM_SHAKING( bool p0) { invoke<void )
	{
		CAM::STOP_CINEMATIC_CAM_SHAKING(invoke<void);
	}

	void LUA_NATIVE_CAM_DISABLE_CINEMATIC_BONNET_CAMERA_THIS_UPDATE(  )
	{
		CAM::DISABLE_CINEMATIC_BONNET_CAMERA_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_DISABLE_CINEMATIC_VEHICLE_IDLE_MODE_THIS_UPDATE(  )
	{
		CAM::DISABLE_CINEMATIC_VEHICLE_IDLE_MODE_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_INVALIDATE_CINEMATIC_VEHICLE_IDLE_MODE(  )
	{
		CAM::INVALIDATE_CINEMATIC_VEHICLE_IDLE_MODE();
	}

	void LUA_NATIVE_CAM_INVALIDATE_IDLE_CAM(  )
	{
		CAM::INVALIDATE_IDLE_CAM();
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_IDLE_CAM_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_IDLE_CAM_RENDERING();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_FIRST_PERSON_VEHICLE_INTERIOR_CAM_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_FIRST_PERSON_VEHICLE_INTERIOR_CAM_RENDERING();
		return retval;
	}

	void LUA_NATIVE_CAM_CREATE_CINEMATIC_SHOT( unsigned p0, int time, bool p2, int entity) { invoke<void )
	{
		CAM::CREATE_CINEMATIC_SHOT(p0, time, p2, invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_SHOT_ACTIVE( unsigned p0) { return invoke<BOOL )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_SHOT_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CAM_STOP_CINEMATIC_SHOT( unsigned p0) { invoke<void )
	{
		CAM::STOP_CINEMATIC_SHOT(invoke<void);
	}

	void LUA_NATIVE_CAM_FORCE_CINEMATIC_RENDERING_THIS_UPDATE( bool toggle) { invoke<void )
	{
		CAM::FORCE_CINEMATIC_RENDERING_THIS_UPDATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CINEMATIC_NEWS_CHANNEL_ACTIVE_THIS_UPDATE(  )
	{
		CAM::SET_CINEMATIC_NEWS_CHANNEL_ACTIVE_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_CINEMATIC_MODE_ACTIVE( bool toggle) { invoke<void )
	{
		CAM::SET_CINEMATIC_MODE_ACTIVE(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_IN_VEHICLE_MOBILE_PHONE_CAMERA_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_IN_VEHICLE_MOBILE_PHONE_CAMERA_RENDERING();
		return retval;
	}

	bool LUA_NATIVE_CAM_DISABLE_CINEMATIC_SLOW_MO_THIS_UPDATE(  )
	{
		auto retval = (bool)CAM::DISABLE_CINEMATIC_SLOW_MO_THIS_UPDATE();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_BONNET_CINEMATIC_CAM_RENDERING(  )
	{
		auto retval = (bool)CAM::IS_BONNET_CINEMATIC_CAM_RENDERING();
		return retval;
	}

	bool LUA_NATIVE_CAM_IS_CINEMATIC_CAM_INPUT_ACTIVE(  )
	{
		auto retval = (bool)CAM::IS_CINEMATIC_CAM_INPUT_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_CAM_IGNORE_MENU_PREFERENCE_FOR_BONNET_CAMERA_THIS_UPDATE(  )
	{
		CAM::IGNORE_MENU_PREFERENCE_FOR_BONNET_CAMERA_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_BYPASS_CUTSCENE_CAM_RENDERING_THIS_UPDATE(  )
	{
		CAM::BYPASS_CUTSCENE_CAM_RENDERING_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_STOP_CUTSCENE_CAM_SHAKING( Any p0) { invoke<void )
	{
		CAM::STOP_CUTSCENE_CAM_SHAKING(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_CUTSCENE_CAM_FAR_CLIP_THIS_UPDATE( float p0) { invoke<void )
	{
		CAM::SET_CUTSCENE_CAM_FAR_CLIP_THIS_UPDATE(invoke<void);
	}

	int LUA_NATIVE_CAM_GET_FOCUS_PED_ON_SCREEN( float p0, int p1, float p2, float p3, float p4, float p5, float p6, int p7, int p8) { return invoke<int )
	{
		auto retval = CAM::GET_FOCUS_PED_ON_SCREEN(p0, p1, p2, p3, p4, p5, p6, p7, invoke<int);
		return retval;
	}

	void LUA_NATIVE_CAM_DISABLE_NEAR_CLIP_SCAN_THIS_UPDATE(  )
	{
		CAM::DISABLE_NEAR_CLIP_SCAN_THIS_UPDATE();
	}

	void LUA_NATIVE_CAM_SET_CAM_DEATH_FAIL_EFFECT_STATE( int p0) { invoke<void )
	{
		CAM::SET_CAM_DEATH_FAIL_EFFECT_STATE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_FLASH_EFFECT_TYPE( Any p0) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_FLASH_EFFECT_TYPE(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_NAME( const char* vehicleName) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_NAME(invoke<void);
	}

	void LUA_NATIVE_CAM_SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_HASH( unsigned vehicleModel) { invoke<void )
	{
		CAM::SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_HASH(invoke<void);
	}

	bool LUA_NATIVE_CAM_IS_ALLOWED_INDEPENDENT_CAMERA_MODES(  )
	{
		auto retval = (bool)CAM::IS_ALLOWED_INDEPENDENT_CAMERA_MODES();
		return retval;
	}

	void LUA_NATIVE_CAM_CAMERA_PREVENT_COLLISION_SETTINGS_FOR_TRIPLEHEAD_IN_INTERIORS_THIS_UPDATE(  )
	{
		CAM::CAMERA_PREVENT_COLLISION_SETTINGS_FOR_TRIPLEHEAD_IN_INTERIORS_THIS_UPDATE();
	}

	float LUA_NATIVE_CAM_REPLAY_GET_MAX_DISTANCE_ALLOWED_FROM_PLAYER(  )
	{
		auto retval = CAM::REPLAY_GET_MAX_DISTANCE_ALLOWED_FROM_PLAYER();
		return retval;
	}

	void LUA_NATIVE_CLOCK_SET_CLOCK_TIME( int hour, int minute, int second) { invoke<void )
	{
		CLOCK::SET_CLOCK_TIME(hour, minute, invoke<void);
	}

	void LUA_NATIVE_CLOCK_PAUSE_CLOCK( bool toggle) { invoke<void )
	{
		CLOCK::PAUSE_CLOCK(invoke<void);
	}

	void LUA_NATIVE_CLOCK_ADVANCE_CLOCK_TIME_TO( int hour, int minute, int second) { invoke<void )
	{
		CLOCK::ADVANCE_CLOCK_TIME_TO(hour, minute, invoke<void);
	}

	void LUA_NATIVE_CLOCK_ADD_TO_CLOCK_TIME( int hours, int minutes, int seconds) { invoke<void )
	{
		CLOCK::ADD_TO_CLOCK_TIME(hours, minutes, invoke<void);
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_HOURS(  )
	{
		auto retval = CLOCK::GET_CLOCK_HOURS();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_MINUTES(  )
	{
		auto retval = CLOCK::GET_CLOCK_MINUTES();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_SECONDS(  )
	{
		auto retval = CLOCK::GET_CLOCK_SECONDS();
		return retval;
	}

	void LUA_NATIVE_CLOCK_SET_CLOCK_DATE( int day, int month, int year) { invoke<void )
	{
		CLOCK::SET_CLOCK_DATE(day, month, invoke<void);
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_DAY_OF_WEEK(  )
	{
		auto retval = CLOCK::GET_CLOCK_DAY_OF_WEEK();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_DAY_OF_MONTH(  )
	{
		auto retval = CLOCK::GET_CLOCK_DAY_OF_MONTH();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_MONTH(  )
	{
		auto retval = CLOCK::GET_CLOCK_MONTH();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_CLOCK_YEAR(  )
	{
		auto retval = CLOCK::GET_CLOCK_YEAR();
		return retval;
	}

	int LUA_NATIVE_CLOCK_GET_MILLISECONDS_PER_GAME_MINUTE(  )
	{
		auto retval = CLOCK::GET_MILLISECONDS_PER_GAME_MINUTE();
		return retval;
	}

	std::tuple<int, int, int, int, int, int second) {> LUA_NATIVE_CLOCK_GET_POSIX_TIME( int year, int month, int day, int hour, int minute, int second) { invoke<void )
	{
		std::tuple<int, int, int, int, int, int second) {> return_values;
		CLOCK::GET_POSIX_TIME(&year, &month, &day, &hour, &minute, &invoke<void);
		std::get<0>(return_values) = year;
		std::get<1>(return_values) = month;
		std::get<2>(return_values) = day;
		std::get<3>(return_values) = hour;
		std::get<4>(return_values) = minute;
		std::get<5>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int, int, int, int, int second) {> LUA_NATIVE_CLOCK_GET_UTC_TIME( int year, int month, int day, int hour, int minute, int second) { invoke<void )
	{
		std::tuple<int, int, int, int, int, int second) {> return_values;
		CLOCK::GET_UTC_TIME(&year, &month, &day, &hour, &minute, &invoke<void);
		std::get<0>(return_values) = year;
		std::get<1>(return_values) = month;
		std::get<2>(return_values) = day;
		std::get<3>(return_values) = hour;
		std::get<4>(return_values) = minute;
		std::get<5>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int, int, int, int, int second) {> LUA_NATIVE_CLOCK_GET_LOCAL_TIME( int year, int month, int day, int hour, int minute, int second) { invoke<void )
	{
		std::tuple<int, int, int, int, int, int second) {> return_values;
		CLOCK::GET_LOCAL_TIME(&year, &month, &day, &hour, &minute, &invoke<void);
		std::get<0>(return_values) = year;
		std::get<1>(return_values) = month;
		std::get<2>(return_values) = day;
		std::get<3>(return_values) = hour;
		std::get<4>(return_values) = minute;
		std::get<5>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_CUTSCENE_REQUEST_CUTSCENE( const char* cutsceneName, int flags) { invoke<void )
	{
		CUTSCENE::REQUEST_CUTSCENE(cutsceneName, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_REQUEST_CUTSCENE_WITH_PLAYBACK_LIST( const char* cutsceneName, int playbackFlags, int flags) { invoke<void )
	{
		CUTSCENE::REQUEST_CUTSCENE_WITH_PLAYBACK_LIST(cutsceneName, playbackFlags, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_REMOVE_CUTSCENE(  )
	{
		CUTSCENE::REMOVE_CUTSCENE();
	}

	bool LUA_NATIVE_CUTSCENE_HAS_CUTSCENE_LOADED(  )
	{
		auto retval = (bool)CUTSCENE::HAS_CUTSCENE_LOADED();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_HAS_THIS_CUTSCENE_LOADED( const char* cutsceneName) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::HAS_THIS_CUTSCENE_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_SCRIPT_CAN_START_CUTSCENE( int threadId) { invoke<void )
	{
		CUTSCENE::SET_SCRIPT_CAN_START_CUTSCENE(invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_CAN_REQUEST_ASSETS_FOR_CUTSCENE_ENTITY(  )
	{
		auto retval = (bool)CUTSCENE::CAN_REQUEST_ASSETS_FOR_CUTSCENE_ENTITY();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_IS_CUTSCENE_PLAYBACK_FLAG_SET( int flag) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::IS_CUTSCENE_PLAYBACK_FLAG_SET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_ENTITY_STREAMING_FLAGS( const char* cutsceneEntName, int p1, int p2) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_ENTITY_STREAMING_FLAGS(cutsceneEntName, p1, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_REQUEST_CUT_FILE( const char* cutsceneName) { invoke<void )
	{
		CUTSCENE::REQUEST_CUT_FILE(invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_HAS_CUT_FILE_LOADED( const char* cutsceneName) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::HAS_CUT_FILE_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_REMOVE_CUT_FILE( const char* cutsceneName) { invoke<void )
	{
		CUTSCENE::REMOVE_CUT_FILE(invoke<void);
	}

	int LUA_NATIVE_CUTSCENE_GET_CUT_FILE_CONCAT_COUNT( const char* cutsceneName) { return invoke<int )
	{
		auto retval = CUTSCENE::GET_CUT_FILE_CONCAT_COUNT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_START_CUTSCENE( int flags) { invoke<void )
	{
		CUTSCENE::START_CUTSCENE(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_START_CUTSCENE_AT_COORDS( float x, float y, float z, int flags) { invoke<void )
	{
		CUTSCENE::START_CUTSCENE_AT_COORDS(x, y, z, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_STOP_CUTSCENE( bool p0) { invoke<void )
	{
		CUTSCENE::STOP_CUTSCENE(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_STOP_CUTSCENE_IMMEDIATELY(  )
	{
		CUTSCENE::STOP_CUTSCENE_IMMEDIATELY();
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_ORIGIN( float x, float y, float z, float p3, int p4) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_ORIGIN(x, y, z, p3, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_ORIGIN_AND_ORIENTATION( float x1, float y1, float z1, float x2, float y2, float z2, int p6) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_ORIGIN_AND_ORIENTATION(x1, y1, z1, x2, y2, z2, invoke<void);
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_TIME(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_TIME();
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_TOTAL_DURATION(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_TOTAL_DURATION();
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_END_TIME(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_END_TIME();
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_PLAY_DURATION(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_PLAY_DURATION();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_WAS_CUTSCENE_SKIPPED(  )
	{
		auto retval = (bool)CUTSCENE::WAS_CUTSCENE_SKIPPED();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_HAS_CUTSCENE_FINISHED(  )
	{
		auto retval = (bool)CUTSCENE::HAS_CUTSCENE_FINISHED();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_IS_CUTSCENE_ACTIVE(  )
	{
		auto retval = (bool)CUTSCENE::IS_CUTSCENE_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_IS_CUTSCENE_PLAYING(  )
	{
		auto retval = (bool)CUTSCENE::IS_CUTSCENE_PLAYING();
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_SECTION_PLAYING(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_SECTION_PLAYING();
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_ENTITY_INDEX_OF_CUTSCENE_ENTITY( const char* cutsceneEntName, unsigned modelHash) { return invoke<int )
	{
		auto retval = CUTSCENE::GET_ENTITY_INDEX_OF_CUTSCENE_ENTITY(cutsceneEntName, invoke<int);
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_GET_CUTSCENE_CONCAT_SECTION_PLAYING(  )
	{
		auto retval = CUTSCENE::GET_CUTSCENE_CONCAT_SECTION_PLAYING();
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_IS_CUTSCENE_AUTHORIZED( const char* cutsceneName) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::IS_CUTSCENE_AUTHORIZED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_CUTSCENE_DOES_CUTSCENE_HANDLE_EXIST( int cutsceneHandle) { return invoke<int )
	{
		auto retval = CUTSCENE::DOES_CUTSCENE_HANDLE_EXIST(invoke<int);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_REGISTER_ENTITY_FOR_CUTSCENE( int cutscenePed, const char* cutsceneEntName, int p2, unsigned modelHash, int p4) { invoke<void )
	{
		CUTSCENE::REGISTER_ENTITY_FOR_CUTSCENE(cutscenePed, cutsceneEntName, p2, modelHash, invoke<void);
	}

	int LUA_NATIVE_CUTSCENE_GET_ENTITY_INDEX_OF_REGISTERED_ENTITY( const char* cutsceneEntName, unsigned modelHash) { return invoke<int )
	{
		auto retval = CUTSCENE::GET_ENTITY_INDEX_OF_REGISTERED_ENTITY(cutsceneEntName, invoke<int);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_VEHICLE_MODEL_PLAYER_WILL_EXIT_SCENE( unsigned modelHash) { invoke<void )
	{
		CUTSCENE::SET_VEHICLE_MODEL_PLAYER_WILL_EXIT_SCENE(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_TRIGGER_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_TRIGGER_AREA(x1, y1, z1, x2, y2, invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_CAN_SET_ENTER_STATE_FOR_REGISTERED_ENTITY( const char* cutsceneEntName, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::CAN_SET_ENTER_STATE_FOR_REGISTERED_ENTITY(cutsceneEntName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_CAN_SET_EXIT_STATE_FOR_REGISTERED_ENTITY( const char* cutsceneEntName, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::CAN_SET_EXIT_STATE_FOR_REGISTERED_ENTITY(cutsceneEntName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_CUTSCENE_CAN_SET_EXIT_STATE_FOR_CAMERA( bool p0) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::CAN_SET_EXIT_STATE_FOR_CAMERA(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_PAD_CAN_SHAKE_DURING_CUTSCENE( bool toggle) { invoke<void )
	{
		CUTSCENE::SET_PAD_CAN_SHAKE_DURING_CUTSCENE(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_FADE_VALUES( bool p0, bool p1, bool p2, bool p3) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_FADE_VALUES(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_MULTIHEAD_FADE( bool p0, bool p1, bool p2, bool p3) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_MULTIHEAD_FADE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_MULTIHEAD_FADE_MANUAL( bool p0) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_MULTIHEAD_FADE_MANUAL(invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_IS_MULTIHEAD_FADE_UP(  )
	{
		auto retval = (bool)CUTSCENE::IS_MULTIHEAD_FADE_UP();
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_NETWORK_SET_MOCAP_CUTSCENE_CAN_BE_SKIPPED( bool p0) { invoke<void )
	{
		CUTSCENE::NETWORK_SET_MOCAP_CUTSCENE_CAN_BE_SKIPPED(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CAR_GENERATORS_CAN_UPDATE_DURING_CUTSCENE( bool p0) { invoke<void )
	{
		CUTSCENE::SET_CAR_GENERATORS_CAN_UPDATE_DURING_CUTSCENE(invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_CAN_USE_MOBILE_PHONE_DURING_CUTSCENE(  )
	{
		auto retval = (bool)CUTSCENE::CAN_USE_MOBILE_PHONE_DURING_CUTSCENE();
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_CAN_BE_SKIPPED( bool p0) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_CAN_BE_SKIPPED(invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CAN_DISPLAY_MINIMAP_DURING_CUTSCENE_THIS_UPDATE(  )
	{
		CUTSCENE::SET_CAN_DISPLAY_MINIMAP_DURING_CUTSCENE_THIS_UPDATE();
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_PED_COMPONENT_VARIATION( const char* cutsceneEntName, int componentId, int drawableId, int textureId, unsigned modelHash) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_PED_COMPONENT_VARIATION(cutsceneEntName, componentId, drawableId, textureId, invoke<void);
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_PED_COMPONENT_VARIATION_FROM_PED( const char* cutsceneEntName, int ped, unsigned modelHash) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_PED_COMPONENT_VARIATION_FROM_PED(cutsceneEntName, ped, invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_DOES_CUTSCENE_ENTITY_EXIST( const char* cutsceneEntName, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)CUTSCENE::DOES_CUTSCENE_ENTITY_EXIST(cutsceneEntName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_CUTSCENE_SET_CUTSCENE_PED_PROP_VARIATION( const char* cutsceneEntName, int componentId, int drawableId, int textureId, unsigned modelHash) { invoke<void )
	{
		CUTSCENE::SET_CUTSCENE_PED_PROP_VARIATION(cutsceneEntName, componentId, drawableId, textureId, invoke<void);
	}

	bool LUA_NATIVE_CUTSCENE_HAS_CUTSCENE_CUT_THIS_FRAME(  )
	{
		auto retval = (bool)CUTSCENE::HAS_CUTSCENE_CUT_THIS_FRAME();
		return retval;
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_WATCH_REQUEST_ID( int requestId) { invoke<void )
	{
		DATAFILE::DATAFILE_WATCH_REQUEST_ID(invoke<void);
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_CLEAR_WATCH_LIST(  )
	{
		DATAFILE::DATAFILE_CLEAR_WATCH_LIST();
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_IS_VALID_REQUEST_ID( int index) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_IS_VALID_REQUEST_ID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_HAS_LOADED_FILE_DATA( int requestId) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_HAS_LOADED_FILE_DATA(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_HAS_VALID_FILE_DATA( int requestId) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_HAS_VALID_FILE_DATA(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_SELECT_ACTIVE_FILE( int requestId, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_SELECT_ACTIVE_FILE(requestId, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_DELETE_REQUESTED_FILE( int requestId) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_DELETE_REQUESTED_FILE(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_DATAFILE_UGC_CREATE_CONTENT( Any data, int dataCount, const char* contentName, const char* description, const char* tagsCsv, const char* contentTypeName, bool publish, Any p7) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)DATAFILE::UGC_CREATE_CONTENT(&data, dataCount, contentName, description, tagsCsv, contentTypeName, publish, invoke<BOOL);
		std::get<1>(return_values) = data;

		return return_values;
	}

	bool LUA_NATIVE_DATAFILE_UGC_CREATE_MISSION( const char* contentName, const char* description, const char* tagsCsv, const char* contentTypeName, bool publish, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::UGC_CREATE_MISSION(contentName, description, tagsCsv, contentTypeName, publish, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_DATAFILE_UGC_UPDATE_CONTENT( const char* contentId, Any data, int dataCount, const char* contentName, const char* description, const char* tagsCsv, const char* contentTypeName, Any p7) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)DATAFILE::UGC_UPDATE_CONTENT(contentId, &data, dataCount, contentName, description, tagsCsv, contentTypeName, invoke<BOOL);
		std::get<1>(return_values) = data;

		return return_values;
	}

	bool LUA_NATIVE_DATAFILE_UGC_UPDATE_MISSION( const char* contentId, const char* contentName, const char* description, const char* tagsCsv, const char* contentTypeName, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::UGC_UPDATE_MISSION(contentId, contentName, description, tagsCsv, contentTypeName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_UGC_SET_PLAYER_DATA( const char* contentId, float rating, const char* contentTypeName, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::UGC_SET_PLAYER_DATA(contentId, rating, contentTypeName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_SELECT_UGC_DATA( int p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_SELECT_UGC_DATA(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_SELECT_UGC_STATS( int p0, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_SELECT_UGC_STATS(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_SELECT_UGC_PLAYER_DATA( int p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_SELECT_UGC_PLAYER_DATA(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_SELECT_CREATOR_STATS( int p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_SELECT_CREATOR_STATS(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_LOAD_OFFLINE_UGC( const char* filename, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_LOAD_OFFLINE_UGC(filename, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_CREATE( int p0) { invoke<void )
	{
		DATAFILE::DATAFILE_CREATE(invoke<void);
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_DELETE( int p0) { invoke<void )
	{
		DATAFILE::DATAFILE_DELETE(invoke<void);
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_STORE_MISSION_HEADER( int p0) { invoke<void )
	{
		DATAFILE::DATAFILE_STORE_MISSION_HEADER(invoke<void);
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_FLUSH_MISSION_HEADER(  )
	{
		DATAFILE::DATAFILE_FLUSH_MISSION_HEADER();
	}

	Any* LUA_NATIVE_DATAFILE_DATAFILE_GET_FILE_DICT( int p0) { return invoke<Any* )
	{
		auto retval = DATAFILE::DATAFILE_GET_FILE_DICT(invoke<Any*);
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_START_SAVE_TO_CLOUD( const char* filename, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_START_SAVE_TO_CLOUD(filename, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, bool p0) { return> LUA_NATIVE_DATAFILE_DATAFILE_UPDATE_SAVE_TO_CLOUD( bool p0) { return invoke<BOOL )
	{
		std::tuple<bool, bool p0) { return> return_values;
		std::get<0>(return_values) = (bool)DATAFILE::DATAFILE_UPDATE_SAVE_TO_CLOUD(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_IS_SAVE_PENDING(  )
	{
		auto retval = (bool)DATAFILE::DATAFILE_IS_SAVE_PENDING();
		return retval;
	}

	bool LUA_NATIVE_DATAFILE_DATAFILE_LOAD_OFFLINE_UGC_FOR_ADDITIONAL_DATA_FILE( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)DATAFILE::DATAFILE_LOAD_OFFLINE_UGC_FOR_ADDITIONAL_DATA_FILE(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_DATAFILE_DATAFILE_DELETE_FOR_ADDITIONAL_DATA_FILE( Any p0) { invoke<void )
	{
		DATAFILE::DATAFILE_DELETE_FOR_ADDITIONAL_DATA_FILE(invoke<void);
	}

	Any* LUA_NATIVE_DATAFILE_DATAFILE_GET_FILE_DICT_FOR_ADDITIONAL_DATA_FILE( Any p0) { return invoke<Any* )
	{
		auto retval = DATAFILE::DATAFILE_GET_FILE_DICT_FOR_ADDITIONAL_DATA_FILE(invoke<Any*);
		return retval;
	}

	Any LUA_NATIVE_DATAFILE_DATADICT_SET_BOOL( Any objectData, const char* key, bool value) { invoke<void )
	{
		DATAFILE::DATADICT_SET_BOOL(&objectData, key, invoke<void);
		return objectData;
	}

	Any LUA_NATIVE_DATAFILE_DATADICT_SET_INT( Any objectData, const char* key, int value) { invoke<void )
	{
		DATAFILE::DATADICT_SET_INT(&objectData, key, invoke<void);
		return objectData;
	}

	Any LUA_NATIVE_DATAFILE_DATADICT_SET_FLOAT( Any objectData, const char* key, float value) { invoke<void )
	{
		DATAFILE::DATADICT_SET_FLOAT(&objectData, key, invoke<void);
		return objectData;
	}

	Any LUA_NATIVE_DATAFILE_DATADICT_SET_STRING( Any objectData, const char* key, const char* value) { invoke<void )
	{
		DATAFILE::DATADICT_SET_STRING(&objectData, key, invoke<void);
		return objectData;
	}

	Any LUA_NATIVE_DATAFILE_DATADICT_SET_VECTOR( Any objectData, const char* key, float valueX, float valueY, float valueZ) { invoke<void )
	{
		DATAFILE::DATADICT_SET_VECTOR(&objectData, key, valueX, valueY, invoke<void);
		return objectData;
	}

	std::tuple<Any*, Any> LUA_NATIVE_DATAFILE_DATADICT_CREATE_DICT( Any objectData, const char* key) { return invoke<Any* )
	{
		std::tuple<Any*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_CREATE_DICT(&objectData, invoke<Any*);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<Any*, Any> LUA_NATIVE_DATAFILE_DATADICT_CREATE_ARRAY( Any objectData, const char* key) { return invoke<Any* )
	{
		std::tuple<Any*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_CREATE_ARRAY(&objectData, invoke<Any*);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_BOOL( Any objectData, const char* key) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)DATAFILE::DATADICT_GET_BOOL(&objectData, invoke<BOOL);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_INT( Any objectData, const char* key) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_INT(&objectData, invoke<int);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<float, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_FLOAT( Any objectData, const char* key) { return invoke<float )
	{
		std::tuple<float, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_FLOAT(&objectData, invoke<float);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<const char*, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_STRING( Any objectData, const char* key) { return invoke<const char* )
	{
		std::tuple<const char*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_STRING(&objectData, char*);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<Vector3, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_VECTOR( Any objectData, const char* key) { return invoke<Vector3 )
	{
		std::tuple<Vector3, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_VECTOR(&objectData, invoke<Vector3);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<Any*, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_DICT( Any objectData, const char* key) { return invoke<Any* )
	{
		std::tuple<Any*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_DICT(&objectData, invoke<Any*);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<Any*, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_ARRAY( Any objectData, const char* key) { return invoke<Any* )
	{
		std::tuple<Any*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_ARRAY(&objectData, invoke<Any*);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_DATAFILE_DATADICT_GET_TYPE( Any objectData, const char* key) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATADICT_GET_TYPE(&objectData, invoke<int);
		std::get<1>(return_values) = objectData;

		return return_values;
	}

	Any LUA_NATIVE_DATAFILE_DATAARRAY_ADD_BOOL( Any arrayData, bool value) { invoke<void )
	{
		DATAFILE::DATAARRAY_ADD_BOOL(&arrayData, invoke<void);
		return arrayData;
	}

	Any LUA_NATIVE_DATAFILE_DATAARRAY_ADD_INT( Any arrayData, int value) { invoke<void )
	{
		DATAFILE::DATAARRAY_ADD_INT(&arrayData, invoke<void);
		return arrayData;
	}

	Any LUA_NATIVE_DATAFILE_DATAARRAY_ADD_FLOAT( Any arrayData, float value) { invoke<void )
	{
		DATAFILE::DATAARRAY_ADD_FLOAT(&arrayData, invoke<void);
		return arrayData;
	}

	Any LUA_NATIVE_DATAFILE_DATAARRAY_ADD_STRING( Any arrayData, const char* value) { invoke<void )
	{
		DATAFILE::DATAARRAY_ADD_STRING(&arrayData, invoke<void);
		return arrayData;
	}

	Any LUA_NATIVE_DATAFILE_DATAARRAY_ADD_VECTOR( Any arrayData, float valueX, float valueY, float valueZ) { invoke<void )
	{
		DATAFILE::DATAARRAY_ADD_VECTOR(&arrayData, valueX, valueY, invoke<void);
		return arrayData;
	}

	std::tuple<Any*, Any arrayData) { return> LUA_NATIVE_DATAFILE_DATAARRAY_ADD_DICT( Any arrayData) { return invoke<Any* )
	{
		std::tuple<Any*, Any arrayData) { return> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_ADD_DICT(&invoke<Any*);
		std::get<1>(return_values) = invoke<Any*;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_BOOL( Any arrayData, int arrayIndex) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)DATAFILE::DATAARRAY_GET_BOOL(&arrayData, invoke<BOOL);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_INT( Any arrayData, int arrayIndex) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_INT(&arrayData, invoke<int);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<float, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_FLOAT( Any arrayData, int arrayIndex) { return invoke<float )
	{
		std::tuple<float, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_FLOAT(&arrayData, invoke<float);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<const char*, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_STRING( Any arrayData, int arrayIndex) { return invoke<const char* )
	{
		std::tuple<const char*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_STRING(&arrayData, char*);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<Vector3, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_VECTOR( Any arrayData, int arrayIndex) { return invoke<Vector3 )
	{
		std::tuple<Vector3, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_VECTOR(&arrayData, invoke<Vector3);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<Any*, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_DICT( Any arrayData, int arrayIndex) { return invoke<Any* )
	{
		std::tuple<Any*, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_DICT(&arrayData, invoke<Any*);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	std::tuple<int, Any arrayData) { return> LUA_NATIVE_DATAFILE_DATAARRAY_GET_COUNT( Any arrayData) { return invoke<int )
	{
		std::tuple<int, Any arrayData) { return> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_COUNT(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_DATAFILE_DATAARRAY_GET_TYPE( Any arrayData, int arrayIndex) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = DATAFILE::DATAARRAY_GET_TYPE(&arrayData, invoke<int);
		std::get<1>(return_values) = arrayData;

		return return_values;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_SET_TIME( int entity, const char* propertyName, int timestamp) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_SET_TIME(entity, propertyName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_SET_BOOL( int entity, const char* propertyName, bool value) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_SET_BOOL(entity, propertyName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_SET_FLOAT( int entity, const char* propertyName, float value) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_SET_FLOAT(entity, propertyName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_SET_INT( int entity, const char* propertyName, int value) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_SET_INT(entity, propertyName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_GET_BOOL( int entity, const char* propertyName) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_GET_BOOL(entity, invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_DECORATOR_DECOR_GET_FLOAT( int entity, const char* propertyName) { return invoke<float )
	{
		auto retval = DECORATOR::DECOR_GET_FLOAT(entity, invoke<float);
		return retval;
	}

	int LUA_NATIVE_DECORATOR_DECOR_GET_INT( int entity, const char* propertyName) { return invoke<int )
	{
		auto retval = DECORATOR::DECOR_GET_INT(entity, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_EXIST_ON( int entity, const char* propertyName) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_EXIST_ON(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DECORATOR_DECOR_REMOVE( int entity, const char* propertyName) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_REMOVE(entity, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_DECORATOR_DECOR_REGISTER( const char* propertyName, int type) { invoke<void )
	{
		DECORATOR::DECOR_REGISTER(propertyName, invoke<void);
	}

	bool LUA_NATIVE_DECORATOR_DECOR_IS_REGISTERED_AS_TYPE( const char* propertyName, int type) { return invoke<BOOL )
	{
		auto retval = (bool)DECORATOR::DECOR_IS_REGISTERED_AS_TYPE(propertyName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_DECORATOR_DECOR_REGISTER_LOCK(  )
	{
		DECORATOR::DECOR_REGISTER_LOCK();
	}

	bool LUA_NATIVE_DLC_ARE_ANY_CCS_PENDING(  )
	{
		auto retval = (bool)DLC::ARE_ANY_CCS_PENDING();
		return retval;
	}

	bool LUA_NATIVE_DLC_IS_DLC_PRESENT( unsigned dlcHash) { return invoke<BOOL )
	{
		auto retval = (bool)DLC::IS_DLC_PRESENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_DLC_DLC_CHECK_CLOUD_DATA_CORRECT(  )
	{
		auto retval = (bool)DLC::DLC_CHECK_CLOUD_DATA_CORRECT();
		return retval;
	}

	int LUA_NATIVE_DLC_GET_EXTRACONTENT_CLOUD_RESULT(  )
	{
		auto retval = DLC::GET_EXTRACONTENT_CLOUD_RESULT();
		return retval;
	}

	bool LUA_NATIVE_DLC_DLC_CHECK_COMPAT_PACK_CONFIGURATION(  )
	{
		auto retval = (bool)DLC::DLC_CHECK_COMPAT_PACK_CONFIGURATION();
		return retval;
	}

	bool LUA_NATIVE_DLC_GET_EVER_HAD_BAD_PACK_ORDER(  )
	{
		auto retval = (bool)DLC::GET_EVER_HAD_BAD_PACK_ORDER();
		return retval;
	}

	bool LUA_NATIVE_DLC_GET_IS_LOADING_SCREEN_ACTIVE(  )
	{
		auto retval = (bool)DLC::GET_IS_LOADING_SCREEN_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_DLC_GET_IS_INITIAL_LOADING_SCREEN_ACTIVE(  )
	{
		auto retval = (bool)DLC::GET_IS_INITIAL_LOADING_SCREEN_ACTIVE();
		return retval;
	}

	std::tuple<bool, bool> LUA_NATIVE_DLC_HAS_CLOUD_REQUESTS_FINISHED( bool p0, int unused) { return invoke<BOOL )
	{
		std::tuple<bool, bool> return_values;
		std::get<0>(return_values) = (bool)DLC::HAS_CLOUD_REQUESTS_FINISHED((BOOL*)&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	void LUA_NATIVE_DLC_ON_ENTER_SP(  )
	{
		DLC::ON_ENTER_SP();
	}

	void LUA_NATIVE_DLC_ON_ENTER_MP(  )
	{
		DLC::ON_ENTER_MP();
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_EXIST( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_EXIST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_BELONG_TO_THIS_SCRIPT( int entity, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_BELONG_TO_THIS_SCRIPT(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_HAVE_DRAWABLE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_HAVE_DRAWABLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_HAVE_PHYSICS( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_HAVE_PHYSICS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_HAVE_SKELETON( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_HAVE_SKELETON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_DOES_ENTITY_HAVE_ANIM_DIRECTOR( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::DOES_ENTITY_HAVE_ANIM_DIRECTOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_ANIM_FINISHED( int entity, const char* animDict, const char* animName, int p3) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_ANIM_FINISHED(entity, animDict, animName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_BEEN_DAMAGED_BY_ANY_OBJECT( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_BEEN_DAMAGED_BY_ANY_OBJECT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_BEEN_DAMAGED_BY_ANY_PED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_BEEN_DAMAGED_BY_ANY_PED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_BEEN_DAMAGED_BY_ANY_VEHICLE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_BEEN_DAMAGED_BY_ANY_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_BEEN_DAMAGED_BY_ENTITY( int entity1, int entity2, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_BEEN_DAMAGED_BY_ENTITY(entity1, entity2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_CLEAR_LOS_TO_ENTITY( int entity1, int entity2, int traceType) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_CLEAR_LOS_TO_ENTITY(entity1, entity2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_CLEAR_LOS_TO_ENTITY_ADJUST_FOR_COVER( int entity1, int entity2, int traceType) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_CLEAR_LOS_TO_ENTITY_ADJUST_FOR_COVER(entity1, entity2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_CLEAR_LOS_TO_ENTITY_IN_FRONT( int entity1, int entity2) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_CLEAR_LOS_TO_ENTITY_IN_FRONT(entity1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ENTITY_COLLIDED_WITH_ANYTHING( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ENTITY_COLLIDED_WITH_ANYTHING(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_LAST_ENTITY_HIT_BY_ENTITY_( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_LAST_ENTITY_HIT_BY_ENTITY_(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_ENTITY_GET_LAST_MATERIAL_HIT_BY_ENTITY( int entity) { return invoke<unsigned )
	{
		auto retval = ENTITY::GET_LAST_MATERIAL_HIT_BY_ENTITY(invoke<unsigned);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_COLLISION_NORMAL_OF_LAST_HIT_FOR_ENTITY( int entity) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_COLLISION_NORMAL_OF_LAST_HIT_FOR_ENTITY(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_ENTITY_FORCE_ENTITY_AI_AND_ANIMATION_UPDATE( int entity) { invoke<void )
	{
		ENTITY::FORCE_ENTITY_AI_AND_ANIMATION_UPDATE(invoke<void);
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_ANIM_CURRENT_TIME( int entity, const char* animDict, const char* animName) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_ANIM_CURRENT_TIME(entity, animDict, invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_ANIM_TOTAL_TIME( int entity, const char* animDict, const char* animName) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_ANIM_TOTAL_TIME(entity, animDict, invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ANIM_DURATION( const char* animDict, const char* animName) { return invoke<float )
	{
		auto retval = ENTITY::GET_ANIM_DURATION(animDict, invoke<float);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_ATTACHED_TO( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_ATTACHED_TO(invoke<int);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_COORDS( int entity, bool alive) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_COORDS(entity, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_FORWARD_VECTOR( int entity) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_FORWARD_VECTOR(invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_FORWARD_X( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_FORWARD_X(invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_FORWARD_Y( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_FORWARD_Y(invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_HEADING( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_HEADING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_HEADING_FROM_EULERS( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_HEADING_FROM_EULERS(invoke<float);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_HEALTH( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_HEALTH(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_MAX_HEALTH( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_MAX_HEALTH(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_MAX_HEALTH( int entity, int value) { invoke<void )
	{
		ENTITY::SET_ENTITY_MAX_HEALTH(entity, invoke<void);
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_HEIGHT( int entity, float X, float Y, float Z, bool atTop, bool inWorldCoords) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_HEIGHT(entity, X, Y, Z, atTop, invoke<float);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_HEIGHT_ABOVE_GROUND( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_HEIGHT_ABOVE_GROUND(invoke<float);
		return retval;
	}

	std::tuple<Vector3, Vector3, Vector3, Vector3 position) {> LUA_NATIVE_ENTITY_GET_ENTITY_MATRIX( int entity, Vector3 forwardVector, Vector3 rightVector, Vector3 upVector, Vector3 position) { invoke<void )
	{
		std::tuple<Vector3, Vector3, Vector3, Vector3 position) {> return_values;
		ENTITY::GET_ENTITY_MATRIX(entity, &forwardVector, &rightVector, &upVector, &invoke<void);
		std::get<0>(return_values) = forwardVector;
		std::get<1>(return_values) = rightVector;
		std::get<2>(return_values) = upVector;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	unsigned LUA_NATIVE_ENTITY_GET_ENTITY_MODEL( int entity) { return invoke<unsigned )
	{
		auto retval = ENTITY::GET_ENTITY_MODEL(invoke<unsigned);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS( int entity, float posX, float posY, float posZ) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS(entity, posX, posY, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS( int entity, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, offsetX, offsetY, invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_PITCH( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_PITCH(invoke<float);
		return retval;
	}

	std::tuple<float, float, float, float w) {> LUA_NATIVE_ENTITY_GET_ENTITY_QUATERNION( int entity, float x, float y, float z, float w) { invoke<void )
	{
		std::tuple<float, float, float, float w) {> return_values;
		ENTITY::GET_ENTITY_QUATERNION(entity, &x, &y, &z, &invoke<void);
		std::get<0>(return_values) = x;
		std::get<1>(return_values) = y;
		std::get<2>(return_values) = z;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_ROLL( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_ROLL(invoke<float);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_ROTATION( int entity, int rotationOrder) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_ROTATION(entity, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_ROTATION_VELOCITY( int entity) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_ROTATION_VELOCITY(invoke<Vector3);
		return retval;
	}

	std::tuple<const char*, int script) { return invoke<const> LUA_NATIVE_ENTITY_GET_ENTITY_SCRIPT( int entity, int script) { return invoke<const char* )
	{
		std::tuple<const char*, int script) { return invoke<const> return_values;
		std::get<0>(return_values) = ENTITY::GET_ENTITY_SCRIPT(entity, &char*);
		std::get<1>(return_values) = char*;

		return return_values;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_SPEED( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_SPEED(invoke<float);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_SPEED_VECTOR( int entity, bool relative) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_SPEED_VECTOR(entity, invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_UPRIGHT_VALUE( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_UPRIGHT_VALUE(invoke<float);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_VELOCITY( int entity) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_VELOCITY(invoke<Vector3);
		return retval;
	}

	Object LUA_NATIVE_ENTITY_GET_OBJECT_INDEX_FROM_ENTITY_INDEX( int entity) { return invoke<Object )
	{
		auto retval = ENTITY::GET_OBJECT_INDEX_FROM_ENTITY_INDEX(invoke<Object);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_PED_INDEX_FROM_ENTITY_INDEX( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_PED_INDEX_FROM_ENTITY_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_VEHICLE_INDEX_FROM_ENTITY_INDEX( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_VEHICLE_INDEX_FROM_ENTITY_INDEX(invoke<int);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_WORLD_POSITION_OF_ENTITY_BONE( int entity, int boneIndex) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_WORLD_POSITION_OF_ENTITY_BONE(entity, invoke<Vector3);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_NEAREST_PLAYER_TO_ENTITY( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_NEAREST_PLAYER_TO_ENTITY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_NEAREST_PLAYER_TO_ENTITY_ON_TEAM( int entity, int team) { return invoke<int )
	{
		auto retval = ENTITY::GET_NEAREST_PLAYER_TO_ENTITY_ON_TEAM(entity, invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_NEAREST_PARTICIPANT_TO_ENTITY( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_NEAREST_PARTICIPANT_TO_ENTITY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_TYPE( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_TYPE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_POPULATION_TYPE( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_POPULATION_TYPE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_AN_ENTITY( int handle) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_AN_ENTITY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_A_PED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_A_PED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_A_MISSION_ENTITY( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_A_MISSION_ENTITY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_A_VEHICLE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_A_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_AN_OBJECT( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_AN_OBJECT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_AT_COORD( int entity, float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, bool p7, bool p8, int p9) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_AT_COORD(entity, xPos, yPos, zPos, xSize, ySize, zSize, p7, p8, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_AT_ENTITY( int entity1, int entity2, float xSize, float ySize, float zSize, bool p5, bool p6, int p7) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_AT_ENTITY(entity1, entity2, xSize, ySize, zSize, p5, p6, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ATTACHED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ATTACHED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ATTACHED_TO_ANY_OBJECT( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ATTACHED_TO_ANY_OBJECT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ATTACHED_TO_ANY_PED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ATTACHED_TO_ANY_PED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ATTACHED_TO_ANY_VEHICLE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ATTACHED_TO_ANY_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ATTACHED_TO_ENTITY( int from, int to) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ATTACHED_TO_ENTITY(from, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_DEAD( int entity, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_DEAD(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_IN_AIR( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_IN_AIR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_IN_ANGLED_AREA( int entity, float x1, float y1, float z1, float x2, float y2, float z2, float width, bool debug, bool includeZ, Any p10) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_IN_ANGLED_AREA(entity, x1, y1, z1, x2, y2, z2, width, debug, includeZ, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_IN_AREA( int entity, float x1, float y1, float z1, float x2, float y2, float z2, bool p7, bool p8, Any p9) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_IN_AREA(entity, x1, y1, z1, x2, y2, z2, p7, p8, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_IN_ZONE( int entity, const char* zone) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_IN_ZONE(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_IN_WATER( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_IN_WATER(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_ENTITY_GET_ENTITY_SUBMERGED_LEVEL( int entity) { return invoke<float )
	{
		auto retval = ENTITY::GET_ENTITY_SUBMERGED_LEVEL(invoke<float);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_REQUIRES_MORE_EXPENSIVE_RIVER_CHECK( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_REQUIRES_MORE_EXPENSIVE_RIVER_CHECK(entity, invoke<void);
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_ON_SCREEN( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_ON_SCREEN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_PLAYING_ANIM( int entity, const char* animDict, const char* animName, int taskFlag) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_PLAYING_ANIM(entity, animDict, animName, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_STATIC( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_STATIC(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_TOUCHING_ENTITY( int entity, int targetEntity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_TOUCHING_ENTITY(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_TOUCHING_MODEL( int entity, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_TOUCHING_MODEL(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_UPRIGHT( int entity, float angle) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_UPRIGHT(entity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_UPSIDEDOWN( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_UPSIDEDOWN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_VISIBLE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_VISIBLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_VISIBLE_TO_SCRIPT( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_VISIBLE_TO_SCRIPT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_OCCLUDED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_OCCLUDED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_WOULD_ENTITY_BE_OCCLUDED( unsigned entityModelHash, float x, float y, float z, bool p4) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::WOULD_ENTITY_BE_OCCLUDED(entityModelHash, x, y, z, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_IS_ENTITY_WAITING_FOR_WORLD_COLLISION( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::IS_ENTITY_WAITING_FOR_WORLD_COLLISION(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ENTITY_APPLY_FORCE_TO_ENTITY_CENTER_OF_MASS( int entity, int forceType, float x, float y, float z, bool p5, bool isDirectionRel, bool isForceRel, bool p8) { invoke<void )
	{
		ENTITY::APPLY_FORCE_TO_ENTITY_CENTER_OF_MASS(entity, forceType, x, y, z, p5, isDirectionRel, isForceRel, invoke<void);
	}

	void LUA_NATIVE_ENTITY_APPLY_FORCE_TO_ENTITY( int entity, int forceFlags, float x, float y, float z, float offX, float offY, float offZ, int boneIndex, bool isDirectionRel, bool ignoreUpVec, bool isForceRel, bool p12, bool p13) { invoke<void )
	{
		ENTITY::APPLY_FORCE_TO_ENTITY(entity, forceFlags, x, y, z, offX, offY, offZ, boneIndex, isDirectionRel, ignoreUpVec, isForceRel, p12, invoke<void);
	}

	void LUA_NATIVE_ENTITY_ATTACH_ENTITY_TO_ENTITY( int entity1, int entity2, int boneIndex, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, bool p9, bool useSoftPinning, bool collision, bool isPed, int vertexIndex, bool fixedRot, Any p15) { invoke<void )
	{
		ENTITY::ATTACH_ENTITY_TO_ENTITY(entity1, entity2, boneIndex, xPos, yPos, zPos, xRot, yRot, zRot, p9, useSoftPinning, collision, isPed, vertexIndex, fixedRot, invoke<void);
	}

	void LUA_NATIVE_ENTITY_ATTACH_ENTITY_BONE_TO_ENTITY_BONE( int entity1, int entity2, int boneIndex1, int boneIndex2, bool p4, bool p5) { invoke<void )
	{
		ENTITY::ATTACH_ENTITY_BONE_TO_ENTITY_BONE(entity1, entity2, boneIndex1, boneIndex2, p4, invoke<void);
	}

	void LUA_NATIVE_ENTITY_ATTACH_ENTITY_BONE_TO_ENTITY_BONE_Y_FORWARD( int entity1, int entity2, int boneIndex1, int boneIndex2, bool p4, bool p5) { invoke<void )
	{
		ENTITY::ATTACH_ENTITY_BONE_TO_ENTITY_BONE_Y_FORWARD(entity1, entity2, boneIndex1, boneIndex2, p4, invoke<void);
	}

	void LUA_NATIVE_ENTITY_ATTACH_ENTITY_TO_ENTITY_PHYSICALLY( int entity1, int entity2, int boneIndex1, int boneIndex2, float xPos1, float yPos1, float zPos1, float xPos2, float yPos2, float zPos2, float xRot, float yRot, float zRot, float breakForce, bool fixedRot, bool p15, bool collision, bool p17, int p18) { invoke<void )
	{
		ENTITY::ATTACH_ENTITY_TO_ENTITY_PHYSICALLY(entity1, entity2, boneIndex1, boneIndex2, xPos1, yPos1, zPos1, xPos2, yPos2, zPos2, xRot, yRot, zRot, breakForce, fixedRot, p15, collision, p17, invoke<void);
	}

	void LUA_NATIVE_ENTITY_ATTACH_ENTITY_TO_ENTITY_PHYSICALLY_OVERRIDE_INVERSE_MASS( int firstEntityIndex, int secondEntityIndex, int firstEntityBoneIndex, int secondEntityBoneIndex, float secondEntityOffsetX, float secondEntityOffsetY, float secondEntityOffsetZ, float firstEntityOffsetX, float firstEntityOffsetY, float firstEntityOffsetZ, float vecRotationX, float vecRotationY, float vecRotationZ, float physicalStrength, bool constrainRotation, bool doInitialWarp, bool collideWithEntity, bool addInitialSeperation, int rotOrder, float invMassScaleA, float invMassScaleB) { invoke<void )
	{
		ENTITY::ATTACH_ENTITY_TO_ENTITY_PHYSICALLY_OVERRIDE_INVERSE_MASS(firstEntityIndex, secondEntityIndex, firstEntityBoneIndex, secondEntityBoneIndex, secondEntityOffsetX, secondEntityOffsetY, secondEntityOffsetZ, firstEntityOffsetX, firstEntityOffsetY, firstEntityOffsetZ, vecRotationX, vecRotationY, vecRotationZ, physicalStrength, constrainRotation, doInitialWarp, collideWithEntity, addInitialSeperation, rotOrder, invMassScaleA, invoke<void);
	}

	void LUA_NATIVE_ENTITY_PROCESS_ENTITY_ATTACHMENTS( int entity) { invoke<void )
	{
		ENTITY::PROCESS_ENTITY_ATTACHMENTS(invoke<void);
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_BONE_INDEX_BY_NAME( int entity, const char* boneName) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_INDEX_BY_NAME(entity, invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_CLEAR_ENTITY_LAST_DAMAGE_ENTITY( int entity) { invoke<void )
	{
		ENTITY::CLEAR_ENTITY_LAST_DAMAGE_ENTITY(invoke<void);
	}

	int entity) { LUA_NATIVE_ENTITY_DELETE_ENTITY( int entity) { invoke<void )
	{
		ENTITY::DELETE_ENTITY(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_ENTITY_DETACH_ENTITY( int entity, bool dynamic, bool collision) { invoke<void )
	{
		ENTITY::DETACH_ENTITY(entity, dynamic, invoke<void);
	}

	void LUA_NATIVE_ENTITY_FREEZE_ENTITY_POSITION( int entity, bool toggle) { invoke<void )
	{
		ENTITY::FREEZE_ENTITY_POSITION(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_SHOULD_FREEZE_WAITING_ON_COLLISION( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_SHOULD_FREEZE_WAITING_ON_COLLISION(entity, invoke<void);
	}

	bool LUA_NATIVE_ENTITY_PLAY_ENTITY_ANIM( int entity, const char* animName, const char* animDict, float p3, bool loop, bool stayInAnim, bool p6, float delta, Any bitset) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::PLAY_ENTITY_ANIM(entity, animName, animDict, p3, loop, stayInAnim, p6, delta, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_PLAY_SYNCHRONIZED_ENTITY_ANIM( int entity, int syncedScene, const char* animation, const char* propName, float p4, float p5, Any p6, float p7) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::PLAY_SYNCHRONIZED_ENTITY_ANIM(entity, syncedScene, animation, propName, p4, p5, p6, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_PLAY_SYNCHRONIZED_MAP_ENTITY_ANIM( float x1, float y1, float z1, float x2, Any y2, float z2, const char* p6, const char* p7, float p8, float p9, Any p10, float p11) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::PLAY_SYNCHRONIZED_MAP_ENTITY_ANIM(x1, y1, z1, x2, y2, z2, p6, p7, p8, p9, p10, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_STOP_SYNCHRONIZED_MAP_ENTITY_ANIM( float x1, float y1, float z1, float x2, Any y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::STOP_SYNCHRONIZED_MAP_ENTITY_ANIM(x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_STOP_ENTITY_ANIM( int entity, const char* animation, const char* animGroup, float p3) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::STOP_ENTITY_ANIM(entity, animation, animGroup, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_STOP_SYNCHRONIZED_ENTITY_ANIM( int entity, float p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::STOP_SYNCHRONIZED_ENTITY_ANIM(entity, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ENTITY_HAS_ANIM_EVENT_FIRED( int entity, unsigned actionHash) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_ANIM_EVENT_FIRED(entity, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any, Any p4) { return> LUA_NATIVE_ENTITY_FIND_ANIM_EVENT_PHASE( const char* animDictionary, const char* animName, const char* p2, Any p3, Any p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p4) { return> return_values;
		std::get<0>(return_values) = (bool)ENTITY::FIND_ANIM_EVENT_PHASE(animDictionary, animName, p2, &p3, &invoke<BOOL);
		std::get<1>(return_values) = p3;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ANIM_CURRENT_TIME( int entity, const char* animDictionary, const char* animName, float time) { invoke<void )
	{
		ENTITY::SET_ENTITY_ANIM_CURRENT_TIME(entity, animDictionary, animName, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ANIM_SPEED( int entity, const char* animDictionary, const char* animName, float speedMultiplier) { invoke<void )
	{
		ENTITY::SET_ENTITY_ANIM_SPEED(entity, animDictionary, animName, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_AS_MISSION_ENTITY( int entity, bool p1, bool p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_AS_MISSION_ENTITY(entity, p1, invoke<void);
	}

	int entity) { LUA_NATIVE_ENTITY_SET_ENTITY_AS_NO_LONGER_NEEDED( int entity) { invoke<void )
	{
		ENTITY::SET_ENTITY_AS_NO_LONGER_NEEDED(&invoke<void);
		return invoke<void;
	}

	int ped) { LUA_NATIVE_ENTITY_SET_PED_AS_NO_LONGER_NEEDED( int ped) { invoke<void )
	{
		ENTITY::SET_PED_AS_NO_LONGER_NEEDED(&invoke<void);
		return invoke<void;
	}

	int vehicle) { LUA_NATIVE_ENTITY_SET_VEHICLE_AS_NO_LONGER_NEEDED( int vehicle) { invoke<void )
	{
		ENTITY::SET_VEHICLE_AS_NO_LONGER_NEEDED(&invoke<void);
		return invoke<void;
	}

	Object object) { LUA_NATIVE_ENTITY_SET_OBJECT_AS_NO_LONGER_NEEDED( Object object) { invoke<void )
	{
		ENTITY::SET_OBJECT_AS_NO_LONGER_NEEDED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CAN_BE_DAMAGED( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_CAN_BE_DAMAGED(entity, invoke<void);
	}

	bool LUA_NATIVE_ENTITY_GET_ENTITY_CAN_BE_DAMAGED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::GET_ENTITY_CAN_BE_DAMAGED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CAN_BE_DAMAGED_BY_RELATIONSHIP_GROUP( int entity, bool bCanBeDamaged, int relGroup) { invoke<void )
	{
		ENTITY::SET_ENTITY_CAN_BE_DAMAGED_BY_RELATIONSHIP_GROUP(entity, bCanBeDamaged, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CAN_ONLY_BE_DAMAGED_BY_SCRIPT_PARTICIPANTS( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_CAN_ONLY_BE_DAMAGED_BY_SCRIPT_PARTICIPANTS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CAN_BE_TARGETED_WITHOUT_LOS( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_CAN_BE_TARGETED_WITHOUT_LOS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_COLLISION( int entity, bool toggle, bool keepPhysics) { invoke<void )
	{
		ENTITY::SET_ENTITY_COLLISION(entity, toggle, invoke<void);
	}

	bool LUA_NATIVE_ENTITY_GET_ENTITY_COLLISION_DISABLED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::GET_ENTITY_COLLISION_DISABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_COMPLETELY_DISABLE_COLLISION( int entity, bool toggle, bool keepPhysics) { invoke<void )
	{
		ENTITY::SET_ENTITY_COMPLETELY_DISABLE_COLLISION(entity, toggle, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_COORDS( int entity, float xPos, float yPos, float zPos, bool xAxis, bool yAxis, bool zAxis, bool clearArea) { invoke<void )
	{
		ENTITY::SET_ENTITY_COORDS(entity, xPos, yPos, zPos, xAxis, yAxis, zAxis, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_COORDS_WITHOUT_PLANTS_RESET( int entity, float xPos, float yPos, float zPos, bool alive, bool deadFlag, bool ragdollFlag, bool clearArea) { invoke<void )
	{
		ENTITY::SET_ENTITY_COORDS_WITHOUT_PLANTS_RESET(entity, xPos, yPos, zPos, alive, deadFlag, ragdollFlag, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_COORDS_NO_OFFSET( int entity, float xPos, float yPos, float zPos, bool xAxis, bool yAxis, bool zAxis) { invoke<void )
	{
		ENTITY::SET_ENTITY_COORDS_NO_OFFSET(entity, xPos, yPos, zPos, xAxis, yAxis, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_DYNAMIC( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_DYNAMIC(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_HEADING( int entity, float heading) { invoke<void )
	{
		ENTITY::SET_ENTITY_HEADING(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_HEALTH( int entity, int health, int p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_HEALTH(entity, health, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_INVINCIBLE( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_INVINCIBLE(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_IS_TARGET_PRIORITY( int entity, bool p1, float p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_IS_TARGET_PRIORITY(entity, p1, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_LIGHTS( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_LIGHTS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_LOAD_COLLISION_FLAG( int entity, bool toggle, Any p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_LOAD_COLLISION_FLAG(entity, toggle, invoke<void);
	}

	bool LUA_NATIVE_ENTITY_HAS_COLLISION_LOADED_AROUND_ENTITY( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)ENTITY::HAS_COLLISION_LOADED_AROUND_ENTITY(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_MAX_SPEED( int entity, float speed) { invoke<void )
	{
		ENTITY::SET_ENTITY_MAX_SPEED(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ONLY_DAMAGED_BY_PLAYER( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_ONLY_DAMAGED_BY_PLAYER(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ONLY_DAMAGED_BY_RELATIONSHIP_GROUP( int entity, bool p1, Any p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_ONLY_DAMAGED_BY_RELATIONSHIP_GROUP(entity, p1, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_PROOFS( int entity, bool bulletProof, bool fireProof, bool explosionProof, bool collisionProof, bool meleeProof, bool steamProof, bool p7, bool waterProof) { invoke<void )
	{
		ENTITY::SET_ENTITY_PROOFS(entity, bulletProof, fireProof, explosionProof, collisionProof, meleeProof, steamProof, p7, invoke<void);
	}

	std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, bool drownProof) { return> LUA_NATIVE_ENTITY_GET_ENTITY_PROOFS( int entity, bool bulletProof, bool fireProof, bool explosionProof, bool collisionProof, bool meleeProof, bool steamProof, bool p7, bool drownProof) { return invoke<BOOL )
	{
		std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, bool drownProof) { return> return_values;
		std::get<0>(return_values) = (bool)ENTITY::GET_ENTITY_PROOFS(entity, (BOOL*)&bulletProof, (BOOL*)&fireProof, (BOOL*)&explosionProof, (BOOL*)&collisionProof, (BOOL*)&meleeProof, (BOOL*)&steamProof, (BOOL*)&p7, &invoke<BOOL);
		std::get<1>(return_values) = bulletProof;
		std::get<2>(return_values) = fireProof;
		std::get<3>(return_values) = explosionProof;
		std::get<4>(return_values) = collisionProof;
		std::get<5>(return_values) = meleeProof;
		std::get<6>(return_values) = steamProof;
		std::get<7>(return_values) = p7;
		std::get<8>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_QUATERNION( int entity, float x, float y, float z, float w) { invoke<void )
	{
		ENTITY::SET_ENTITY_QUATERNION(entity, x, y, z, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_RECORDS_COLLISIONS( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_RECORDS_COLLISIONS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ROTATION( int entity, float pitch, float roll, float yaw, int rotationOrder, bool p5) { invoke<void )
	{
		ENTITY::SET_ENTITY_ROTATION(entity, pitch, roll, yaw, rotationOrder, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_VISIBLE( int entity, bool toggle, bool p2) { invoke<void )
	{
		ENTITY::SET_ENTITY_VISIBLE(entity, toggle, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_WATER_REFLECTION_FLAG( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_WATER_REFLECTION_FLAG(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_MIRROR_REFLECTION_FLAG( int entity, bool p1) { invoke<void )
	{
		ENTITY::SET_ENTITY_MIRROR_REFLECTION_FLAG(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_VELOCITY( int entity, float x, float y, float z) { invoke<void )
	{
		ENTITY::SET_ENTITY_VELOCITY(entity, x, y, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ANGULAR_VELOCITY( int entity, float x, float y, float z) { invoke<void )
	{
		ENTITY::SET_ENTITY_ANGULAR_VELOCITY(entity, x, y, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_HAS_GRAVITY( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_HAS_GRAVITY(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_LOD_DIST( int entity, int value) { invoke<void )
	{
		ENTITY::SET_ENTITY_LOD_DIST(entity, invoke<void);
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_LOD_DIST( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_LOD_DIST(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ALPHA( int entity, int alphaLevel, bool skin) { invoke<void )
	{
		ENTITY::SET_ENTITY_ALPHA(entity, alphaLevel, invoke<void);
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_ALPHA( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_ALPHA(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_RESET_ENTITY_ALPHA( int entity) { invoke<void )
	{
		ENTITY::RESET_ENTITY_ALPHA(invoke<void);
	}

	void LUA_NATIVE_ENTITY_RESET_PICKUP_ENTITY_GLOW( int entity) { invoke<void )
	{
		ENTITY::RESET_PICKUP_ENTITY_GLOW(invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_PICKUP_COLLIDES_WITH_PROJECTILES( Any p0, Any p1) { invoke<void )
	{
		ENTITY::SET_PICKUP_COLLIDES_WITH_PROJECTILES(p0, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_SORT_BIAS( int entity, float p1) { invoke<void )
	{
		ENTITY::SET_ENTITY_SORT_BIAS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_ALWAYS_PRERENDER( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_ALWAYS_PRERENDER(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_RENDER_SCORCHED( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_RENDER_SCORCHED(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_TRAFFICLIGHT_OVERRIDE( int entity, int state) { invoke<void )
	{
		ENTITY::SET_ENTITY_TRAFFICLIGHT_OVERRIDE(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_IS_IN_VEHICLE( int entity) { invoke<void )
	{
		ENTITY::SET_ENTITY_IS_IN_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_ENTITY_CREATE_MODEL_SWAP( float x, float y, float z, float radius, unsigned originalModel, unsigned newModel, bool p6) { invoke<void )
	{
		ENTITY::CREATE_MODEL_SWAP(x, y, z, radius, originalModel, newModel, invoke<void);
	}

	void LUA_NATIVE_ENTITY_REMOVE_MODEL_SWAP( float x, float y, float z, float radius, unsigned originalModel, unsigned newModel, bool p6) { invoke<void )
	{
		ENTITY::REMOVE_MODEL_SWAP(x, y, z, radius, originalModel, newModel, invoke<void);
	}

	void LUA_NATIVE_ENTITY_CREATE_MODEL_HIDE( float x, float y, float z, float radius, unsigned modelHash, bool p5) { invoke<void )
	{
		ENTITY::CREATE_MODEL_HIDE(x, y, z, radius, modelHash, invoke<void);
	}

	void LUA_NATIVE_ENTITY_CREATE_MODEL_HIDE_EXCLUDING_SCRIPT_OBJECTS( float x, float y, float z, float radius, unsigned modelHash, bool p5) { invoke<void )
	{
		ENTITY::CREATE_MODEL_HIDE_EXCLUDING_SCRIPT_OBJECTS(x, y, z, radius, modelHash, invoke<void);
	}

	void LUA_NATIVE_ENTITY_REMOVE_MODEL_HIDE( float x, float y, float z, float radius, unsigned modelHash, bool p5) { invoke<void )
	{
		ENTITY::REMOVE_MODEL_HIDE(x, y, z, radius, modelHash, invoke<void);
	}

	void LUA_NATIVE_ENTITY_CREATE_FORCED_OBJECT( float x, float y, float z, Any p3, unsigned modelHash, bool p5) { invoke<void )
	{
		ENTITY::CREATE_FORCED_OBJECT(x, y, z, p3, modelHash, invoke<void);
	}

	void LUA_NATIVE_ENTITY_REMOVE_FORCED_OBJECT( float x, float y, float z, float p3, unsigned modelHash) { invoke<void )
	{
		ENTITY::REMOVE_FORCED_OBJECT(x, y, z, p3, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_NO_COLLISION_ENTITY( int entity1, int entity2, bool thisFrameOnly) { invoke<void )
	{
		ENTITY::SET_ENTITY_NO_COLLISION_ENTITY(entity1, entity2, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_MOTION_BLUR( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_ENTITY_MOTION_BLUR(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_CAN_AUTO_VAULT_ON_ENTITY( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_CAN_AUTO_VAULT_ON_ENTITY(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_CAN_CLIMB_ON_ENTITY( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_CAN_CLIMB_ON_ENTITY(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_WAIT_FOR_COLLISIONS_BEFORE_PROBE( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_WAIT_FOR_COLLISIONS_BEFORE_PROBE(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_NOWEAPONDECALS( int entity, bool p1) { invoke<void )
	{
		ENTITY::SET_ENTITY_NOWEAPONDECALS(entity, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_USE_MAX_DISTANCE_FOR_WATER_REFLECTION( int entity, bool p1) { invoke<void )
	{
		ENTITY::SET_ENTITY_USE_MAX_DISTANCE_FOR_WATER_REFLECTION(entity, invoke<void);
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_BONE_ROTATION( int entity, int boneIndex) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_ROTATION(entity, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_BONE_POSTION( int entity, int boneIndex) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_POSTION(entity, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_BONE_OBJECT_ROTATION( int entity, int boneIndex) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_OBJECT_ROTATION(entity, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_ENTITY_GET_ENTITY_BONE_OBJECT_POSTION( int entity, int boneIndex) { return invoke<Vector3 )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_OBJECT_POSTION(entity, invoke<Vector3);
		return retval;
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_BONE_COUNT( int entity) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_BONE_COUNT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_ENABLE_ENTITY_BULLET_COLLISION( int entity) { invoke<void )
	{
		ENTITY::ENABLE_ENTITY_BULLET_COLLISION(invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CAN_ONLY_BE_DAMAGED_BY_ENTITY( int entity1, int entity2) { invoke<void )
	{
		ENTITY::SET_ENTITY_CAN_ONLY_BE_DAMAGED_BY_ENTITY(entity1, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ENTITY_CANT_CAUSE_COLLISION_DAMAGED_ENTITY( int entity1, int entity2) { invoke<void )
	{
		ENTITY::SET_ENTITY_CANT_CAUSE_COLLISION_DAMAGED_ENTITY(entity1, invoke<void);
	}

	void LUA_NATIVE_ENTITY_SET_ALLOW_MIGRATE_TO_SPECTATOR( int entity, Any p1) { invoke<void )
	{
		ENTITY::SET_ALLOW_MIGRATE_TO_SPECTATOR(entity, invoke<void);
	}

	int LUA_NATIVE_ENTITY_GET_ENTITY_OF_TYPE_ATTACHED_TO_ENTITY( int entity, unsigned modelHash) { return invoke<int )
	{
		auto retval = ENTITY::GET_ENTITY_OF_TYPE_ATTACHED_TO_ENTITY(entity, invoke<int);
		return retval;
	}

	void LUA_NATIVE_ENTITY_SET_PICK_UP_BY_CARGOBOB_DISABLED( int entity, bool toggle) { invoke<void )
	{
		ENTITY::SET_PICK_UP_BY_CARGOBOB_DISABLED(entity, invoke<void);
	}

	void LUA_NATIVE_EVENT_SET_DECISION_MAKER( int ped, unsigned name) { invoke<void )
	{
		EVENT::SET_DECISION_MAKER(ped, invoke<void);
	}

	void LUA_NATIVE_EVENT_CLEAR_DECISION_MAKER_EVENT_RESPONSE( unsigned name, int eventType) { invoke<void )
	{
		EVENT::CLEAR_DECISION_MAKER_EVENT_RESPONSE(name, invoke<void);
	}

	void LUA_NATIVE_EVENT_BLOCK_DECISION_MAKER_EVENT( unsigned name, int eventType) { invoke<void )
	{
		EVENT::BLOCK_DECISION_MAKER_EVENT(name, invoke<void);
	}

	void LUA_NATIVE_EVENT_UNBLOCK_DECISION_MAKER_EVENT( unsigned name, int eventType) { invoke<void )
	{
		EVENT::UNBLOCK_DECISION_MAKER_EVENT(name, invoke<void);
	}

	int LUA_NATIVE_EVENT_ADD_SHOCKING_EVENT_AT_POSITION( int eventType, float x, float y, float z, float duration) { return invoke<int )
	{
		auto retval = EVENT::ADD_SHOCKING_EVENT_AT_POSITION(eventType, x, y, z, invoke<int);
		return retval;
	}

	int LUA_NATIVE_EVENT_ADD_SHOCKING_EVENT_FOR_ENTITY( int eventType, int entity, float duration) { return invoke<int )
	{
		auto retval = EVENT::ADD_SHOCKING_EVENT_FOR_ENTITY(eventType, entity, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_EVENT_IS_SHOCKING_EVENT_IN_SPHERE( int eventType, float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)EVENT::IS_SHOCKING_EVENT_IN_SPHERE(eventType, x, y, z, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_EVENT_REMOVE_SHOCKING_EVENT( int event) { return invoke<BOOL )
	{
		auto retval = (bool)EVENT::REMOVE_SHOCKING_EVENT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_EVENT_REMOVE_ALL_SHOCKING_EVENTS( bool p0) { invoke<void )
	{
		EVENT::REMOVE_ALL_SHOCKING_EVENTS(invoke<void);
	}

	void LUA_NATIVE_EVENT_REMOVE_SHOCKING_EVENT_SPAWN_BLOCKING_AREAS(  )
	{
		EVENT::REMOVE_SHOCKING_EVENT_SPAWN_BLOCKING_AREAS();
	}

	void LUA_NATIVE_EVENT_SUPPRESS_SHOCKING_EVENTS_NEXT_FRAME(  )
	{
		EVENT::SUPPRESS_SHOCKING_EVENTS_NEXT_FRAME();
	}

	void LUA_NATIVE_EVENT_SUPPRESS_SHOCKING_EVENT_TYPE_NEXT_FRAME( int eventType) { invoke<void )
	{
		EVENT::SUPPRESS_SHOCKING_EVENT_TYPE_NEXT_FRAME(invoke<void);
	}

	void LUA_NATIVE_EVENT_SUPPRESS_AGITATION_EVENTS_NEXT_FRAME(  )
	{
		EVENT::SUPPRESS_AGITATION_EVENTS_NEXT_FRAME();
	}

	int LUA_NATIVE_FILES_GET_NUM_TATTOO_SHOP_DLC_ITEMS( int character) { return invoke<int )
	{
		auto retval = FILES::GET_NUM_TATTOO_SHOP_DLC_ITEMS(invoke<int);
		return retval;
	}

	std::tuple<bool, Any outComponent) { return> LUA_NATIVE_FILES_GET_TATTOO_SHOP_DLC_ITEM_DATA( int characterType, int decorationIndex, Any outComponent) { return invoke<BOOL )
	{
		std::tuple<bool, Any outComponent) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_TATTOO_SHOP_DLC_ITEM_DATA(characterType, decorationIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_FILES_GET_TATTOO_SHOP_DLC_ITEM_INDEX( unsigned overlayHash, Any p1, int character) { return invoke<int )
	{
		auto retval = FILES::GET_TATTOO_SHOP_DLC_ITEM_INDEX(overlayHash, p1, invoke<int);
		return retval;
	}

	Any outComponent) { LUA_NATIVE_FILES_INIT_SHOP_PED_COMPONENT( Any outComponent) { invoke<void )
	{
		FILES::INIT_SHOP_PED_COMPONENT(&invoke<void);
		return invoke<void;
	}

	Any outProp) { LUA_NATIVE_FILES_INIT_SHOP_PED_PROP( Any outProp) { invoke<void )
	{
		FILES::INIT_SHOP_PED_PROP(&invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_FILES_SETUP_SHOP_PED_APPAREL_QUERY( int p0, int p1, int p2, int p3) { return invoke<int )
	{
		auto retval = FILES::SETUP_SHOP_PED_APPAREL_QUERY(p0, p1, p2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_FILES_SETUP_SHOP_PED_APPAREL_QUERY_TU( int character, int p1, int p2, bool p3, int p4, int componentId) { return invoke<int )
	{
		auto retval = FILES::SETUP_SHOP_PED_APPAREL_QUERY_TU(character, p1, p2, p3, p4, invoke<int);
		return retval;
	}

	Any outComponent) { LUA_NATIVE_FILES_GET_SHOP_PED_QUERY_COMPONENT( int componentId, Any outComponent) { invoke<void )
	{
		FILES::GET_SHOP_PED_QUERY_COMPONENT(componentId, &invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_QUERY_COMPONENT_INDEX( unsigned componentHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_QUERY_COMPONENT_INDEX(invoke<int);
		return retval;
	}

	Any outComponent) { LUA_NATIVE_FILES_GET_SHOP_PED_COMPONENT( unsigned componentHash, Any outComponent) { invoke<void )
	{
		FILES::GET_SHOP_PED_COMPONENT(componentHash, &invoke<void);
		return invoke<void;
	}

	Any outProp) { LUA_NATIVE_FILES_GET_SHOP_PED_QUERY_PROP( int componentId, Any outProp) { invoke<void )
	{
		FILES::GET_SHOP_PED_QUERY_PROP(componentId, &invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_QUERY_PROP_INDEX( unsigned componentHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_QUERY_PROP_INDEX(invoke<int);
		return retval;
	}

	Any outProp) { LUA_NATIVE_FILES_GET_SHOP_PED_PROP( unsigned componentHash, Any outProp) { invoke<void )
	{
		FILES::GET_SHOP_PED_PROP(componentHash, &invoke<void);
		return invoke<void;
	}

	unsigned LUA_NATIVE_FILES_GET_HASH_NAME_FOR_COMPONENT( int entity, int componentId, int drawableVariant, int textureVariant) { return invoke<unsigned )
	{
		auto retval = FILES::GET_HASH_NAME_FOR_COMPONENT(entity, componentId, drawableVariant, invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_FILES_GET_HASH_NAME_FOR_PROP( int entity, int componentId, int propIndex, int propTextureIndex) { return invoke<unsigned )
	{
		auto retval = FILES::GET_HASH_NAME_FOR_PROP(entity, componentId, propIndex, invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_APPAREL_VARIANT_COMPONENT_COUNT( unsigned componentHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_APPAREL_VARIANT_COMPONENT_COUNT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_APPAREL_VARIANT_PROP_COUNT( unsigned propHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_APPAREL_VARIANT_PROP_COUNT(invoke<int);
		return retval;
	}

	std::tuple<unsigned, int, int componentType) {> LUA_NATIVE_FILES_GET_VARIANT_COMPONENT( unsigned componentHash, int variantComponentIndex, unsigned nameHash, int enumValue, int componentType) { invoke<void )
	{
		std::tuple<unsigned, int, int componentType) {> return_values;
		FILES::GET_VARIANT_COMPONENT(componentHash, variantComponentIndex, &nameHash, &enumValue, &invoke<void);
		std::get<0>(return_values) = nameHash;
		std::get<1>(return_values) = enumValue;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<unsigned, int, int anchorPoint) {> LUA_NATIVE_FILES_GET_VARIANT_PROP( unsigned componentHash, int variantPropIndex, unsigned nameHash, int enumValue, int anchorPoint) { invoke<void )
	{
		std::tuple<unsigned, int, int anchorPoint) {> return_values;
		FILES::GET_VARIANT_PROP(componentHash, variantPropIndex, &nameHash, &enumValue, &invoke<void);
		std::get<0>(return_values) = nameHash;
		std::get<1>(return_values) = enumValue;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_APPAREL_FORCED_COMPONENT_COUNT( unsigned componentHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_APPAREL_FORCED_COMPONENT_COUNT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_APPAREL_FORCED_PROP_COUNT( unsigned componentHash) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_APPAREL_FORCED_PROP_COUNT(invoke<int);
		return retval;
	}

	std::tuple<unsigned, int, int componentType) {> LUA_NATIVE_FILES_GET_FORCED_COMPONENT( unsigned componentHash, int forcedComponentIndex, unsigned nameHash, int enumValue, int componentType) { invoke<void )
	{
		std::tuple<unsigned, int, int componentType) {> return_values;
		FILES::GET_FORCED_COMPONENT(componentHash, forcedComponentIndex, &nameHash, &enumValue, &invoke<void);
		std::get<0>(return_values) = nameHash;
		std::get<1>(return_values) = enumValue;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<unsigned, int, int anchorPoint) {> LUA_NATIVE_FILES_GET_FORCED_PROP( unsigned componentHash, int forcedPropIndex, unsigned nameHash, int enumValue, int anchorPoint) { invoke<void )
	{
		std::tuple<unsigned, int, int anchorPoint) {> return_values;
		FILES::GET_FORCED_PROP(componentHash, forcedPropIndex, &nameHash, &enumValue, &invoke<void);
		std::get<0>(return_values) = nameHash;
		std::get<1>(return_values) = enumValue;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	bool LUA_NATIVE_FILES_DOES_SHOP_PED_APPAREL_HAVE_RESTRICTION_TAG( unsigned componentHash, unsigned restrictionTagHash, int componentId) { return invoke<BOOL )
	{
		auto retval = (bool)FILES::DOES_SHOP_PED_APPAREL_HAVE_RESTRICTION_TAG(componentHash, restrictionTagHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_FILES_DOES_CURRENT_PED_COMPONENT_HAVE_RESTRICTION_TAG( int ped, int componentId, unsigned restrictionTagHash) { return invoke<BOOL )
	{
		auto retval = (bool)FILES::DOES_CURRENT_PED_COMPONENT_HAVE_RESTRICTION_TAG(ped, componentId, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_FILES_DOES_CURRENT_PED_PROP_HAVE_RESTRICTION_TAG( int ped, int componentId, unsigned restrictionTagHash) { return invoke<BOOL )
	{
		auto retval = (bool)FILES::DOES_CURRENT_PED_PROP_HAVE_RESTRICTION_TAG(ped, componentId, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_FILES_SETUP_SHOP_PED_OUTFIT_QUERY( int character, bool p1) { return invoke<int )
	{
		auto retval = FILES::SETUP_SHOP_PED_OUTFIT_QUERY(character, invoke<int);
		return retval;
	}

	Any outfit) { LUA_NATIVE_FILES_GET_SHOP_PED_QUERY_OUTFIT( int outfitIndex, Any outfit) { invoke<void )
	{
		FILES::GET_SHOP_PED_QUERY_OUTFIT(outfitIndex, &invoke<void);
		return invoke<void;
	}

	Any p1) { LUA_NATIVE_FILES_GET_SHOP_PED_OUTFIT( Any p0, Any p1) { invoke<void )
	{
		FILES::GET_SHOP_PED_OUTFIT(p0, &invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_FILES_GET_SHOP_PED_OUTFIT_LOCATE( Any p0) { return invoke<int )
	{
		auto retval = FILES::GET_SHOP_PED_OUTFIT_LOCATE(invoke<int);
		return retval;
	}

	std::tuple<bool, Any outPropVariant) { return> LUA_NATIVE_FILES_GET_SHOP_PED_OUTFIT_PROP_VARIANT( unsigned outfitHash, int variantIndex, Any outPropVariant) { return invoke<BOOL )
	{
		std::tuple<bool, Any outPropVariant) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_SHOP_PED_OUTFIT_PROP_VARIANT(outfitHash, variantIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any outComponentVariant) { return> LUA_NATIVE_FILES_GET_SHOP_PED_OUTFIT_COMPONENT_VARIANT( unsigned outfitHash, int variantIndex, Any outComponentVariant) { return invoke<BOOL )
	{
		std::tuple<bool, Any outComponentVariant) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_SHOP_PED_OUTFIT_COMPONENT_VARIANT(outfitHash, variantIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_FILES_GET_NUM_DLC_VEHICLES(  )
	{
		auto retval = FILES::GET_NUM_DLC_VEHICLES();
		return retval;
	}

	unsigned LUA_NATIVE_FILES_GET_DLC_VEHICLE_MODEL( int dlcVehicleIndex) { return invoke<unsigned )
	{
		auto retval = FILES::GET_DLC_VEHICLE_MODEL(invoke<unsigned);
		return retval;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_FILES_GET_DLC_VEHICLE_DATA( int dlcVehicleIndex, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_DLC_VEHICLE_DATA(dlcVehicleIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_FILES_GET_DLC_VEHICLE_FLAGS( int dlcVehicleIndex) { return invoke<int )
	{
		auto retval = FILES::GET_DLC_VEHICLE_FLAGS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_FILES_GET_NUM_DLC_WEAPONS(  )
	{
		auto retval = FILES::GET_NUM_DLC_WEAPONS();
		return retval;
	}

	int LUA_NATIVE_FILES_GET_NUM_DLC_WEAPONS_SP(  )
	{
		auto retval = FILES::GET_NUM_DLC_WEAPONS_SP();
		return retval;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_FILES_GET_DLC_WEAPON_DATA( int dlcWeaponIndex, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_DLC_WEAPON_DATA(dlcWeaponIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_FILES_GET_DLC_WEAPON_DATA_SP( int dlcWeaponIndex, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_DLC_WEAPON_DATA_SP(dlcWeaponIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_FILES_GET_NUM_DLC_WEAPON_COMPONENTS( int dlcWeaponIndex) { return invoke<int )
	{
		auto retval = FILES::GET_NUM_DLC_WEAPON_COMPONENTS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_FILES_GET_NUM_DLC_WEAPON_COMPONENTS_SP( int dlcWeaponIndex) { return invoke<int )
	{
		auto retval = FILES::GET_NUM_DLC_WEAPON_COMPONENTS_SP(invoke<int);
		return retval;
	}

	std::tuple<bool, Any ComponentDataPtr) { return> LUA_NATIVE_FILES_GET_DLC_WEAPON_COMPONENT_DATA( int dlcWeaponIndex, int dlcWeapCompIndex, Any ComponentDataPtr) { return invoke<BOOL )
	{
		std::tuple<bool, Any ComponentDataPtr) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_DLC_WEAPON_COMPONENT_DATA(dlcWeaponIndex, dlcWeapCompIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any ComponentDataPtr) { return> LUA_NATIVE_FILES_GET_DLC_WEAPON_COMPONENT_DATA_SP( int dlcWeaponIndex, int dlcWeapCompIndex, Any ComponentDataPtr) { return invoke<BOOL )
	{
		std::tuple<bool, Any ComponentDataPtr) { return> return_values;
		std::get<0>(return_values) = (bool)FILES::GET_DLC_WEAPON_COMPONENT_DATA_SP(dlcWeaponIndex, dlcWeapCompIndex, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_FILES_IS_CONTENT_ITEM_LOCKED( unsigned itemHash) { return invoke<BOOL )
	{
		auto retval = (bool)FILES::IS_CONTENT_ITEM_LOCKED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_FILES_IS_DLC_VEHICLE_MOD( unsigned hash) { return invoke<BOOL )
	{
		auto retval = (bool)FILES::IS_DLC_VEHICLE_MOD(invoke<BOOL);
		return retval;
	}

	unsigned LUA_NATIVE_FILES_GET_DLC_VEHICLE_MOD_LOCK_HASH( unsigned hash) { return invoke<unsigned )
	{
		auto retval = FILES::GET_DLC_VEHICLE_MOD_LOCK_HASH(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_FILES_EXECUTE_CONTENT_CHANGESET_GROUP_FOR_ALL( unsigned hash) { invoke<void )
	{
		FILES::EXECUTE_CONTENT_CHANGESET_GROUP_FOR_ALL(invoke<void);
	}

	void LUA_NATIVE_FILES_REVERT_CONTENT_CHANGESET_GROUP_FOR_ALL( unsigned hash) { invoke<void )
	{
		FILES::REVERT_CONTENT_CHANGESET_GROUP_FOR_ALL(invoke<void);
	}

	int LUA_NATIVE_FIRE_START_SCRIPT_FIRE( float X, float Y, float Z, int maxChildren, bool isGasFire) { return invoke<int )
	{
		auto retval = FIRE::START_SCRIPT_FIRE(X, Y, Z, maxChildren, invoke<int);
		return retval;
	}

	void LUA_NATIVE_FIRE_REMOVE_SCRIPT_FIRE( int fireHandle) { invoke<void )
	{
		FIRE::REMOVE_SCRIPT_FIRE(invoke<void);
	}

	int LUA_NATIVE_FIRE_START_ENTITY_FIRE( int entity) { return invoke<int )
	{
		auto retval = FIRE::START_ENTITY_FIRE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_FIRE_STOP_ENTITY_FIRE( int entity) { invoke<void )
	{
		FIRE::STOP_ENTITY_FIRE(invoke<void);
	}

	bool LUA_NATIVE_FIRE_IS_ENTITY_ON_FIRE( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)FIRE::IS_ENTITY_ON_FIRE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_FIRE_GET_NUMBER_OF_FIRES_IN_RANGE( float x, float y, float z, float radius) { return invoke<int )
	{
		auto retval = FIRE::GET_NUMBER_OF_FIRES_IN_RANGE(x, y, z, invoke<int);
		return retval;
	}

	void LUA_NATIVE_FIRE_SET_FLAMMABILITY_MULTIPLIER( float p0) { invoke<void )
	{
		FIRE::SET_FLAMMABILITY_MULTIPLIER(invoke<void);
	}

	void LUA_NATIVE_FIRE_STOP_FIRE_IN_RANGE( float x, float y, float z, float radius) { invoke<void )
	{
		FIRE::STOP_FIRE_IN_RANGE(x, y, z, invoke<void);
	}

	std::tuple<bool, Vector3> LUA_NATIVE_FIRE_GET_CLOSEST_FIRE_POS( Vector3 outPosition, float x, float y, float z) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)FIRE::GET_CLOSEST_FIRE_POS(&outPosition, x, y, invoke<BOOL);
		std::get<1>(return_values) = outPosition;

		return return_values;
	}

	void LUA_NATIVE_FIRE_ADD_EXPLOSION( float x, float y, float z, int explosionType, float damageScale, bool isAudible, bool isInvisible, float cameraShake, bool noDamage) { invoke<void )
	{
		FIRE::ADD_EXPLOSION(x, y, z, explosionType, damageScale, isAudible, isInvisible, cameraShake, invoke<void);
	}

	void LUA_NATIVE_FIRE_ADD_OWNED_EXPLOSION( int ped, float x, float y, float z, int explosionType, float damageScale, bool isAudible, bool isInvisible, float cameraShake) { invoke<void )
	{
		FIRE::ADD_OWNED_EXPLOSION(ped, x, y, z, explosionType, damageScale, isAudible, isInvisible, invoke<void);
	}

	void LUA_NATIVE_FIRE_ADD_EXPLOSION_WITH_USER_VFX( float x, float y, float z, int explosionType, unsigned explosionFx, float damageScale, bool isAudible, bool isInvisible, float cameraShake) { invoke<void )
	{
		FIRE::ADD_EXPLOSION_WITH_USER_VFX(x, y, z, explosionType, explosionFx, damageScale, isAudible, isInvisible, invoke<void);
	}

	bool LUA_NATIVE_FIRE_IS_EXPLOSION_IN_AREA( int explosionType, float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)FIRE::IS_EXPLOSION_IN_AREA(explosionType, x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_FIRE_IS_EXPLOSION_ACTIVE_IN_AREA( int explosionType, float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)FIRE::IS_EXPLOSION_ACTIVE_IN_AREA(explosionType, x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_FIRE_IS_EXPLOSION_IN_SPHERE( int explosionType, float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)FIRE::IS_EXPLOSION_IN_SPHERE(explosionType, x, y, z, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_FIRE_GET_OWNER_OF_EXPLOSION_IN_SPHERE( int explosionType, float x, float y, float z, float radius) { return invoke<int )
	{
		auto retval = FIRE::GET_OWNER_OF_EXPLOSION_IN_SPHERE(explosionType, x, y, z, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_FIRE_IS_EXPLOSION_IN_ANGLED_AREA( int explosionType, float x1, float y1, float z1, float x2, float y2, float z2, float width) { return invoke<BOOL )
	{
		auto retval = (bool)FIRE::IS_EXPLOSION_IN_ANGLED_AREA(explosionType, x1, y1, z1, x2, y2, z2, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_FIRE_GET_OWNER_OF_EXPLOSION_IN_ANGLED_AREA( int explosionType, float x1, float y1, float z1, float x2, float y2, float z2, float radius) { return invoke<int )
	{
		auto retval = FIRE::GET_OWNER_OF_EXPLOSION_IN_ANGLED_AREA(explosionType, x1, y1, z1, x2, y2, z2, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_DEBUG_LINES_AND_SPHERES_DRAWING_ACTIVE( bool enabled) { invoke<void )
	{
		GRAPHICS::SET_DEBUG_LINES_AND_SPHERES_DRAWING_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_LINE( float x1, float y1, float z1, float x2, float y2, float z2, int r, int g, int b, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_LINE(x1, y1, z1, x2, y2, z2, r, g, b, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_LINE_WITH_TWO_COLOURS( float x1, float y1, float z1, float x2, float y2, float z2, int r1, int g1, int b1, int r2, int g2, int b2, int alpha1, int alpha2) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_LINE_WITH_TWO_COLOURS(x1, y1, z1, x2, y2, z2, r1, g1, b1, r2, g2, b2, alpha1, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_SPHERE( float x, float y, float z, float radius, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_SPHERE(x, y, z, radius, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_BOX( float x1, float y1, float z1, float x2, float y2, float z2, int r, int g, int b, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_BOX(x1, y1, z1, x2, y2, z2, r, g, b, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_CROSS( float x, float y, float z, float size, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_CROSS(x, y, z, size, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_TEXT( const char* text, float x, float y, float z, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_TEXT(text, x, y, z, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_DEBUG_TEXT_2D( const char* text, float x, float y, float z, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_DEBUG_TEXT_2D(text, x, y, z, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_LINE( float x1, float y1, float z1, float x2, float y2, float z2, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_LINE(x1, y1, z1, x2, y2, z2, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_POLY( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_POLY(x1, y1, z1, x2, y2, z2, x3, y3, z3, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_TEXTURED_POLY( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, int red, int green, int blue, int alpha, const char* textureDict, const char* textureName, float u1, float v1, float w1, float u2, float v2, float w2, float u3, float v3, float w3) { invoke<void )
	{
		GRAPHICS::DRAW_TEXTURED_POLY(x1, y1, z1, x2, y2, z2, x3, y3, z3, red, green, blue, alpha, textureDict, textureName, u1, v1, w1, u2, v2, w2, u3, v3, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_TEXTURED_POLY_WITH_THREE_COLOURS( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float red1, float green1, float blue1, int alpha1, float red2, float green2, float blue2, int alpha2, float red3, float green3, float blue3, int alpha3, const char* textureDict, const char* textureName, float u1, float v1, float w1, float u2, float v2, float w2, float u3, float v3, float w3) { invoke<void )
	{
		GRAPHICS::DRAW_TEXTURED_POLY_WITH_THREE_COLOURS(x1, y1, z1, x2, y2, z2, x3, y3, z3, red1, green1, blue1, alpha1, red2, green2, blue2, alpha2, red3, green3, blue3, alpha3, textureDict, textureName, u1, v1, w1, u2, v2, w2, u3, v3, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_BOX( float x1, float y1, float z1, float x2, float y2, float z2, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_BOX(x1, y1, z1, x2, y2, z2, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_BACKFACECULLING( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_BACKFACECULLING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_DEPTHWRITING( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_DEPTHWRITING(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_TAKE_MISSION_CREATOR_PHOTO(  )
	{
		auto retval = (bool)GRAPHICS::BEGIN_TAKE_MISSION_CREATOR_PHOTO();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_TAKE_MISSION_CREATOR_PHOTO(  )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_TAKE_MISSION_CREATOR_PHOTO();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_FREE_MEMORY_FOR_MISSION_CREATOR_PHOTO(  )
	{
		GRAPHICS::FREE_MEMORY_FOR_MISSION_CREATOR_PHOTO();
	}

	std::tuple<bool, Any> LUA_NATIVE_GRAPHICS_LOAD_MISSION_CREATOR_PHOTO( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)GRAPHICS::LOAD_MISSION_CREATOR_PHOTO(&p0, p1, p2, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<int, Any p0) { return> LUA_NATIVE_GRAPHICS_GET_STATUS_OF_LOAD_MISSION_CREATOR_PHOTO( Any p0) { return invoke<int )
	{
		std::tuple<int, Any p0) { return> return_values;
		std::get<0>(return_values) = GRAPHICS::GET_STATUS_OF_LOAD_MISSION_CREATOR_PHOTO(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_CREATE_MISSION_CREATOR_PHOTO_PREVIEW(  )
	{
		auto retval = (bool)GRAPHICS::BEGIN_CREATE_MISSION_CREATOR_PHOTO_PREVIEW();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_CREATE_MISSION_CREATOR_PHOTO_PREVIEW(  )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_CREATE_MISSION_CREATOR_PHOTO_PREVIEW();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_FREE_MEMORY_FOR_MISSION_CREATOR_PHOTO_PREVIEW(  )
	{
		GRAPHICS::FREE_MEMORY_FOR_MISSION_CREATOR_PHOTO_PREVIEW();
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_TAKE_HIGH_QUALITY_PHOTO(  )
	{
		auto retval = (bool)GRAPHICS::BEGIN_TAKE_HIGH_QUALITY_PHOTO();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_TAKE_HIGH_QUALITY_PHOTO(  )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_TAKE_HIGH_QUALITY_PHOTO();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_FREE_MEMORY_FOR_HIGH_QUALITY_PHOTO(  )
	{
		GRAPHICS::FREE_MEMORY_FOR_HIGH_QUALITY_PHOTO();
	}

	void LUA_NATIVE_GRAPHICS_SET_TAKEN_PHOTO_IS_MUGSHOT( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_TAKEN_PHOTO_IS_MUGSHOT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_ARENA_THEME_AND_VARIATION_FOR_TAKEN_PHOTO( Any p0, int p1) { invoke<void )
	{
		GRAPHICS::SET_ARENA_THEME_AND_VARIATION_FOR_TAKEN_PHOTO(p0, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_ON_ISLAND_X_FOR_TAKEN_PHOTO( Any p0) { invoke<void )
	{
		GRAPHICS::SET_ON_ISLAND_X_FOR_TAKEN_PHOTO(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_SAVE_HIGH_QUALITY_PHOTO( int unused) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::SAVE_HIGH_QUALITY_PHOTO(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_SAVE_HIGH_QUALITY_PHOTO(  )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_SAVE_HIGH_QUALITY_PHOTO();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_CREATE_LOW_QUALITY_COPY_OF_PHOTO( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::BEGIN_CREATE_LOW_QUALITY_COPY_OF_PHOTO(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_CREATE_LOW_QUALITY_COPY_OF_PHOTO( int p0) { return invoke<int )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_CREATE_LOW_QUALITY_COPY_OF_PHOTO(invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_FREE_MEMORY_FOR_LOW_QUALITY_PHOTO(  )
	{
		GRAPHICS::FREE_MEMORY_FOR_LOW_QUALITY_PHOTO();
	}

	void LUA_NATIVE_GRAPHICS_DRAW_LOW_QUALITY_PHOTO_TO_PHONE( bool p0, bool p1) { invoke<void )
	{
		GRAPHICS::DRAW_LOW_QUALITY_PHOTO_TO_PHONE(p0, invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_GET_MAXIMUM_NUMBER_OF_PHOTOS(  )
	{
		auto retval = GRAPHICS::GET_MAXIMUM_NUMBER_OF_PHOTOS();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_MAXIMUM_NUMBER_OF_CLOUD_PHOTOS(  )
	{
		auto retval = GRAPHICS::GET_MAXIMUM_NUMBER_OF_CLOUD_PHOTOS();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_CURRENT_NUMBER_OF_CLOUD_PHOTOS(  )
	{
		auto retval = GRAPHICS::GET_CURRENT_NUMBER_OF_CLOUD_PHOTOS();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_QUEUE_OPERATION_TO_CREATE_SORTED_LIST_OF_PHOTOS( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::QUEUE_OPERATION_TO_CREATE_SORTED_LIST_OF_PHOTOS(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_STATUS_OF_SORTED_LIST_OPERATION( Any p0) { return invoke<int )
	{
		auto retval = GRAPHICS::GET_STATUS_OF_SORTED_LIST_OPERATION(invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_STATUS_OF_SORTED_LIST_OPERATION(  )
	{
		GRAPHICS::CLEAR_STATUS_OF_SORTED_LIST_OPERATION();
	}

	bool LUA_NATIVE_GRAPHICS_DOES_THIS_PHOTO_SLOT_CONTAIN_A_VALID_PHOTO( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::DOES_THIS_PHOTO_SLOT_CONTAIN_A_VALID_PHOTO(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_LOAD_HIGH_QUALITY_PHOTO( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::LOAD_HIGH_QUALITY_PHOTO(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_LOAD_HIGH_QUALITY_PHOTO_STATUS( int p0) { return invoke<int )
	{
		auto retval = GRAPHICS::GET_LOAD_HIGH_QUALITY_PHOTO_STATUS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DRAW_LIGHT_WITH_RANGEEX( float x, float y, float z, int r, int g, int b, float range, float intensity, float shadow) { invoke<void )
	{
		GRAPHICS::DRAW_LIGHT_WITH_RANGEEX(x, y, z, r, g, b, range, intensity, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_LIGHT_WITH_RANGE( float posX, float posY, float posZ, int colorR, int colorG, int colorB, float range, float intensity) { invoke<void )
	{
		GRAPHICS::DRAW_LIGHT_WITH_RANGE(posX, posY, posZ, colorR, colorG, colorB, range, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SPOT_LIGHT( float posX, float posY, float posZ, float dirX, float dirY, float dirZ, int colorR, int colorG, int colorB, float distance, float brightness, float hardness, float radius, float falloff) { invoke<void )
	{
		GRAPHICS::DRAW_SPOT_LIGHT(posX, posY, posZ, dirX, dirY, dirZ, colorR, colorG, colorB, distance, brightness, hardness, radius, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SHADOWED_SPOT_LIGHT( float posX, float posY, float posZ, float dirX, float dirY, float dirZ, int colorR, int colorG, int colorB, float distance, float brightness, float roundness, float radius, float falloff, int shadowId) { invoke<void )
	{
		GRAPHICS::DRAW_SHADOWED_SPOT_LIGHT(posX, posY, posZ, dirX, dirY, dirZ, colorR, colorG, colorB, distance, brightness, roundness, radius, falloff, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FADE_UP_PED_LIGHT( float p0) { invoke<void )
	{
		GRAPHICS::FADE_UP_PED_LIGHT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_UPDATE_LIGHTS_ON_ENTITY( int entity) { invoke<void )
	{
		GRAPHICS::UPDATE_LIGHTS_ON_ENTITY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_LIGHT_OVERRIDE_MAX_INTENSITY_SCALE( Any p0) { invoke<void )
	{
		GRAPHICS::SET_LIGHT_OVERRIDE_MAX_INTENSITY_SCALE(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_GET_LIGHT_OVERRIDE_MAX_INTENSITY_SCALE(  )
	{
		auto retval = GRAPHICS::GET_LIGHT_OVERRIDE_MAX_INTENSITY_SCALE();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DRAW_MARKER( int type, float posX, float posY, float posZ, float dirX, float dirY, float dirZ, float rotX, float rotY, float rotZ, float scaleX, float scaleY, float scaleZ, int red, int green, int blue, int alpha, bool bobUpAndDown, bool faceCamera, int p19, bool rotate, const char* textureDict, const char* textureName, bool drawOnEnts) { invoke<void )
	{
		GRAPHICS::DRAW_MARKER(type, posX, posY, posZ, dirX, dirY, dirZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ, red, green, blue, alpha, bobUpAndDown, faceCamera, p19, rotate, textureDict, textureName, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_MARKER_EX( int type, float posX, float posY, float posZ, float dirX, float dirY, float dirZ, float rotX, float rotY, float rotZ, float scaleX, float scaleY, float scaleZ, int red, int green, int blue, int alpha, bool bobUpAndDown, bool faceCamera, Any p19, bool rotate, const char* textureDict, const char* textureName, bool drawOnEnts, bool p24, bool p25) { invoke<void )
	{
		GRAPHICS::DRAW_MARKER_EX(type, posX, posY, posZ, dirX, dirY, dirZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ, red, green, blue, alpha, bobUpAndDown, faceCamera, p19, rotate, textureDict, textureName, drawOnEnts, p24, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_MARKER_SPHERE( float x, float y, float z, float radius, int red, int green, int blue, float alpha) { invoke<void )
	{
		GRAPHICS::DRAW_MARKER_SPHERE(x, y, z, radius, red, green, blue, invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_CREATE_CHECKPOINT( int type, float posX1, float posY1, float posZ1, float posX2, float posY2, float posZ2, float diameter, int red, int green, int blue, int alpha, int reserved) { return invoke<int )
	{
		auto retval = GRAPHICS::CREATE_CHECKPOINT(type, posX1, posY1, posZ1, posX2, posY2, posZ2, diameter, red, green, blue, alpha, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_INSIDE_CYLINDER_HEIGHT_SCALE( int checkpoint, float scale) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_INSIDE_CYLINDER_HEIGHT_SCALE(checkpoint, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_INSIDE_CYLINDER_SCALE( int checkpoint, float scale) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_INSIDE_CYLINDER_SCALE(checkpoint, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_CYLINDER_HEIGHT( int checkpoint, float nearHeight, float farHeight, float radius) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_CYLINDER_HEIGHT(checkpoint, nearHeight, farHeight, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_RGBA( int checkpoint, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_RGBA(checkpoint, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_RGBA2( int checkpoint, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_RGBA2(checkpoint, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_CLIPPLANE_WITH_POS_NORM( int checkpoint, float posX, float posY, float posZ, float unkX, float unkY, float unkZ) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_CLIPPLANE_WITH_POS_NORM(checkpoint, posX, posY, posZ, unkX, unkY, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_FORCE_OLD_ARROW_POINTING( int checkpoint) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_FORCE_OLD_ARROW_POINTING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_DECAL_ROT_ALIGNED_TO_CAMERA_ROT( int checkpoint) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_DECAL_ROT_ALIGNED_TO_CAMERA_ROT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_FORCE_DIRECTION( int checkpoint) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_FORCE_DIRECTION(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_CHECKPOINT_DIRECTION( int checkpoint, float posX, float posY, float posZ) { invoke<void )
	{
		GRAPHICS::SET_CHECKPOINT_DIRECTION(checkpoint, posX, posY, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DELETE_CHECKPOINT( int checkpoint) { invoke<void )
	{
		GRAPHICS::DELETE_CHECKPOINT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DONT_RENDER_IN_GAME_UI( bool p0) { invoke<void )
	{
		GRAPHICS::DONT_RENDER_IN_GAME_UI(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FORCE_RENDER_IN_GAME_UI( bool toggle) { invoke<void )
	{
		GRAPHICS::FORCE_RENDER_IN_GAME_UI(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REQUEST_STREAMED_TEXTURE_DICT( const char* textureDict, bool p1) { invoke<void )
	{
		GRAPHICS::REQUEST_STREAMED_TEXTURE_DICT(textureDict, invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_HAS_STREAMED_TEXTURE_DICT_LOADED( const char* textureDict) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::HAS_STREAMED_TEXTURE_DICT_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_STREAMED_TEXTURE_DICT_AS_NO_LONGER_NEEDED( const char* textureDict) { invoke<void )
	{
		GRAPHICS::SET_STREAMED_TEXTURE_DICT_AS_NO_LONGER_NEEDED(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_RECT( float x, float y, float width, float height, int r, int g, int b, int a, bool p8) { invoke<void )
	{
		GRAPHICS::DRAW_RECT(x, y, width, height, r, g, b, a, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SCRIPT_GFX_DRAW_BEHIND_PAUSEMENU( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_SCRIPT_GFX_DRAW_BEHIND_PAUSEMENU(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SCRIPT_GFX_DRAW_ORDER( int drawOrder) { invoke<void )
	{
		GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SCRIPT_GFX_ALIGN( int horizontalAlign, int verticalAlign) { invoke<void )
	{
		GRAPHICS::SET_SCRIPT_GFX_ALIGN(horizontalAlign, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_RESET_SCRIPT_GFX_ALIGN(  )
	{
		GRAPHICS::RESET_SCRIPT_GFX_ALIGN();
	}

	void LUA_NATIVE_GRAPHICS_SET_SCRIPT_GFX_ALIGN_PARAMS( float x, float y, float w, float h) { invoke<void )
	{
		GRAPHICS::SET_SCRIPT_GFX_ALIGN_PARAMS(x, y, w, invoke<void);
	}

	std::tuple<float, float calculatedY) {> LUA_NATIVE_GRAPHICS_GET_SCRIPT_GFX_ALIGN_POSITION( float x, float y, float calculatedX, float calculatedY) { invoke<void )
	{
		std::tuple<float, float calculatedY) {> return_values;
		GRAPHICS::GET_SCRIPT_GFX_ALIGN_POSITION(x, y, &calculatedX, &invoke<void);
		std::get<0>(return_values) = calculatedX;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	float LUA_NATIVE_GRAPHICS_GET_SAFE_ZONE_SIZE(  )
	{
		auto retval = GRAPHICS::GET_SAFE_ZONE_SIZE();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SPRITE( const char* textureDict, const char* textureName, float screenX, float screenY, float width, float height, float heading, int red, int green, int blue, int alpha, bool p11, Any p12) { invoke<void )
	{
		GRAPHICS::DRAW_SPRITE(textureDict, textureName, screenX, screenY, width, height, heading, red, green, blue, alpha, p11, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SPRITE_ARX( const char* textureDict, const char* textureName, float x, float y, float width, float height, float p6, int red, int green, int blue, int alpha, Any p11, Any p12) { invoke<void )
	{
		GRAPHICS::DRAW_SPRITE_ARX(textureDict, textureName, x, y, width, height, p6, red, green, blue, alpha, p11, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SPRITE_NAMED_RENDERTARGET( const char* textureDict, const char* textureName, float screenX, float screenY, float width, float height, float heading, int red, int green, int blue, int alpha, Any p11) { invoke<void )
	{
		GRAPHICS::DRAW_SPRITE_NAMED_RENDERTARGET(textureDict, textureName, screenX, screenY, width, height, heading, red, green, blue, alpha, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SPRITE_ARX_WITH_UV( const char* textureDict, const char* textureName, float x, float y, float width, float height, float u1, float v1, float u2, float v2, float heading, int red, int green, int blue, int alpha, Any p15) { invoke<void )
	{
		GRAPHICS::DRAW_SPRITE_ARX_WITH_UV(textureDict, textureName, x, y, width, height, u1, v1, u2, v2, heading, red, green, blue, alpha, invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_ADD_ENTITY_ICON( int entity, const char* icon) { return invoke<int )
	{
		auto retval = GRAPHICS::ADD_ENTITY_ICON(entity, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_ENTITY_ICON_VISIBILITY( int entity, bool toggle) { invoke<void )
	{
		GRAPHICS::SET_ENTITY_ICON_VISIBILITY(entity, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_ENTITY_ICON_COLOR( int entity, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::SET_ENTITY_ICON_COLOR(entity, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_DRAW_ORIGIN( float x, float y, float z, bool p3) { invoke<void )
	{
		GRAPHICS::SET_DRAW_ORIGIN(x, y, z, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_DRAW_ORIGIN(  )
	{
		GRAPHICS::CLEAR_DRAW_ORIGIN();
	}

	int LUA_NATIVE_GRAPHICS_SET_BINK_MOVIE( const char* name) { return invoke<int )
	{
		auto retval = GRAPHICS::SET_BINK_MOVIE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_PLAY_BINK_MOVIE( int binkMovie) { invoke<void )
	{
		GRAPHICS::PLAY_BINK_MOVIE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_STOP_BINK_MOVIE( int binkMovie) { invoke<void )
	{
		GRAPHICS::STOP_BINK_MOVIE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_RELEASE_BINK_MOVIE( int binkMovie) { invoke<void )
	{
		GRAPHICS::RELEASE_BINK_MOVIE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_BINK_MOVIE( int binkMovie, float p1, float p2, float p3, float p4, float p5, int r, int g, int b, int a) { invoke<void )
	{
		GRAPHICS::DRAW_BINK_MOVIE(binkMovie, p1, p2, p3, p4, p5, r, g, b, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_BINK_MOVIE_TIME( int binkMovie, float progress) { invoke<void )
	{
		GRAPHICS::SET_BINK_MOVIE_TIME(binkMovie, invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_GET_BINK_MOVIE_TIME( int binkMovie) { return invoke<float )
	{
		auto retval = GRAPHICS::GET_BINK_MOVIE_TIME(invoke<float);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_BINK_MOVIE_VOLUME( int binkMovie, float value) { invoke<void )
	{
		GRAPHICS::SET_BINK_MOVIE_VOLUME(binkMovie, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ATTACH_TV_AUDIO_TO_ENTITY( int entity) { invoke<void )
	{
		GRAPHICS::ATTACH_TV_AUDIO_TO_ENTITY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_BINK_MOVIE_AUDIO_FRONTEND( int binkMovie, bool p1) { invoke<void )
	{
		GRAPHICS::SET_BINK_MOVIE_AUDIO_FRONTEND(binkMovie, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_AUDIO_FRONTEND( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_TV_AUDIO_FRONTEND(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_BINK_SHOULD_SKIP( int binkMovie, bool bShouldSkip) { invoke<void )
	{
		GRAPHICS::SET_BINK_SHOULD_SKIP(binkMovie, invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_LOAD_MOVIE_MESH_SET( const char* movieMeshSetName) { return invoke<int )
	{
		auto retval = GRAPHICS::LOAD_MOVIE_MESH_SET(invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_RELEASE_MOVIE_MESH_SET( int movieMeshSet) { invoke<void )
	{
		GRAPHICS::RELEASE_MOVIE_MESH_SET(invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_QUERY_MOVIE_MESH_SET_STATE( Any p0) { return invoke<int )
	{
		auto retval = GRAPHICS::QUERY_MOVIE_MESH_SET_STATE(invoke<int);
		return retval;
	}

	std::tuple<int, int y) {> LUA_NATIVE_GRAPHICS_GET_SCREEN_RESOLUTION( int x, int y) { invoke<void )
	{
		std::tuple<int, int y) {> return_values;
		GRAPHICS::GET_SCREEN_RESOLUTION(&x, &invoke<void);
		std::get<0>(return_values) = x;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int y) {> LUA_NATIVE_GRAPHICS_GET_ACTUAL_SCREEN_RESOLUTION( int x, int y) { invoke<void )
	{
		std::tuple<int, int y) {> return_values;
		GRAPHICS::GET_ACTUAL_SCREEN_RESOLUTION(&x, &invoke<void);
		std::get<0>(return_values) = x;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	float LUA_NATIVE_GRAPHICS_GET_ASPECT_RATIO( bool b) { return invoke<float )
	{
		auto retval = GRAPHICS::GET_ASPECT_RATIO(invoke<float);
		return retval;
	}

	float LUA_NATIVE_GRAPHICS_GET_SCREEN_ASPECT_RATIO(  )
	{
		auto retval = GRAPHICS::GET_SCREEN_ASPECT_RATIO();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_GET_IS_WIDESCREEN(  )
	{
		auto retval = (bool)GRAPHICS::GET_IS_WIDESCREEN();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_GET_IS_HIDEF(  )
	{
		auto retval = (bool)GRAPHICS::GET_IS_HIDEF();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_ADJUST_NEXT_POS_SIZE_AS_NORMALIZED_16_9(  )
	{
		GRAPHICS::ADJUST_NEXT_POS_SIZE_AS_NORMALIZED_16_9();
	}

	void LUA_NATIVE_GRAPHICS_SET_NIGHTVISION( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_NIGHTVISION(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_GET_REQUESTINGNIGHTVISION(  )
	{
		auto retval = (bool)GRAPHICS::GET_REQUESTINGNIGHTVISION();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_GET_USINGNIGHTVISION(  )
	{
		auto retval = (bool)GRAPHICS::GET_USINGNIGHTVISION();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_EXPOSURETWEAK( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_EXPOSURETWEAK(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FORCE_EXPOSURE_READBACK( bool toggle) { invoke<void )
	{
		GRAPHICS::FORCE_EXPOSURE_READBACK(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_OVERRIDE_NIGHTVISION_LIGHT_RANGE( float p0) { invoke<void )
	{
		GRAPHICS::OVERRIDE_NIGHTVISION_LIGHT_RANGE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_NOISEOVERIDE( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_NOISEOVERIDE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_NOISINESSOVERIDE( float value) { invoke<void )
	{
		GRAPHICS::SET_NOISINESSOVERIDE(invoke<void);
	}

	std::tuple<bool, float, float screenY) { return> LUA_NATIVE_GRAPHICS_GET_SCREEN_COORD_FROM_WORLD_COORD( float worldX, float worldY, float worldZ, float screenX, float screenY) { return invoke<BOOL )
	{
		std::tuple<bool, float, float screenY) { return> return_values;
		std::get<0>(return_values) = (bool)GRAPHICS::GET_SCREEN_COORD_FROM_WORLD_COORD(worldX, worldY, worldZ, &screenX, &invoke<BOOL);
		std::get<1>(return_values) = screenX;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	Vector3 LUA_NATIVE_GRAPHICS_GET_TEXTURE_RESOLUTION( const char* textureDict, const char* textureName) { return invoke<Vector3 )
	{
		auto retval = GRAPHICS::GET_TEXTURE_RESOLUTION(textureDict, invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_OVERRIDE_PED_CREW_LOGO_TEXTURE( int ped, const char* txd, const char* txn) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::OVERRIDE_PED_CREW_LOGO_TEXTURE(ped, txd, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_DISTANCE_BLUR_STRENGTH_OVERRIDE( float p0) { invoke<void )
	{
		GRAPHICS::SET_DISTANCE_BLUR_STRENGTH_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_FLASH( float p0, float p1, float fadeIn, float duration, float fadeOut) { invoke<void )
	{
		GRAPHICS::SET_FLASH(p0, p1, fadeIn, duration, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_OCCLUSION_THIS_FRAME(  )
	{
		GRAPHICS::DISABLE_OCCLUSION_THIS_FRAME();
	}

	void LUA_NATIVE_GRAPHICS_SET_ARTIFICIAL_LIGHTS_STATE( bool state) { invoke<void )
	{
		GRAPHICS::SET_ARTIFICIAL_LIGHTS_STATE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_ARTIFICIAL_VEHICLE_LIGHTS_STATE( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_ARTIFICIAL_VEHICLE_LIGHTS_STATE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_HDTEX_THIS_FRAME(  )
	{
		GRAPHICS::DISABLE_HDTEX_THIS_FRAME();
	}

	int LUA_NATIVE_GRAPHICS_CREATE_TRACKED_POINT(  )
	{
		auto retval = GRAPHICS::CREATE_TRACKED_POINT();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_TRACKED_POINT_INFO( int point, float x, float y, float z, float radius) { invoke<void )
	{
		GRAPHICS::SET_TRACKED_POINT_INFO(point, x, y, z, invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_IS_TRACKED_POINT_VISIBLE( int point) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_TRACKED_POINT_VISIBLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DESTROY_TRACKED_POINT( int point) { invoke<void )
	{
		GRAPHICS::DESTROY_TRACKED_POINT(invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_SET_GRASS_CULL_SPHERE( float p0, float p1, float p2, float p3) { return invoke<int )
	{
		auto retval = GRAPHICS::SET_GRASS_CULL_SPHERE(p0, p1, p2, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_GRASS_CULL_SPHERE( int handle) { invoke<void )
	{
		GRAPHICS::REMOVE_GRASS_CULL_SPHERE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_PROCGRASS_ENABLE_CULLSPHERE( int handle, float x, float y, float z, float scale) { invoke<void )
	{
		GRAPHICS::PROCGRASS_ENABLE_CULLSPHERE(handle, x, y, z, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_PROCGRASS_DISABLE_CULLSPHERE( int handle) { invoke<void )
	{
		GRAPHICS::PROCGRASS_DISABLE_CULLSPHERE(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_PROCGRASS_IS_CULLSPHERE_ENABLED( int handle) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::PROCGRASS_IS_CULLSPHERE_ENABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_PROCGRASS_ENABLE_AMBSCALESCAN(  )
	{
		GRAPHICS::PROCGRASS_ENABLE_AMBSCALESCAN();
	}

	void LUA_NATIVE_GRAPHICS_PROCGRASS_DISABLE_AMBSCALESCAN(  )
	{
		GRAPHICS::PROCGRASS_DISABLE_AMBSCALESCAN();
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_PROCOBJ_CREATION(  )
	{
		GRAPHICS::DISABLE_PROCOBJ_CREATION();
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_PROCOBJ_CREATION(  )
	{
		GRAPHICS::ENABLE_PROCOBJ_CREATION();
	}

	void LUA_NATIVE_GRAPHICS_GRASSBATCH_ENABLE_FLATTENING_EXT_IN_SPHERE( float x, float y, float z, Any p3, float p4, float p5, float p6, float scale) { invoke<void )
	{
		GRAPHICS::GRASSBATCH_ENABLE_FLATTENING_EXT_IN_SPHERE(x, y, z, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GRASSBATCH_ENABLE_FLATTENING_IN_SPHERE( float x, float y, float z, float radius, float p4, float p5, float p6) { invoke<void )
	{
		GRAPHICS::GRASSBATCH_ENABLE_FLATTENING_IN_SPHERE(x, y, z, radius, p4, p5, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GRASSBATCH_DISABLE_FLATTENING(  )
	{
		GRAPHICS::GRASSBATCH_DISABLE_FLATTENING();
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_INIT_SESSION(  )
	{
		GRAPHICS::CASCADE_SHADOWS_INIT_SESSION();
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_CASCADE_BOUNDS( Any p0, bool p1, float p2, float p3, float p4, float p5, bool p6, float p7) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_CASCADE_BOUNDS(p0, p1, p2, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_CASCADE_BOUNDS_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_CASCADE_BOUNDS_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_ENTITY_TRACKER_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_ENTITY_TRACKER_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_SPLIT_Z_EXP_WEIGHT( float p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_SPLIT_Z_EXP_WEIGHT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_BOUND_POSITION( Any p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_BOUND_POSITION(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_ENABLE_ENTITY_TRACKER( bool toggle) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_ENABLE_ENTITY_TRACKER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_SCREEN_SIZE_CHECK_ENABLED( bool p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_SCREEN_SIZE_CHECK_ENABLED(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_SHADOW_SAMPLE_TYPE( const char* type) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_SHADOW_SAMPLE_TYPE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_CLEAR_SHADOW_SAMPLE_TYPE(  )
	{
		GRAPHICS::CASCADE_SHADOWS_CLEAR_SHADOW_SAMPLE_TYPE();
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_AIRCRAFT_MODE( bool p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_AIRCRAFT_MODE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_DYNAMIC_DEPTH_MODE( bool p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_DYNAMIC_DEPTH_MODE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_SET_DYNAMIC_DEPTH_VALUE( float p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_SET_DYNAMIC_DEPTH_VALUE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CASCADE_SHADOWS_ENABLE_FREEZER( bool p0) { invoke<void )
	{
		GRAPHICS::CASCADE_SHADOWS_ENABLE_FREEZER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_WATER_REFLECTION_SET_SCRIPT_OBJECT_VISIBILITY( Any p0) { invoke<void )
	{
		GRAPHICS::WATER_REFLECTION_SET_SCRIPT_OBJECT_VISIBILITY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_ENABLED( bool toggle) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_ENABLED(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_PATH( float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, bool p8) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_PATH(p0, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_RADIUS( float p0, float p1, float p2) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_RADIUS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_COLOUR( int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_COLOUR(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_TESSELLATION( int p0, int p1) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_TESSELLATION(p0, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_FIXED_CONTROL_POINT_ENABLE( bool p0) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_FIXED_CONTROL_POINT_ENABLE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_FIXED_CONTROL_POINT( int type, float xPos, float yPos, float zPos, float p4, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_FIXED_CONTROL_POINT(type, xPos, yPos, zPos, p4, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_SHADER_PARAMS( float p0, float p1, float p2, float p3, float p4) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_SHADER_PARAMS(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_GOLF_TRAIL_SET_FACING( bool p0) { invoke<void )
	{
		GRAPHICS::GOLF_TRAIL_SET_FACING(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_GOLF_TRAIL_GET_MAX_HEIGHT(  )
	{
		auto retval = GRAPHICS::GOLF_TRAIL_GET_MAX_HEIGHT();
		return retval;
	}

	Vector3 LUA_NATIVE_GRAPHICS_GOLF_TRAIL_GET_VISUAL_CONTROL_POINT( int p0) { return invoke<Vector3 )
	{
		auto retval = GRAPHICS::GOLF_TRAIL_GET_VISUAL_CONTROL_POINT(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_SEETHROUGH( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_SEETHROUGH(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_GET_USINGSEETHROUGH(  )
	{
		auto retval = (bool)GRAPHICS::GET_USINGSEETHROUGH();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_RESET(  )
	{
		GRAPHICS::SEETHROUGH_RESET();
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_FADE_STARTDISTANCE( float distance) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_FADE_STARTDISTANCE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_FADE_ENDDISTANCE( float distance) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_FADE_ENDDISTANCE(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_SEETHROUGH_GET_MAX_THICKNESS(  )
	{
		auto retval = GRAPHICS::SEETHROUGH_GET_MAX_THICKNESS();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_MAX_THICKNESS( float thickness) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_MAX_THICKNESS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_NOISE_MIN( float amount) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_NOISE_MIN(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_NOISE_MAX( float amount) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_NOISE_MAX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_HILIGHT_INTENSITY( float intensity) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_HILIGHT_INTENSITY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_HIGHLIGHT_NOISE( float noise) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_HIGHLIGHT_NOISE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_HEATSCALE( int index, float heatScale) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_HEATSCALE(index, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SEETHROUGH_SET_COLOR_NEAR( int red, int green, int blue) { invoke<void )
	{
		GRAPHICS::SEETHROUGH_SET_COLOR_NEAR(red, green, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_MOTIONBLUR_MAX_VEL_SCALER( float p0) { invoke<void )
	{
		GRAPHICS::SET_MOTIONBLUR_MAX_VEL_SCALER(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_GET_MOTIONBLUR_MAX_VEL_SCALER(  )
	{
		auto retval = GRAPHICS::GET_MOTIONBLUR_MAX_VEL_SCALER();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_FORCE_MOTIONBLUR( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_FORCE_MOTIONBLUR(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_TOGGLE_PLAYER_DAMAGE_OVERLAY( bool toggle) { invoke<void )
	{
		GRAPHICS::TOGGLE_PLAYER_DAMAGE_OVERLAY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_RESET_ADAPTATION( int p0) { invoke<void )
	{
		GRAPHICS::RESET_ADAPTATION(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_TRIGGER_SCREENBLUR_FADE_IN( float transitionTime) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::TRIGGER_SCREENBLUR_FADE_IN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_TRIGGER_SCREENBLUR_FADE_OUT( float transitionTime) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::TRIGGER_SCREENBLUR_FADE_OUT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_SCREENBLUR_FADE(  )
	{
		GRAPHICS::DISABLE_SCREENBLUR_FADE();
	}

	float LUA_NATIVE_GRAPHICS_GET_SCREENBLUR_FADE_CURRENT_TIME(  )
	{
		auto retval = GRAPHICS::GET_SCREENBLUR_FADE_CURRENT_TIME();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_IS_SCREENBLUR_FADE_RUNNING(  )
	{
		auto retval = (bool)GRAPHICS::IS_SCREENBLUR_FADE_RUNNING();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_TOGGLE_PAUSED_RENDERPHASES( bool toggle) { invoke<void )
	{
		GRAPHICS::TOGGLE_PAUSED_RENDERPHASES(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_GET_TOGGLE_PAUSED_RENDERPHASES_STATUS(  )
	{
		auto retval = (bool)GRAPHICS::GET_TOGGLE_PAUSED_RENDERPHASES_STATUS();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_RESET_PAUSED_RENDERPHASES(  )
	{
		GRAPHICS::RESET_PAUSED_RENDERPHASES();
	}

	void LUA_NATIVE_GRAPHICS_GRAB_PAUSEMENU_OWNERSHIP(  )
	{
		GRAPHICS::GRAB_PAUSEMENU_OWNERSHIP();
	}

	void LUA_NATIVE_GRAPHICS_SET_HIDOF_OVERRIDE( bool p0, bool p1, float nearplaneOut, float nearplaneIn, float farplaneOut, float farplaneIn) { invoke<void )
	{
		GRAPHICS::SET_HIDOF_OVERRIDE(p0, p1, nearplaneOut, nearplaneIn, farplaneOut, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_LOCK_ADAPTIVE_DOF_DISTANCE( bool p0) { invoke<void )
	{
		GRAPHICS::SET_LOCK_ADAPTIVE_DOF_DISTANCE(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_PHONEPHOTOEDITOR_TOGGLE( bool p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::PHONEPHOTOEDITOR_TOGGLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_PHONEPHOTOEDITOR_IS_ACTIVE(  )
	{
		auto retval = (bool)GRAPHICS::PHONEPHOTOEDITOR_IS_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_PHONEPHOTOEDITOR_SET_FRAME_TXD( const char* textureDict, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::PHONEPHOTOEDITOR_SET_FRAME_TXD(textureDict, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_NON_LOOPED_AT_COORD( const char* effectName, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_PARTICLE_FX_NON_LOOPED_AT_COORD(effectName, xPos, yPos, zPos, xRot, yRot, zRot, scale, xAxis, yAxis, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD( const char* effectName, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, bool p11) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD(effectName, xPos, yPos, zPos, xRot, yRot, zRot, scale, xAxis, yAxis, zAxis, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE( const char* effectName, int ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE(effectName, ped, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, boneIndex, scale, axisX, axisY, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_NETWORKED_PARTICLE_FX_NON_LOOPED_ON_PED_BONE( const char* effectName, int ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_NETWORKED_PARTICLE_FX_NON_LOOPED_ON_PED_BONE(effectName, ped, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, boneIndex, scale, axisX, axisY, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_NON_LOOPED_ON_ENTITY( const char* effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale, bool axisX, bool axisY, bool axisZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_ENTITY(effectName, entity, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale, axisX, axisY, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_NETWORKED_PARTICLE_FX_NON_LOOPED_ON_ENTITY( const char* effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale, bool axisX, bool axisY, bool axisZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_NETWORKED_PARTICLE_FX_NON_LOOPED_ON_ENTITY(effectName, entity, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale, axisX, axisY, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_NON_LOOPED_ON_ENTITY_BONE( const char* effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_ENTITY_BONE(effectName, entity, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, boneIndex, scale, axisX, axisY, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_NON_LOOPED_COLOUR( float r, float g, float b) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_NON_LOOPED_COLOUR(r, g, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_NON_LOOPED_ALPHA( float alpha) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_NON_LOOPED_ALPHA(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_NON_LOOPED_SCALE( float scale) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_NON_LOOPED_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_NON_LOOPED_EMITTER_SIZE( float p0, float p1, float scale) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_NON_LOOPED_EMITTER_SIZE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_FORCE_VEHICLE_INTERIOR( bool toggle) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_FORCE_VEHICLE_INTERIOR(invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_LOOPED_AT_COORD( const char* effectName, float x, float y, float z, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, bool p11) { return invoke<int )
	{
		auto retval = GRAPHICS::START_PARTICLE_FX_LOOPED_AT_COORD(effectName, x, y, z, xRot, yRot, zRot, scale, xAxis, yAxis, zAxis, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_LOOPED_ON_PED_BONE( const char* effectName, int ped, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis) { return invoke<int )
	{
		auto retval = GRAPHICS::START_PARTICLE_FX_LOOPED_ON_PED_BONE(effectName, ped, xOffset, yOffset, zOffset, xRot, yRot, zRot, boneIndex, scale, xAxis, yAxis, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_LOOPED_ON_ENTITY( const char* effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis) { return invoke<int )
	{
		auto retval = GRAPHICS::START_PARTICLE_FX_LOOPED_ON_ENTITY(effectName, entity, xOffset, yOffset, zOffset, xRot, yRot, zRot, scale, xAxis, yAxis, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_START_PARTICLE_FX_LOOPED_ON_ENTITY_BONE( const char* effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis) { return invoke<int )
	{
		auto retval = GRAPHICS::START_PARTICLE_FX_LOOPED_ON_ENTITY_BONE(effectName, entity, xOffset, yOffset, zOffset, xRot, yRot, zRot, boneIndex, scale, xAxis, yAxis, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_START_NETWORKED_PARTICLE_FX_LOOPED_ON_ENTITY( const char* effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, float r, float g, float b, float a) { return invoke<int )
	{
		auto retval = GRAPHICS::START_NETWORKED_PARTICLE_FX_LOOPED_ON_ENTITY(effectName, entity, xOffset, yOffset, zOffset, xRot, yRot, zRot, scale, xAxis, yAxis, zAxis, r, g, b, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_START_NETWORKED_PARTICLE_FX_LOOPED_ON_ENTITY_BONE( const char* effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis, float r, float g, float b, float a) { return invoke<int )
	{
		auto retval = GRAPHICS::START_NETWORKED_PARTICLE_FX_LOOPED_ON_ENTITY_BONE(effectName, entity, xOffset, yOffset, zOffset, xRot, yRot, zRot, boneIndex, scale, xAxis, yAxis, zAxis, r, g, b, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_STOP_PARTICLE_FX_LOOPED( int ptfxHandle, bool p1) { invoke<void )
	{
		GRAPHICS::STOP_PARTICLE_FX_LOOPED(ptfxHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_PARTICLE_FX( int ptfxHandle, bool p1) { invoke<void )
	{
		GRAPHICS::REMOVE_PARTICLE_FX(ptfxHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_PARTICLE_FX_FROM_ENTITY( int entity) { invoke<void )
	{
		GRAPHICS::REMOVE_PARTICLE_FX_FROM_ENTITY(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_PARTICLE_FX_IN_RANGE( float X, float Y, float Z, float radius) { invoke<void )
	{
		GRAPHICS::REMOVE_PARTICLE_FX_IN_RANGE(X, Y, Z, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FORCE_PARTICLE_FX_IN_VEHICLE_INTERIOR( Any p0, Any p1) { invoke<void )
	{
		GRAPHICS::FORCE_PARTICLE_FX_IN_VEHICLE_INTERIOR(p0, invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_DOES_PARTICLE_FX_LOOPED_EXIST( int ptfxHandle) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::DOES_PARTICLE_FX_LOOPED_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_OFFSETS( int ptfxHandle, float x, float y, float z, float rotX, float rotY, float rotZ) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_OFFSETS(ptfxHandle, x, y, z, rotX, rotY, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_EVOLUTION( int ptfxHandle, const char* propertyName, float amount, bool noNetwork) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_EVOLUTION(ptfxHandle, propertyName, amount, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_COLOUR( int ptfxHandle, float r, float g, float b, bool p4) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_COLOUR(ptfxHandle, r, g, b, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_ALPHA( int ptfxHandle, float alpha) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_ALPHA(ptfxHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_SCALE( int ptfxHandle, float scale) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_SCALE(ptfxHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_LOOPED_FAR_CLIP_DIST( int ptfxHandle, float range) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_LOOPED_FAR_CLIP_DIST(ptfxHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_CAM_INSIDE_VEHICLE( bool p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_CAM_INSIDE_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_CAM_INSIDE_NONPLAYER_VEHICLE( int vehicle, bool p1) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_CAM_INSIDE_NONPLAYER_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_SHOOTOUT_BOAT( Any p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_SHOOTOUT_BOAT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_PARTICLE_FX_SHOOTOUT_BOAT(  )
	{
		GRAPHICS::CLEAR_PARTICLE_FX_SHOOTOUT_BOAT();
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_BLOOD_SCALE( Any p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_BLOOD_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_IN_WATER_PTFX( bool toggle) { invoke<void )
	{
		GRAPHICS::DISABLE_IN_WATER_PTFX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_DOWNWASH_PTFX( bool toggle) { invoke<void )
	{
		GRAPHICS::DISABLE_DOWNWASH_PTFX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_SLIPSTREAM_LODRANGE_SCALE( float scale) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_SLIPSTREAM_LODRANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_CLOWN_BLOOD_VFX( bool toggle) { invoke<void )
	{
		GRAPHICS::ENABLE_CLOWN_BLOOD_VFX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_ALIEN_BLOOD_VFX( bool toggle) { invoke<void )
	{
		GRAPHICS::ENABLE_ALIEN_BLOOD_VFX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_BULLET_IMPACT_SCALE( float scale) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_BULLET_IMPACT_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_BULLET_IMPACT_LODRANGE_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_BULLET_IMPACT_LODRANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_BULLET_TRACE_NO_ANGLE_REJECT( bool p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_BULLET_TRACE_NO_ANGLE_REJECT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_BANG_SCRAPE_LODRANGE_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_BANG_SCRAPE_LODRANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_FOOT_LODRANGE_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_FOOT_LODRANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_FOOT_OVERRIDE_NAME( const char* p0) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_FOOT_OVERRIDE_NAME(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SKIDMARK_RANGE_SCALE( float scale) { invoke<void )
	{
		GRAPHICS::SET_SKIDMARK_RANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PTFX_FORCE_VEHICLE_INTERIOR_FLAG( Any p0) { invoke<void )
	{
		GRAPHICS::SET_PTFX_FORCE_VEHICLE_INTERIOR_FLAG(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REGISTER_POSTFX_BULLET_IMPACT( float weaponWorldPosX, float weaponWorldPosY, float weaponWorldPosZ, float intensity) { invoke<void )
	{
		GRAPHICS::REGISTER_POSTFX_BULLET_IMPACT(weaponWorldPosX, weaponWorldPosY, weaponWorldPosZ, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FORCE_POSTFX_BULLET_IMPACTS_AFTER_HUD( bool p0) { invoke<void )
	{
		GRAPHICS::FORCE_POSTFX_BULLET_IMPACTS_AFTER_HUD(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_USE_PARTICLE_FX_ASSET( const char* name) { invoke<void )
	{
		GRAPHICS::USE_PARTICLE_FX_ASSET(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PARTICLE_FX_OVERRIDE( const char* oldAsset, const char* newAsset) { invoke<void )
	{
		GRAPHICS::SET_PARTICLE_FX_OVERRIDE(oldAsset, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_RESET_PARTICLE_FX_OVERRIDE( const char* name) { invoke<void )
	{
		GRAPHICS::RESET_PARTICLE_FX_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_WEATHER_PTFX_USE_OVERRIDE_SETTINGS( bool p0) { invoke<void )
	{
		GRAPHICS::SET_WEATHER_PTFX_USE_OVERRIDE_SETTINGS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_WEATHER_PTFX_OVERRIDE_CURR_LEVEL( float p0) { invoke<void )
	{
		GRAPHICS::SET_WEATHER_PTFX_OVERRIDE_CURR_LEVEL(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_WASH_DECALS_IN_RANGE( float x, float y, float z, float range, float p4) { invoke<void )
	{
		GRAPHICS::WASH_DECALS_IN_RANGE(x, y, z, range, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_WASH_DECALS_FROM_VEHICLE( int vehicle, float p1) { invoke<void )
	{
		GRAPHICS::WASH_DECALS_FROM_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_FADE_DECALS_IN_RANGE( float x, float y, float z, float p3, float p4) { invoke<void )
	{
		GRAPHICS::FADE_DECALS_IN_RANGE(x, y, z, p3, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_DECALS_IN_RANGE( float x, float y, float z, float range) { invoke<void )
	{
		GRAPHICS::REMOVE_DECALS_IN_RANGE(x, y, z, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_DECALS_FROM_OBJECT( Object obj) { invoke<void )
	{
		GRAPHICS::REMOVE_DECALS_FROM_OBJECT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_DECALS_FROM_OBJECT_FACING( Object obj, float x, float y, float z) { invoke<void )
	{
		GRAPHICS::REMOVE_DECALS_FROM_OBJECT_FACING(obj, x, y, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_DECALS_FROM_VEHICLE( int vehicle) { invoke<void )
	{
		GRAPHICS::REMOVE_DECALS_FROM_VEHICLE(invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_ADD_DECAL( int decalType, float posX, float posY, float posZ, float p4, float p5, float p6, float p7, float p8, float p9, float width, float height, float rCoef, float gCoef, float bCoef, float opacity, float timeout, bool p17, bool p18, bool p19) { return invoke<int )
	{
		auto retval = GRAPHICS::ADD_DECAL(decalType, posX, posY, posZ, p4, p5, p6, p7, p8, p9, width, height, rCoef, gCoef, bCoef, opacity, timeout, p17, p18, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_ADD_PETROL_DECAL( float x, float y, float z, float groundLvl, float width, float transparency) { return invoke<int )
	{
		auto retval = GRAPHICS::ADD_PETROL_DECAL(x, y, z, groundLvl, width, invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_ADD_OIL_DECAL( float x, float y, float z, float groundLvl, float width, float transparency) { return invoke<int )
	{
		auto retval = GRAPHICS::ADD_OIL_DECAL(x, y, z, groundLvl, width, invoke<int);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_START_PETROL_TRAIL_DECALS( float p0) { invoke<void )
	{
		GRAPHICS::START_PETROL_TRAIL_DECALS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ADD_PETROL_TRAIL_DECAL_INFO( float x, float y, float z, float p3) { invoke<void )
	{
		GRAPHICS::ADD_PETROL_TRAIL_DECAL_INFO(x, y, z, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_END_PETROL_TRAIL_DECALS(  )
	{
		GRAPHICS::END_PETROL_TRAIL_DECALS();
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_DECAL( int decal) { invoke<void )
	{
		GRAPHICS::REMOVE_DECAL(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_IS_DECAL_ALIVE( int decal) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_DECAL_ALIVE(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_GRAPHICS_GET_DECAL_WASH_LEVEL( int decal) { return invoke<float )
	{
		auto retval = GRAPHICS::GET_DECAL_WASH_LEVEL(invoke<float);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_DISABLE_PETROL_DECALS_IGNITING_THIS_FRAME(  )
	{
		GRAPHICS::SET_DISABLE_PETROL_DECALS_IGNITING_THIS_FRAME();
	}

	void LUA_NATIVE_GRAPHICS_SET_DISABLE_PETROL_DECALS_RECYCLING_THIS_FRAME(  )
	{
		GRAPHICS::SET_DISABLE_PETROL_DECALS_RECYCLING_THIS_FRAME();
	}

	void LUA_NATIVE_GRAPHICS_SET_DISABLE_DECAL_RENDERING_THIS_FRAME(  )
	{
		GRAPHICS::SET_DISABLE_DECAL_RENDERING_THIS_FRAME();
	}

	bool LUA_NATIVE_GRAPHICS_GET_IS_PETROL_DECAL_IN_RANGE( float xCoord, float yCoord, float zCoord, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::GET_IS_PETROL_DECAL_IN_RANGE(xCoord, yCoord, zCoord, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_PATCH_DECAL_DIFFUSE_MAP( int decalType, const char* textureDict, const char* textureName) { invoke<void )
	{
		GRAPHICS::PATCH_DECAL_DIFFUSE_MAP(decalType, textureDict, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_UNPATCH_DECAL_DIFFUSE_MAP( int decalType) { invoke<void )
	{
		GRAPHICS::UNPATCH_DECAL_DIFFUSE_MAP(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_MOVE_VEHICLE_DECALS( Any p0, Any p1) { invoke<void )
	{
		GRAPHICS::MOVE_VEHICLE_DECALS(p0, invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_ADD_VEHICLE_CREW_EMBLEM( int vehicle, int ped, int boneIndex, float x1, float x2, float x3, float y1, float y2, float y3, float z1, float z2, float z3, float scale, Any p13, int alpha) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::ADD_VEHICLE_CREW_EMBLEM(vehicle, ped, boneIndex, x1, x2, x3, y1, y2, y3, z1, z2, z3, scale, p13, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_GRAPHICS_ABORT_VEHICLE_CREW_EMBLEM_REQUEST( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)GRAPHICS::ABORT_VEHICLE_CREW_EMBLEM_REQUEST(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_VEHICLE_CREW_EMBLEM( int vehicle, int p1) { invoke<void )
	{
		GRAPHICS::REMOVE_VEHICLE_CREW_EMBLEM(vehicle, invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_GET_VEHICLE_CREW_EMBLEM_REQUEST_STATE( int vehicle, int p1) { return invoke<int )
	{
		auto retval = GRAPHICS::GET_VEHICLE_CREW_EMBLEM_REQUEST_STATE(vehicle, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_DOES_VEHICLE_HAVE_CREW_EMBLEM( int vehicle, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::DOES_VEHICLE_HAVE_CREW_EMBLEM(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_COMPOSITE_SHOTGUN_DECALS( bool toggle) { invoke<void )
	{
		GRAPHICS::DISABLE_COMPOSITE_SHOTGUN_DECALS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_SCUFF_DECALS( bool toggle) { invoke<void )
	{
		GRAPHICS::DISABLE_SCUFF_DECALS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_DECAL_BULLET_IMPACT_RANGE_SCALE( float p0) { invoke<void )
	{
		GRAPHICS::SET_DECAL_BULLET_IMPACT_RANGE_SCALE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_OVERRIDE_INTERIOR_SMOKE_NAME( const char* name) { invoke<void )
	{
		GRAPHICS::OVERRIDE_INTERIOR_SMOKE_NAME(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_OVERRIDE_INTERIOR_SMOKE_LEVEL( float level) { invoke<void )
	{
		GRAPHICS::OVERRIDE_INTERIOR_SMOKE_LEVEL(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_OVERRIDE_INTERIOR_SMOKE_END(  )
	{
		GRAPHICS::OVERRIDE_INTERIOR_SMOKE_END();
	}

	void LUA_NATIVE_GRAPHICS_REGISTER_NOIR_LENS_EFFECT(  )
	{
		GRAPHICS::REGISTER_NOIR_LENS_EFFECT();
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_VEHICLE_DISTANTLIGHTS( bool toggle) { invoke<void )
	{
		GRAPHICS::DISABLE_VEHICLE_DISTANTLIGHTS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_RENDER_SHADOWED_LIGHTS_WITH_NO_SHADOWS( bool p0) { invoke<void )
	{
		GRAPHICS::RENDER_SHADOWED_LIGHTS_WITH_NO_SHADOWS(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REQUEST_EARLY_LIGHT_CHECK(  )
	{
		GRAPHICS::REQUEST_EARLY_LIGHT_CHECK();
	}

	void LUA_NATIVE_GRAPHICS_USE_SNOW_FOOT_VFX_WHEN_UNSHELTERED( bool toggle) { invoke<void )
	{
		GRAPHICS::USE_SNOW_FOOT_VFX_WHEN_UNSHELTERED(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_USE_SNOW_WHEEL_VFX_WHEN_UNSHELTERED( bool toggle) { invoke<void )
	{
		GRAPHICS::USE_SNOW_WHEEL_VFX_WHEN_UNSHELTERED(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_REGION_VFX( Any p0) { invoke<void )
	{
		GRAPHICS::DISABLE_REGION_VFX(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_PRESET_INTERIOR_AMBIENT_CACHE( const char* timecycleModifierName) { invoke<void )
	{
		GRAPHICS::PRESET_INTERIOR_AMBIENT_CACHE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TIMECYCLE_MODIFIER( const char* modifierName) { invoke<void )
	{
		GRAPHICS::SET_TIMECYCLE_MODIFIER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TIMECYCLE_MODIFIER_STRENGTH( float strength) { invoke<void )
	{
		GRAPHICS::SET_TIMECYCLE_MODIFIER_STRENGTH(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TRANSITION_TIMECYCLE_MODIFIER( const char* modifierName, float transition) { invoke<void )
	{
		GRAPHICS::SET_TRANSITION_TIMECYCLE_MODIFIER(modifierName, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TRANSITION_OUT_OF_TIMECYCLE_MODIFIER( float strength) { invoke<void )
	{
		GRAPHICS::SET_TRANSITION_OUT_OF_TIMECYCLE_MODIFIER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_TIMECYCLE_MODIFIER(  )
	{
		GRAPHICS::CLEAR_TIMECYCLE_MODIFIER();
	}

	int LUA_NATIVE_GRAPHICS_GET_TIMECYCLE_MODIFIER_INDEX(  )
	{
		auto retval = GRAPHICS::GET_TIMECYCLE_MODIFIER_INDEX();
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_TIMECYCLE_TRANSITION_MODIFIER_INDEX(  )
	{
		auto retval = GRAPHICS::GET_TIMECYCLE_TRANSITION_MODIFIER_INDEX();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_GET_IS_TIMECYCLE_TRANSITIONING_OUT(  )
	{
		auto retval = (bool)GRAPHICS::GET_IS_TIMECYCLE_TRANSITIONING_OUT();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_PUSH_TIMECYCLE_MODIFIER(  )
	{
		GRAPHICS::PUSH_TIMECYCLE_MODIFIER();
	}

	void LUA_NATIVE_GRAPHICS_POP_TIMECYCLE_MODIFIER(  )
	{
		GRAPHICS::POP_TIMECYCLE_MODIFIER();
	}

	void LUA_NATIVE_GRAPHICS_SET_CURRENT_PLAYER_TCMODIFIER( const char* modifierName) { invoke<void )
	{
		GRAPHICS::SET_CURRENT_PLAYER_TCMODIFIER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_PLAYER_TCMODIFIER_TRANSITION( float value) { invoke<void )
	{
		GRAPHICS::SET_PLAYER_TCMODIFIER_TRANSITION(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_NEXT_PLAYER_TCMODIFIER( const char* modifierName) { invoke<void )
	{
		GRAPHICS::SET_NEXT_PLAYER_TCMODIFIER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ADD_TCMODIFIER_OVERRIDE( const char* modifierName1, const char* modifierName2) { invoke<void )
	{
		GRAPHICS::ADD_TCMODIFIER_OVERRIDE(modifierName1, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_ALL_TCMODIFIER_OVERRIDES( const char* p0) { invoke<void )
	{
		GRAPHICS::CLEAR_ALL_TCMODIFIER_OVERRIDES(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_EXTRA_TCMODIFIER( const char* modifierName) { invoke<void )
	{
		GRAPHICS::SET_EXTRA_TCMODIFIER(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_EXTRA_TCMODIFIER(  )
	{
		GRAPHICS::CLEAR_EXTRA_TCMODIFIER();
	}

	int LUA_NATIVE_GRAPHICS_GET_EXTRA_TCMODIFIER(  )
	{
		auto retval = GRAPHICS::GET_EXTRA_TCMODIFIER();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_MOON_CYCLE_OVERRIDE( float strength) { invoke<void )
	{
		GRAPHICS::ENABLE_MOON_CYCLE_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DISABLE_MOON_CYCLE_OVERRIDE(  )
	{
		GRAPHICS::DISABLE_MOON_CYCLE_OVERRIDE();
	}

	int LUA_NATIVE_GRAPHICS_REQUEST_SCALEFORM_MOVIE( const char* scaleformName) { return invoke<int )
	{
		auto retval = GRAPHICS::REQUEST_SCALEFORM_MOVIE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_REQUEST_SCALEFORM_MOVIE_WITH_IGNORE_SUPER_WIDESCREEN( const char* scaleformName) { return invoke<int )
	{
		auto retval = GRAPHICS::REQUEST_SCALEFORM_MOVIE_WITH_IGNORE_SUPER_WIDESCREEN(invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_REQUEST_SCALEFORM_MOVIE_INSTANCE( const char* scaleformName) { return invoke<int )
	{
		auto retval = GRAPHICS::REQUEST_SCALEFORM_MOVIE_INSTANCE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_REQUEST_SCALEFORM_MOVIE_SKIP_RENDER_WHILE_PAUSED( const char* scaleformName) { return invoke<int )
	{
		auto retval = GRAPHICS::REQUEST_SCALEFORM_MOVIE_SKIP_RENDER_WHILE_PAUSED(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_HAS_SCALEFORM_MOVIE_LOADED( int scaleformHandle) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::HAS_SCALEFORM_MOVIE_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_IS_ACTIVE_SCALEFORM_MOVIE_DELETING( int val) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_ACTIVE_SCALEFORM_MOVIE_DELETING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_IS_SCALEFORM_MOVIE_DELETING( int val) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_SCALEFORM_MOVIE_DELETING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_HAS_SCALEFORM_MOVIE_FILENAME_LOADED( const char* scaleformName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::HAS_SCALEFORM_MOVIE_FILENAME_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_HAS_SCALEFORM_CONTAINER_MOVIE_LOADED_INTO_PARENT( int scaleformHandle) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::HAS_SCALEFORM_CONTAINER_MOVIE_LOADED_INTO_PARENT(invoke<BOOL);
		return retval;
	}

	int scaleformHandle) { LUA_NATIVE_GRAPHICS_SET_SCALEFORM_MOVIE_AS_NO_LONGER_NEEDED( int scaleformHandle) { invoke<void )
	{
		GRAPHICS::SET_SCALEFORM_MOVIE_AS_NO_LONGER_NEEDED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_GRAPHICS_SET_SCALEFORM_MOVIE_TO_USE_SYSTEM_TIME( int scaleform, bool toggle) { invoke<void )
	{
		GRAPHICS::SET_SCALEFORM_MOVIE_TO_USE_SYSTEM_TIME(scaleform, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SCALEFORM_MOVIE_TO_USE_LARGE_RT( int scaleformHandle, bool toggle) { invoke<void )
	{
		GRAPHICS::SET_SCALEFORM_MOVIE_TO_USE_LARGE_RT(scaleformHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_SCALEFORM_MOVIE_TO_USE_SUPER_LARGE_RT( int scaleformHandle, bool toggle) { invoke<void )
	{
		GRAPHICS::SET_SCALEFORM_MOVIE_TO_USE_SUPER_LARGE_RT(scaleformHandle, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SCALEFORM_MOVIE( int scaleformHandle, float x, float y, float width, float height, int red, int green, int blue, int alpha, int p9) { invoke<void )
	{
		GRAPHICS::DRAW_SCALEFORM_MOVIE(scaleformHandle, x, y, width, height, red, green, blue, alpha, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SCALEFORM_MOVIE_FULLSCREEN( int scaleform, int red, int green, int blue, int alpha, int p5) { invoke<void )
	{
		GRAPHICS::DRAW_SCALEFORM_MOVIE_FULLSCREEN(scaleform, red, green, blue, alpha, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SCALEFORM_MOVIE_FULLSCREEN_MASKED( int scaleform1, int scaleform2, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_SCALEFORM_MOVIE_FULLSCREEN_MASKED(scaleform1, scaleform2, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SCALEFORM_MOVIE_3D( int scaleform, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float p7, float p8, float p9, float scaleX, float scaleY, float scaleZ, int rotationOrder) { invoke<void )
	{
		GRAPHICS::DRAW_SCALEFORM_MOVIE_3D(scaleform, posX, posY, posZ, rotX, rotY, rotZ, p7, p8, p9, scaleX, scaleY, scaleZ, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_DRAW_SCALEFORM_MOVIE_3D_SOLID( int scaleform, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float p7, float p8, float p9, float scaleX, float scaleY, float scaleZ, int rotationOrder) { invoke<void )
	{
		GRAPHICS::DRAW_SCALEFORM_MOVIE_3D_SOLID(scaleform, posX, posY, posZ, rotX, rotY, rotZ, p7, p8, p9, scaleX, scaleY, scaleZ, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CALL_SCALEFORM_MOVIE_METHOD( int scaleform, const char* method) { invoke<void )
	{
		GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD(scaleform, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER( int scaleform, const char* methodName, float param1, float param2, float param3, float param4, float param5) { invoke<void )
	{
		GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER(scaleform, methodName, param1, param2, param3, param4, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CALL_SCALEFORM_MOVIE_METHOD_WITH_STRING( int scaleform, const char* methodName, const char* param1, const char* param2, const char* param3, const char* param4, const char* param5) { invoke<void )
	{
		GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD_WITH_STRING(scaleform, methodName, param1, param2, param3, param4, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER_AND_STRING( int scaleform, const char* methodName, float floatParam1, float floatParam2, float floatParam3, float floatParam4, float floatParam5, const char* stringParam1, const char* stringParam2, const char* stringParam3, const char* stringParam4, const char* stringParam5) { invoke<void )
	{
		GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER_AND_STRING(scaleform, methodName, floatParam1, floatParam2, floatParam3, floatParam4, floatParam5, stringParam1, stringParam2, stringParam3, stringParam4, invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_SCALEFORM_SCRIPT_HUD_MOVIE_METHOD( int hudComponent, const char* methodName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::BEGIN_SCALEFORM_SCRIPT_HUD_MOVIE_METHOD(hudComponent, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_SCALEFORM_MOVIE_METHOD( int scaleform, const char* methodName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::BEGIN_SCALEFORM_MOVIE_METHOD(scaleform, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND( const char* methodName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND_HEADER( const char* methodName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND_HEADER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_END_SCALEFORM_MOVIE_METHOD(  )
	{
		GRAPHICS::END_SCALEFORM_MOVIE_METHOD();
	}

	int LUA_NATIVE_GRAPHICS_END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE(  )
	{
		auto retval = GRAPHICS::END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_IS_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_READY( int methodReturn) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_READY(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_GRAPHICS_GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT( int methodReturn) { return invoke<int )
	{
		auto retval = GRAPHICS::GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_BOOL( int methodReturn) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_BOOL(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_GRAPHICS_GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING( int methodReturn) { return invoke<const char* )
	{
		auto retval = GRAPHICS::GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING(char*);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT( int value) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_FLOAT( float value) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_FLOAT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_BOOL( bool value) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_BOOL(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_BEGIN_TEXT_COMMAND_SCALEFORM_STRING( const char* componentType) { invoke<void )
	{
		GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_END_TEXT_COMMAND_SCALEFORM_STRING(  )
	{
		GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
	}

	void LUA_NATIVE_GRAPHICS_END_TEXT_COMMAND_UNPARSED_SCALEFORM_STRING(  )
	{
		GRAPHICS::END_TEXT_COMMAND_UNPARSED_SCALEFORM_STRING();
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_LITERAL_STRING( const char* string) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_LITERAL_STRING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING( const char* string) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_PLAYER_NAME_STRING( const char* string) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_PLAYER_NAME_STRING(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_DOES_LATEST_BRIEF_STRING_EXIST( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::DOES_LATEST_BRIEF_STRING_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SCALEFORM_MOVIE_METHOD_ADD_PARAM_LATEST_BRIEF_STRING( int value) { invoke<void )
	{
		GRAPHICS::SCALEFORM_MOVIE_METHOD_ADD_PARAM_LATEST_BRIEF_STRING(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_REQUEST_SCALEFORM_SCRIPT_HUD_MOVIE( int hudComponent) { invoke<void )
	{
		GRAPHICS::REQUEST_SCALEFORM_SCRIPT_HUD_MOVIE(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_HAS_SCALEFORM_SCRIPT_HUD_MOVIE_LOADED( int hudComponent) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::HAS_SCALEFORM_SCRIPT_HUD_MOVIE_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_REMOVE_SCALEFORM_SCRIPT_HUD_MOVIE( int hudComponent) { invoke<void )
	{
		GRAPHICS::REMOVE_SCALEFORM_SCRIPT_HUD_MOVIE(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_PASS_KEYBOARD_INPUT_TO_SCALEFORM( int scaleformHandle) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::PASS_KEYBOARD_INPUT_TO_SCALEFORM(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_CHANNEL( int channel) { invoke<void )
	{
		GRAPHICS::SET_TV_CHANNEL(invoke<void);
	}

	int LUA_NATIVE_GRAPHICS_GET_TV_CHANNEL(  )
	{
		auto retval = GRAPHICS::GET_TV_CHANNEL();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_VOLUME( float volume) { invoke<void )
	{
		GRAPHICS::SET_TV_VOLUME(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_GET_TV_VOLUME(  )
	{
		auto retval = GRAPHICS::GET_TV_VOLUME();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_DRAW_TV_CHANNEL( float xPos, float yPos, float xScale, float yScale, float rotation, int red, int green, int blue, int alpha) { invoke<void )
	{
		GRAPHICS::DRAW_TV_CHANNEL(xPos, yPos, xScale, yScale, rotation, red, green, blue, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_CHANNEL_PLAYLIST( int tvChannel, const char* playlistName, bool restart) { invoke<void )
	{
		GRAPHICS::SET_TV_CHANNEL_PLAYLIST(tvChannel, playlistName, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_CHANNEL_PLAYLIST_AT_HOUR( int tvChannel, const char* playlistName, int hour) { invoke<void )
	{
		GRAPHICS::SET_TV_CHANNEL_PLAYLIST_AT_HOUR(tvChannel, playlistName, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_CLEAR_TV_CHANNEL_PLAYLIST( int tvChannel) { invoke<void )
	{
		GRAPHICS::CLEAR_TV_CHANNEL_PLAYLIST(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_IS_PLAYLIST_ON_CHANNEL( int tvChannel, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_PLAYLIST_ON_CHANNEL(tvChannel, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_IS_TVSHOW_CURRENTLY_PLAYING( unsigned videoCliphash) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::IS_TVSHOW_CURRENTLY_PLAYING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_MOVIE_KEYFRAME_WAIT( bool toggle) { invoke<void )
	{
		GRAPHICS::ENABLE_MOVIE_KEYFRAME_WAIT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_SET_TV_PLAYER_WATCHING_THIS_FRAME( Any p0) { invoke<void )
	{
		GRAPHICS::SET_TV_PLAYER_WATCHING_THIS_FRAME(invoke<void);
	}

	unsigned LUA_NATIVE_GRAPHICS_GET_CURRENT_TV_CLIP_NAMEHASH(  )
	{
		auto retval = GRAPHICS::GET_CURRENT_TV_CLIP_NAMEHASH();
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_ENABLE_MOVIE_SUBTITLES( bool toggle) { invoke<void )
	{
		GRAPHICS::ENABLE_MOVIE_SUBTITLES(invoke<void);
	}

	bool LUA_NATIVE_GRAPHICS_UI3DSCENE_IS_AVAILABLE(  )
	{
		auto retval = (bool)GRAPHICS::UI3DSCENE_IS_AVAILABLE();
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_UI3DSCENE_PUSH_PRESET( const char* presetName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::UI3DSCENE_PUSH_PRESET(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_UI3DSCENE_ASSIGN_PED_TO_SLOT( const char* presetName, int ped, int slot, float posX, float posY, float posZ) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::UI3DSCENE_ASSIGN_PED_TO_SLOT(presetName, ped, slot, posX, posY, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_UI3DSCENE_CLEAR_PATCHED_DATA(  )
	{
		GRAPHICS::UI3DSCENE_CLEAR_PATCHED_DATA();
	}

	void LUA_NATIVE_GRAPHICS_UI3DSCENE_MAKE_PUSHED_PRESET_PERSISTENT( bool toggle) { invoke<void )
	{
		GRAPHICS::UI3DSCENE_MAKE_PUSHED_PRESET_PERSISTENT(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_TERRAINGRID_ACTIVATE( bool toggle) { invoke<void )
	{
		GRAPHICS::TERRAINGRID_ACTIVATE(invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_TERRAINGRID_SET_PARAMS( float x, float y, float z, float forwardX, float forwardY, float forwardZ, float sizeX, float sizeY, float sizeZ, float gridScale, float glowIntensity, float normalHeight, float heightDiff) { invoke<void )
	{
		GRAPHICS::TERRAINGRID_SET_PARAMS(x, y, z, forwardX, forwardY, forwardZ, sizeX, sizeY, sizeZ, gridScale, glowIntensity, normalHeight, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_TERRAINGRID_SET_COLOURS( int lowR, int lowG, int lowB, int lowAlpha, int r, int g, int b, int alpha, int highR, int highG, int highB, int highAlpha) { invoke<void )
	{
		GRAPHICS::TERRAINGRID_SET_COLOURS(lowR, lowG, lowB, lowAlpha, r, g, b, alpha, highR, highG, highB, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ANIMPOSTFX_PLAY( const char* effectName, int duration, bool looped) { invoke<void )
	{
		GRAPHICS::ANIMPOSTFX_PLAY(effectName, duration, invoke<void);
	}

	void LUA_NATIVE_GRAPHICS_ANIMPOSTFX_STOP( const char* effectName) { invoke<void )
	{
		GRAPHICS::ANIMPOSTFX_STOP(invoke<void);
	}

	float LUA_NATIVE_GRAPHICS_ANIMPOSTFX_GET_CURRENT_TIME( const char* effectName) { return invoke<float )
	{
		auto retval = GRAPHICS::ANIMPOSTFX_GET_CURRENT_TIME(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_GRAPHICS_ANIMPOSTFX_IS_RUNNING( const char* effectName) { return invoke<BOOL )
	{
		auto retval = (bool)GRAPHICS::ANIMPOSTFX_IS_RUNNING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_GRAPHICS_ANIMPOSTFX_STOP_ALL(  )
	{
		GRAPHICS::ANIMPOSTFX_STOP_ALL();
	}

	void LUA_NATIVE_GRAPHICS_ANIMPOSTFX_STOP_AND_FLUSH_REQUESTS( const char* effectName) { invoke<void )
	{
		GRAPHICS::ANIMPOSTFX_STOP_AND_FLUSH_REQUESTS(invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_BUSYSPINNER_ON( const char* string) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_BUSYSPINNER_ON(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_BUSYSPINNER_ON( int busySpinnerType) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_BUSYSPINNER_ON(invoke<void);
	}

	void LUA_NATIVE_HUD_BUSYSPINNER_OFF(  )
	{
		HUD::BUSYSPINNER_OFF();
	}

	void LUA_NATIVE_HUD_PRELOAD_BUSYSPINNER(  )
	{
		HUD::PRELOAD_BUSYSPINNER();
	}

	bool LUA_NATIVE_HUD_BUSYSPINNER_IS_ON(  )
	{
		auto retval = (bool)HUD::BUSYSPINNER_IS_ON();
		return retval;
	}

	bool LUA_NATIVE_HUD_BUSYSPINNER_IS_DISPLAYING(  )
	{
		auto retval = (bool)HUD::BUSYSPINNER_IS_DISPLAYING();
		return retval;
	}

	void LUA_NATIVE_HUD_DISABLE_PAUSEMENU_SPINNER( bool p0) { invoke<void )
	{
		HUD::DISABLE_PAUSEMENU_SPINNER(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MOUSE_CURSOR_THIS_FRAME(  )
	{
		HUD::SET_MOUSE_CURSOR_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_MOUSE_CURSOR_STYLE( int spriteId) { invoke<void )
	{
		HUD::SET_MOUSE_CURSOR_STYLE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MOUSE_CURSOR_VISIBLE( bool toggle) { invoke<void )
	{
		HUD::SET_MOUSE_CURSOR_VISIBLE(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_MOUSE_ROLLED_OVER_INSTRUCTIONAL_BUTTONS(  )
	{
		auto retval = (bool)HUD::IS_MOUSE_ROLLED_OVER_INSTRUCTIONAL_BUTTONS();
		return retval;
	}

	std::tuple<bool, Any, Any, Any p3) { return> LUA_NATIVE_HUD_GET_MOUSE_EVENT( int scaleformHandle, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_MOUSE_EVENT(scaleformHandle, &p1, &p2, &invoke<BOOL);
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = p2;
		std::get<3>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_HUD_THEFEED_ONLY_SHOW_TOOLTIPS( bool toggle) { invoke<void )
	{
		HUD::THEFEED_ONLY_SHOW_TOOLTIPS(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_SET_SCRIPTED_MENU_HEIGHT( float pos) { invoke<void )
	{
		HUD::THEFEED_SET_SCRIPTED_MENU_HEIGHT(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_HIDE(  )
	{
		HUD::THEFEED_HIDE();
	}

	void LUA_NATIVE_HUD_THEFEED_HIDE_THIS_FRAME(  )
	{
		HUD::THEFEED_HIDE_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_THEFEED_SHOW(  )
	{
		HUD::THEFEED_SHOW();
	}

	void LUA_NATIVE_HUD_THEFEED_FLUSH_QUEUE(  )
	{
		HUD::THEFEED_FLUSH_QUEUE();
	}

	void LUA_NATIVE_HUD_THEFEED_REMOVE_ITEM( int notificationId) { invoke<void )
	{
		HUD::THEFEED_REMOVE_ITEM(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_FORCE_RENDER_ON(  )
	{
		HUD::THEFEED_FORCE_RENDER_ON();
	}

	void LUA_NATIVE_HUD_THEFEED_FORCE_RENDER_OFF(  )
	{
		HUD::THEFEED_FORCE_RENDER_OFF();
	}

	void LUA_NATIVE_HUD_THEFEED_PAUSE(  )
	{
		HUD::THEFEED_PAUSE();
	}

	void LUA_NATIVE_HUD_THEFEED_RESUME(  )
	{
		HUD::THEFEED_RESUME();
	}

	bool LUA_NATIVE_HUD_THEFEED_IS_PAUSED(  )
	{
		auto retval = (bool)HUD::THEFEED_IS_PAUSED();
		return retval;
	}

	void LUA_NATIVE_HUD_THEFEED_REPORT_LOGO_ON(  )
	{
		HUD::THEFEED_REPORT_LOGO_ON();
	}

	void LUA_NATIVE_HUD_THEFEED_REPORT_LOGO_OFF(  )
	{
		HUD::THEFEED_REPORT_LOGO_OFF();
	}

	int LUA_NATIVE_HUD_THEFEED_GET_LAST_SHOWN_PHONE_ACTIVATABLE_FEED_ID(  )
	{
		auto retval = HUD::THEFEED_GET_LAST_SHOWN_PHONE_ACTIVATABLE_FEED_ID();
		return retval;
	}

	void LUA_NATIVE_HUD_THEFEED_AUTO_POST_GAMETIPS_ON(  )
	{
		HUD::THEFEED_AUTO_POST_GAMETIPS_ON();
	}

	void LUA_NATIVE_HUD_THEFEED_AUTO_POST_GAMETIPS_OFF(  )
	{
		HUD::THEFEED_AUTO_POST_GAMETIPS_OFF();
	}

	void LUA_NATIVE_HUD_THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST( int hudColorIndex) { invoke<void )
	{
		HUD::THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_SET_RGBA_PARAMETER_FOR_NEXT_MESSAGE( int red, int green, int blue, int alpha) { invoke<void )
	{
		HUD::THEFEED_SET_RGBA_PARAMETER_FOR_NEXT_MESSAGE(red, green, blue, invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_SET_FLASH_DURATION_PARAMETER_FOR_NEXT_MESSAGE( int count) { invoke<void )
	{
		HUD::THEFEED_SET_FLASH_DURATION_PARAMETER_FOR_NEXT_MESSAGE(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_SET_VIBRATE_PARAMETER_FOR_NEXT_MESSAGE( bool toggle) { invoke<void )
	{
		HUD::THEFEED_SET_VIBRATE_PARAMETER_FOR_NEXT_MESSAGE(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_RESET_ALL_PARAMETERS(  )
	{
		HUD::THEFEED_RESET_ALL_PARAMETERS();
	}

	void LUA_NATIVE_HUD_THEFEED_FREEZE_NEXT_POST(  )
	{
		HUD::THEFEED_FREEZE_NEXT_POST();
	}

	void LUA_NATIVE_HUD_THEFEED_CLEAR_FROZEN_POST(  )
	{
		HUD::THEFEED_CLEAR_FROZEN_POST();
	}

	void LUA_NATIVE_HUD_THEFEED_SET_SNAP_FEED_ITEM_POSITIONS( bool p0) { invoke<void )
	{
		HUD::THEFEED_SET_SNAP_FEED_ITEM_POSITIONS(invoke<void);
	}

	void LUA_NATIVE_HUD_THEFEED_UPDATE_ITEM_TEXTURE( const char* txdString1, const char* txnString1, const char* txdString2, const char* txnString2) { invoke<void )
	{
		HUD::THEFEED_UPDATE_ITEM_TEXTURE(txdString1, txnString1, txdString2, invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_THEFEED_POST( const char* text) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_THEFEED_POST(invoke<void);
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_STATS( const char* statTitle, int iconEnum, bool stepVal, int barValue, bool isImportant, const char* pictureTextureDict, const char* pictureTextureName) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_STATS(statTitle, iconEnum, stepVal, barValue, isImportant, pictureTextureDict, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT( const char* txdName, const char* textureName, bool flash, int iconType, const char* sender, const char* subject) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT(txdName, textureName, flash, iconType, sender, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_SUBTITLE_LABEL( const char* txdName, const char* textureName, bool flash, int iconType, const char* sender, const char* subject) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_SUBTITLE_LABEL(txdName, textureName, flash, iconType, sender, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_TU( const char* txdName, const char* textureName, bool flash, int iconType, const char* sender, const char* subject, float duration) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_TU(txdName, textureName, flash, iconType, sender, subject, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_WITH_CREW_TAG( const char* txdName, const char* textureName, bool flash, int iconType, const char* sender, const char* subject, float duration, const char* clanTag) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_WITH_CREW_TAG(txdName, textureName, flash, iconType, sender, subject, duration, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_WITH_CREW_TAG_AND_ADDITIONAL_ICON( const char* txdName, const char* textureName, bool flash, int iconType1, const char* sender, const char* subject, float duration, const char* clanTag, int iconType2, int p9) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_WITH_CREW_TAG_AND_ADDITIONAL_ICON(txdName, textureName, flash, iconType1, sender, subject, duration, clanTag, iconType2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_TICKER( bool blink, bool p1) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_TICKER(blink, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_TICKER_FORCED( bool blink, bool p1) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_TICKER_FORCED(blink, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_TICKER_WITH_TOKENS( bool blink, bool p1) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_TICKER_WITH_TOKENS(blink, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_AWARD( const char* textureDict, const char* textureName, int rpBonus, int colorOverlay, const char* titleLabel) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_AWARD(textureDict, textureName, rpBonus, colorOverlay, invoke<int);
		return retval;
	}

	std::tuple<int, int> LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_CREWTAG( bool p0, bool p1, int p2, int p3, bool isLeader, bool unk0, int clanDesc, int R, int G, int B) { return invoke<int )
	{
		std::tuple<int, int> return_values;
		std::get<0>(return_values) = HUD::END_TEXT_COMMAND_THEFEED_POST_CREWTAG(p0, p1, &p2, p3, isLeader, unk0, clanDesc, R, G, invoke<int);
		std::get<1>(return_values) = p2;

		return return_values;
	}

	std::tuple<int, int> LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_CREWTAG_WITH_GAME_NAME( bool p0, bool p1, int p2, int p3, bool isLeader, bool unk0, int clanDesc, const char* playerName, int R, int G, int B) { return invoke<int )
	{
		std::tuple<int, int> return_values;
		std::get<0>(return_values) = HUD::END_TEXT_COMMAND_THEFEED_POST_CREWTAG_WITH_GAME_NAME(p0, p1, &p2, p3, isLeader, unk0, clanDesc, playerName, R, G, invoke<int);
		std::get<1>(return_values) = p2;

		return return_values;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_UNLOCK( const char* gxtLabel1, int p1, const char* gxtLabel2) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_UNLOCK(gxtLabel1, p1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_UNLOCK_TU( const char* gxtLabel1, int p1, const char* gxtLabel2, int p3) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_UNLOCK_TU(gxtLabel1, p1, gxtLabel2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_UNLOCK_TU_WITH_COLOR( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_UNLOCK_TU_WITH_COLOR(p0, p1, p2, p3, p4, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_MPTICKER( bool blink, bool p1) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_MPTICKER(blink, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_CREW_RANKUP_WITH_LITERAL_FLAG( const char* p0, const char* p1, const char* p2, bool p3, bool p4) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_CREW_RANKUP_WITH_LITERAL_FLAG(p0, p1, p2, p3, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_VERSUS_TU( const char* txdName1, const char* textureName1, int count1, const char* txdName2, const char* textureName2, int count2, int hudColor1, int hudColor2) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_VERSUS_TU(txdName1, textureName1, count1, txdName2, textureName2, count2, hudColor1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_REPLAY( int type, int image, const char* text) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY(type, image, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT( int type, const char* button, const char* text) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(type, button, invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_PRINT( const char* GxtEntry) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_PRINT(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_PRINT( int duration, bool drawImmediately) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_PRINT(duration, invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_IS_MESSAGE_DISPLAYED( const char* text) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_IS_MESSAGE_DISPLAYED(invoke<void);
	}

	bool LUA_NATIVE_HUD_END_TEXT_COMMAND_IS_MESSAGE_DISPLAYED(  )
	{
		auto retval = (bool)HUD::END_TEXT_COMMAND_IS_MESSAGE_DISPLAYED();
		return retval;
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_DISPLAY_TEXT( const char* text) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_DISPLAY_TEXT(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_DISPLAY_TEXT( float x, float y, int p2) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_DISPLAY_TEXT(x, y, invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_GET_SCREEN_WIDTH_OF_DISPLAY_TEXT( const char* text) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_GET_SCREEN_WIDTH_OF_DISPLAY_TEXT(invoke<void);
	}

	float LUA_NATIVE_HUD_END_TEXT_COMMAND_GET_SCREEN_WIDTH_OF_DISPLAY_TEXT( bool p0) { return invoke<float )
	{
		auto retval = HUD::END_TEXT_COMMAND_GET_SCREEN_WIDTH_OF_DISPLAY_TEXT(invoke<float);
		return retval;
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING( const char* entry) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING(invoke<void);
	}

	int LUA_NATIVE_HUD_END_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING( float x, float y) { return invoke<int )
	{
		auto retval = HUD::END_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING(x, invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_DISPLAY_HELP( const char* inputType) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_DISPLAY_HELP(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_DISPLAY_HELP( int p0, bool loop, bool beep, int shape) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_DISPLAY_HELP(p0, loop, beep, invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED( const char* labelName) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(invoke<void);
	}

	bool LUA_NATIVE_HUD_END_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::END_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_SET_BLIP_NAME( const char* textLabel) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_SET_BLIP_NAME(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_SET_BLIP_NAME( int blip) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_SET_BLIP_NAME(invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_ADD_DIRECTLY_TO_PREVIOUS_BRIEFS( const char* p0) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_ADD_DIRECTLY_TO_PREVIOUS_BRIEFS(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_ADD_DIRECTLY_TO_PREVIOUS_BRIEFS( bool p0) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_ADD_DIRECTLY_TO_PREVIOUS_BRIEFS(invoke<void);
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_CLEAR_PRINT( const char* text) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_CLEAR_PRINT(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_CLEAR_PRINT(  )
	{
		HUD::END_TEXT_COMMAND_CLEAR_PRINT();
	}

	void LUA_NATIVE_HUD_BEGIN_TEXT_COMMAND_OVERRIDE_BUTTON_TEXT( const char* gxtEntry) { invoke<void )
	{
		HUD::BEGIN_TEXT_COMMAND_OVERRIDE_BUTTON_TEXT(invoke<void);
	}

	void LUA_NATIVE_HUD_END_TEXT_COMMAND_OVERRIDE_BUTTON_TEXT( int p0) { invoke<void )
	{
		HUD::END_TEXT_COMMAND_OVERRIDE_BUTTON_TEXT(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_INTEGER( int value) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_INTEGER(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_FLOAT( float value, int decimalPlaces) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_FLOAT(value, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL( const char* labelName) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL_HASH_KEY( unsigned gxtEntryHash) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL_HASH_KEY(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_BLIP_NAME( int blip) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_BLIP_NAME(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME( const char* text) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_TIME( int timestamp, int flags) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_TIME(timestamp, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_FORMATTED_INTEGER( int value, bool commaSeparated) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_FORMATTED_INTEGER(value, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_PHONE_NUMBER( const char* p0, int p1) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_PHONE_NUMBER(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_WEBSITE( const char* website) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_WEBSITE(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_TEXT_COMPONENT_SUBSTRING_KEYBOARD_DISPLAY( const char* string) { invoke<void )
	{
		HUD::ADD_TEXT_COMPONENT_SUBSTRING_KEYBOARD_DISPLAY(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_COLOUR_OF_NEXT_TEXT_COMPONENT( int hudColor) { invoke<void )
	{
		HUD::SET_COLOUR_OF_NEXT_TEXT_COMPONENT(invoke<void);
	}

	const char* LUA_NATIVE_HUD_GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME( const char* text, int position, int length) { return invoke<const char* )
	{
		auto retval = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME(text, position, char*);
		return retval;
	}

	const char* LUA_NATIVE_HUD_GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_WITH_BYTE_LIMIT( const char* text, int position, int length, int maxLength) { return invoke<const char* )
	{
		auto retval = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_WITH_BYTE_LIMIT(text, position, length, char*);
		return retval;
	}

	const char* LUA_NATIVE_HUD_GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_BYTES( const char* text, int startPosition, int endPosition) { return invoke<const char* )
	{
		auto retval = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_BYTES(text, startPosition, char*);
		return retval;
	}

	const char* LUA_NATIVE_HUD_GET_FILENAME_FOR_AUDIO_CONVERSATION( const char* labelName) { return invoke<const char* )
	{
		auto retval = HUD::GET_FILENAME_FOR_AUDIO_CONVERSATION(char*);
		return retval;
	}

	void LUA_NATIVE_HUD_CLEAR_PRINTS(  )
	{
		HUD::CLEAR_PRINTS();
	}

	void LUA_NATIVE_HUD_CLEAR_BRIEF(  )
	{
		HUD::CLEAR_BRIEF();
	}

	void LUA_NATIVE_HUD_CLEAR_ALL_HELP_MESSAGES(  )
	{
		HUD::CLEAR_ALL_HELP_MESSAGES();
	}

	void LUA_NATIVE_HUD_CLEAR_THIS_PRINT( const char* p0) { invoke<void )
	{
		HUD::CLEAR_THIS_PRINT(invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_SMALL_PRINTS(  )
	{
		HUD::CLEAR_SMALL_PRINTS();
	}

	bool LUA_NATIVE_HUD_DOES_TEXT_BLOCK_EXIST( const char* gxt) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::DOES_TEXT_BLOCK_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_REQUEST_ADDITIONAL_TEXT( const char* gxt, int slot) { invoke<void )
	{
		HUD::REQUEST_ADDITIONAL_TEXT(gxt, invoke<void);
	}

	void LUA_NATIVE_HUD_REQUEST_ADDITIONAL_TEXT_FOR_DLC( const char* gxt, int slot) { invoke<void )
	{
		HUD::REQUEST_ADDITIONAL_TEXT_FOR_DLC(gxt, invoke<void);
	}

	bool LUA_NATIVE_HUD_HAS_ADDITIONAL_TEXT_LOADED( int slot) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::HAS_ADDITIONAL_TEXT_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_CLEAR_ADDITIONAL_TEXT( int p0, bool p1) { invoke<void )
	{
		HUD::CLEAR_ADDITIONAL_TEXT(p0, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_STREAMING_ADDITIONAL_TEXT( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_STREAMING_ADDITIONAL_TEXT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_HAS_THIS_ADDITIONAL_TEXT_LOADED( const char* gxt, int slot) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::HAS_THIS_ADDITIONAL_TEXT_LOADED(gxt, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_MESSAGE_BEING_DISPLAYED(  )
	{
		auto retval = (bool)HUD::IS_MESSAGE_BEING_DISPLAYED();
		return retval;
	}

	bool LUA_NATIVE_HUD_DOES_TEXT_LABEL_EXIST( const char* gxt) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::DOES_TEXT_LABEL_EXIST(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_HUD_GET_FIRST_N_CHARACTERS_OF_LITERAL_STRING( const char* string, int length) { return invoke<const char* )
	{
		auto retval = HUD::GET_FIRST_N_CHARACTERS_OF_LITERAL_STRING(string, char*);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_LENGTH_OF_STRING_WITH_THIS_TEXT_LABEL( const char* gxt) { return invoke<int )
	{
		auto retval = HUD::GET_LENGTH_OF_STRING_WITH_THIS_TEXT_LABEL(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_LENGTH_OF_LITERAL_STRING( const char* string) { return invoke<int )
	{
		auto retval = HUD::GET_LENGTH_OF_LITERAL_STRING(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_LENGTH_OF_LITERAL_STRING_IN_BYTES( const char* string) { return invoke<int )
	{
		auto retval = HUD::GET_LENGTH_OF_LITERAL_STRING_IN_BYTES(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_HUD_GET_STREET_NAME_FROM_HASH_KEY( unsigned hash) { return invoke<const char* )
	{
		auto retval = HUD::GET_STREET_NAME_FROM_HASH_KEY(char*);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_HUD_PREFERENCE_SWITCHED_ON(  )
	{
		auto retval = (bool)HUD::IS_HUD_PREFERENCE_SWITCHED_ON();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_RADAR_PREFERENCE_SWITCHED_ON(  )
	{
		auto retval = (bool)HUD::IS_RADAR_PREFERENCE_SWITCHED_ON();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_SUBTITLE_PREFERENCE_SWITCHED_ON(  )
	{
		auto retval = (bool)HUD::IS_SUBTITLE_PREFERENCE_SWITCHED_ON();
		return retval;
	}

	void LUA_NATIVE_HUD_DISPLAY_HUD( bool toggle) { invoke<void )
	{
		HUD::DISPLAY_HUD(invoke<void);
	}

	void LUA_NATIVE_HUD_DISPLAY_HUD_WHEN_NOT_IN_STATE_OF_PLAY_THIS_FRAME(  )
	{
		HUD::DISPLAY_HUD_WHEN_NOT_IN_STATE_OF_PLAY_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_DISPLAY_HUD_WHEN_PAUSED_THIS_FRAME(  )
	{
		HUD::DISPLAY_HUD_WHEN_PAUSED_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_DISPLAY_RADAR( bool toggle) { invoke<void )
	{
		HUD::DISPLAY_RADAR(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FAKE_SPECTATOR_MODE( bool toggle) { invoke<void )
	{
		HUD::SET_FAKE_SPECTATOR_MODE(invoke<void);
	}

	bool LUA_NATIVE_HUD_GET_FAKE_SPECTATOR_MODE(  )
	{
		auto retval = (bool)HUD::GET_FAKE_SPECTATOR_MODE();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_HUD_HIDDEN(  )
	{
		auto retval = (bool)HUD::IS_HUD_HIDDEN();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_RADAR_HIDDEN(  )
	{
		auto retval = (bool)HUD::IS_RADAR_HIDDEN();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_MINIMAP_RENDERING(  )
	{
		auto retval = (bool)HUD::IS_MINIMAP_RENDERING();
		return retval;
	}

	void LUA_NATIVE_HUD_USE_VEHICLE_TARGETING_RETICULE( Any p0) { invoke<void )
	{
		HUD::USE_VEHICLE_TARGETING_RETICULE(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_VALID_VEHICLE_HIT_HASH( Any p0) { invoke<void )
	{
		HUD::ADD_VALID_VEHICLE_HIT_HASH(invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_VALID_VEHICLE_HIT_HASHES(  )
	{
		HUD::CLEAR_VALID_VEHICLE_HIT_HASHES();
	}

	void LUA_NATIVE_HUD_SET_BLIP_ROUTE( int blip, bool enabled) { invoke<void )
	{
		HUD::SET_BLIP_ROUTE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_ALL_BLIP_ROUTES(  )
	{
		HUD::CLEAR_ALL_BLIP_ROUTES();
	}

	void LUA_NATIVE_HUD_SET_BLIP_ROUTE_COLOUR( int blip, int colour) { invoke<void )
	{
		HUD::SET_BLIP_ROUTE_COLOUR(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FORCE_SHOW_GPS( bool toggle) { invoke<void )
	{
		HUD::SET_FORCE_SHOW_GPS(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_USE_SET_DESTINATION_IN_PAUSE_MAP( bool toggle) { invoke<void )
	{
		HUD::SET_USE_SET_DESTINATION_IN_PAUSE_MAP(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLOCK_WANTED_FLASH( bool disabled) { invoke<void )
	{
		HUD::SET_BLOCK_WANTED_FLASH(invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_NEXT_MESSAGE_TO_PREVIOUS_BRIEFS( bool p0) { invoke<void )
	{
		HUD::ADD_NEXT_MESSAGE_TO_PREVIOUS_BRIEFS(invoke<void);
	}

	void LUA_NATIVE_HUD_FORCE_NEXT_MESSAGE_TO_PREVIOUS_BRIEFS_LIST( int p0) { invoke<void )
	{
		HUD::FORCE_NEXT_MESSAGE_TO_PREVIOUS_BRIEFS_LIST(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADAR_ZOOM_PRECISE( float zoom) { invoke<void )
	{
		HUD::SET_RADAR_ZOOM_PRECISE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADAR_ZOOM( int zoomLevel) { invoke<void )
	{
		HUD::SET_RADAR_ZOOM(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADAR_ZOOM_TO_BLIP( int blip, float zoom) { invoke<void )
	{
		HUD::SET_RADAR_ZOOM_TO_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADAR_ZOOM_TO_DISTANCE( float zoom) { invoke<void )
	{
		HUD::SET_RADAR_ZOOM_TO_DISTANCE(invoke<void);
	}

	void LUA_NATIVE_HUD_UPDATE_RADAR_ZOOM_TO_BLIP(  )
	{
		HUD::UPDATE_RADAR_ZOOM_TO_BLIP();
	}

	std::tuple<int, int, int, int a) {> LUA_NATIVE_HUD_GET_HUD_COLOUR( int hudColorIndex, int r, int g, int b, int a) { invoke<void )
	{
		std::tuple<int, int, int, int a) {> return_values;
		HUD::GET_HUD_COLOUR(hudColorIndex, &r, &g, &b, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = b;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_HUD_SET_SCRIPT_VARIABLE_HUD_COLOUR( int r, int g, int b, int a) { invoke<void )
	{
		HUD::SET_SCRIPT_VARIABLE_HUD_COLOUR(r, g, b, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_SECOND_SCRIPT_VARIABLE_HUD_COLOUR( int r, int g, int b, int a) { invoke<void )
	{
		HUD::SET_SECOND_SCRIPT_VARIABLE_HUD_COLOUR(r, g, b, invoke<void);
	}

	void LUA_NATIVE_HUD_REPLACE_HUD_COLOUR( int hudColorIndex, int hudColorIndex2) { invoke<void )
	{
		HUD::REPLACE_HUD_COLOUR(hudColorIndex, invoke<void);
	}

	void LUA_NATIVE_HUD_REPLACE_HUD_COLOUR_WITH_RGBA( int hudColorIndex, int r, int g, int b, int a) { invoke<void )
	{
		HUD::REPLACE_HUD_COLOUR_WITH_RGBA(hudColorIndex, r, g, b, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_ABILITY_BAR_VISIBILITY( bool visible) { invoke<void )
	{
		HUD::SET_ABILITY_BAR_VISIBILITY(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_ALLOW_ABILITY_BAR( bool toggle) { invoke<void )
	{
		HUD::SET_ALLOW_ABILITY_BAR(invoke<void);
	}

	void LUA_NATIVE_HUD_FLASH_ABILITY_BAR( int millisecondsToFlash) { invoke<void )
	{
		HUD::FLASH_ABILITY_BAR(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_ABILITY_BAR_VALUE( float p0, float p1) { invoke<void )
	{
		HUD::SET_ABILITY_BAR_VALUE(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_FLASH_WANTED_DISPLAY( bool p0) { invoke<void )
	{
		HUD::FLASH_WANTED_DISPLAY(invoke<void);
	}

	void LUA_NATIVE_HUD_FORCE_OFF_WANTED_STAR_FLASH( bool toggle) { invoke<void )
	{
		HUD::FORCE_OFF_WANTED_STAR_FLASH(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_CUSTOM_MP_HUD_COLOR( int hudColorId) { invoke<void )
	{
		HUD::SET_CUSTOM_MP_HUD_COLOR(invoke<void);
	}

	float LUA_NATIVE_HUD_GET_RENDERED_CHARACTER_HEIGHT( float size, int font) { return invoke<float )
	{
		auto retval = HUD::GET_RENDERED_CHARACTER_HEIGHT(size, invoke<float);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_TEXT_SCALE( float scale, float size) { invoke<void )
	{
		HUD::SET_TEXT_SCALE(scale, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_COLOUR( int red, int green, int blue, int alpha) { invoke<void )
	{
		HUD::SET_TEXT_COLOUR(red, green, blue, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_CENTRE( bool align) { invoke<void )
	{
		HUD::SET_TEXT_CENTRE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_RIGHT_JUSTIFY( bool toggle) { invoke<void )
	{
		HUD::SET_TEXT_RIGHT_JUSTIFY(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_JUSTIFICATION( int justifyType) { invoke<void )
	{
		HUD::SET_TEXT_JUSTIFICATION(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_WRAP( float start, float end) { invoke<void )
	{
		HUD::SET_TEXT_WRAP(start, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_LEADING( int p0) { invoke<void )
	{
		HUD::SET_TEXT_LEADING(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_PROPORTIONAL( bool p0) { invoke<void )
	{
		HUD::SET_TEXT_PROPORTIONAL(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_FONT( int fontType) { invoke<void )
	{
		HUD::SET_TEXT_FONT(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_DROP_SHADOW(  )
	{
		HUD::SET_TEXT_DROP_SHADOW();
	}

	void LUA_NATIVE_HUD_SET_TEXT_DROPSHADOW( int distance, int r, int g, int b, int a) { invoke<void )
	{
		HUD::SET_TEXT_DROPSHADOW(distance, r, g, b, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_OUTLINE(  )
	{
		HUD::SET_TEXT_OUTLINE();
	}

	void LUA_NATIVE_HUD_SET_TEXT_EDGE( int p0, int r, int g, int b, int a) { invoke<void )
	{
		HUD::SET_TEXT_EDGE(p0, r, g, b, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_TEXT_RENDER_ID( int renderId) { invoke<void )
	{
		HUD::SET_TEXT_RENDER_ID(invoke<void);
	}

	int LUA_NATIVE_HUD_GET_DEFAULT_SCRIPT_RENDERTARGET_RENDER_ID(  )
	{
		auto retval = HUD::GET_DEFAULT_SCRIPT_RENDERTARGET_RENDER_ID();
		return retval;
	}

	bool LUA_NATIVE_HUD_REGISTER_NAMED_RENDERTARGET( const char* name, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::REGISTER_NAMED_RENDERTARGET(name, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_NAMED_RENDERTARGET_REGISTERED( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_NAMED_RENDERTARGET_REGISTERED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_RELEASE_NAMED_RENDERTARGET( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::RELEASE_NAMED_RENDERTARGET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_LINK_NAMED_RENDERTARGET( unsigned modelHash) { invoke<void )
	{
		HUD::LINK_NAMED_RENDERTARGET(invoke<void);
	}

	int LUA_NATIVE_HUD_GET_NAMED_RENDERTARGET_RENDER_ID( const char* name) { return invoke<int )
	{
		auto retval = HUD::GET_NAMED_RENDERTARGET_RENDER_ID(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_NAMED_RENDERTARGET_LINKED( unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_NAMED_RENDERTARGET_LINKED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_CLEAR_HELP( bool toggle) { invoke<void )
	{
		HUD::CLEAR_HELP(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_HELP_MESSAGE_ON_SCREEN(  )
	{
		auto retval = (bool)HUD::IS_HELP_MESSAGE_ON_SCREEN();
		return retval;
	}

	bool LUA_NATIVE_HUD_HAS_SCRIPT_HIDDEN_HELP_THIS_FRAME(  )
	{
		auto retval = (bool)HUD::HAS_SCRIPT_HIDDEN_HELP_THIS_FRAME();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_HELP_MESSAGE_BEING_DISPLAYED(  )
	{
		auto retval = (bool)HUD::IS_HELP_MESSAGE_BEING_DISPLAYED();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_HELP_MESSAGE_FADING_OUT(  )
	{
		auto retval = (bool)HUD::IS_HELP_MESSAGE_FADING_OUT();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_HELP_MESSAGE_STYLE( int style, int hudColor, int alpha, int p3, int p4) { invoke<void )
	{
		HUD::SET_HELP_MESSAGE_STYLE(style, hudColor, alpha, p3, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_STANDARD_BLIP_ENUM_ID(  )
	{
		auto retval = HUD::GET_STANDARD_BLIP_ENUM_ID();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_WAYPOINT_BLIP_ENUM_ID(  )
	{
		auto retval = HUD::GET_WAYPOINT_BLIP_ENUM_ID();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_NUMBER_OF_ACTIVE_BLIPS(  )
	{
		auto retval = HUD::GET_NUMBER_OF_ACTIVE_BLIPS();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_NEXT_BLIP_INFO_ID( int blipSprite) { return invoke<int )
	{
		auto retval = HUD::GET_NEXT_BLIP_INFO_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_FIRST_BLIP_INFO_ID( int blipSprite) { return invoke<int )
	{
		auto retval = HUD::GET_FIRST_BLIP_INFO_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_CLOSEST_BLIP_INFO_ID( int blipSprite) { return invoke<int )
	{
		auto retval = HUD::GET_CLOSEST_BLIP_INFO_ID(invoke<int);
		return retval;
	}

	Vector3 LUA_NATIVE_HUD_GET_BLIP_INFO_ID_COORD( int blip) { return invoke<Vector3 )
	{
		auto retval = HUD::GET_BLIP_INFO_ID_COORD(invoke<Vector3);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_INFO_ID_DISPLAY( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_INFO_ID_DISPLAY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_INFO_ID_TYPE( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_INFO_ID_TYPE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_INFO_ID_ENTITY_INDEX( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_INFO_ID_ENTITY_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_INFO_ID_PICKUP_INDEX( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_INFO_ID_PICKUP_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_FROM_ENTITY( int entity) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_FROM_ENTITY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_ADD_BLIP_FOR_RADIUS( float posX, float posY, float posZ, float radius) { return invoke<int )
	{
		auto retval = HUD::ADD_BLIP_FOR_RADIUS(posX, posY, posZ, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_ADD_BLIP_FOR_AREA( float x, float y, float z, float width, float height) { return invoke<int )
	{
		auto retval = HUD::ADD_BLIP_FOR_AREA(x, y, z, width, invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_ADD_BLIP_FOR_ENTITY( int entity) { return invoke<int )
	{
		auto retval = HUD::ADD_BLIP_FOR_ENTITY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_ADD_BLIP_FOR_PICKUP( int pickup) { return invoke<int )
	{
		auto retval = HUD::ADD_BLIP_FOR_PICKUP(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_ADD_BLIP_FOR_COORD( float x, float y, float z) { return invoke<int )
	{
		auto retval = HUD::ADD_BLIP_FOR_COORD(x, y, invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_TRIGGER_SONAR_BLIP( float posX, float posY, float posZ, float radius, int p4) { invoke<void )
	{
		HUD::TRIGGER_SONAR_BLIP(posX, posY, posZ, radius, invoke<void);
	}

	void LUA_NATIVE_HUD_ALLOW_SONAR_BLIPS( bool toggle) { invoke<void )
	{
		HUD::ALLOW_SONAR_BLIPS(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_COORDS( int blip, float posX, float posY, float posZ) { invoke<void )
	{
		HUD::SET_BLIP_COORDS(blip, posX, posY, invoke<void);
	}

	Vector3 LUA_NATIVE_HUD_GET_BLIP_COORDS( int blip) { return invoke<Vector3 )
	{
		auto retval = HUD::GET_BLIP_COORDS(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_SPRITE( int blip, int spriteId) { invoke<void )
	{
		HUD::SET_BLIP_SPRITE(blip, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_BLIP_SPRITE( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_SPRITE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_COP_BLIP_SPRITE( int p0, float p1) { invoke<void )
	{
		HUD::SET_COP_BLIP_SPRITE(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_COP_BLIP_SPRITE_AS_STANDARD(  )
	{
		HUD::SET_COP_BLIP_SPRITE_AS_STANDARD();
	}

	void LUA_NATIVE_HUD_SET_BLIP_NAME_FROM_TEXT_FILE( int blip, const char* gxtEntry) { invoke<void )
	{
		HUD::SET_BLIP_NAME_FROM_TEXT_FILE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_NAME_TO_PLAYER_NAME( int blip, int player) { invoke<void )
	{
		HUD::SET_BLIP_NAME_TO_PLAYER_NAME(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_ALPHA( int blip, int alpha) { invoke<void )
	{
		HUD::SET_BLIP_ALPHA(blip, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_BLIP_ALPHA( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_ALPHA(invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_FADE( int blip, int opacity, int duration) { invoke<void )
	{
		HUD::SET_BLIP_FADE(blip, opacity, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_BLIP_FADE_DIRECTION( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_FADE_DIRECTION(invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_ROTATION( int blip, int rotation) { invoke<void )
	{
		HUD::SET_BLIP_ROTATION(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_ROTATION_WITH_FLOAT( int blip, float heading) { invoke<void )
	{
		HUD::SET_BLIP_ROTATION_WITH_FLOAT(blip, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_BLIP_ROTATION( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_ROTATION(invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_FLASH_TIMER( int blip, int duration) { invoke<void )
	{
		HUD::SET_BLIP_FLASH_TIMER(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_FLASH_INTERVAL( int blip, Any p1) { invoke<void )
	{
		HUD::SET_BLIP_FLASH_INTERVAL(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_COLOUR( int blip, int color) { invoke<void )
	{
		HUD::SET_BLIP_COLOUR(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_SECONDARY_COLOUR( int blip, int r, int g, int b) { invoke<void )
	{
		HUD::SET_BLIP_SECONDARY_COLOUR(blip, r, g, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_BLIP_COLOUR( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_COLOUR(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_BLIP_HUD_COLOUR( int blip) { return invoke<int )
	{
		auto retval = HUD::GET_BLIP_HUD_COLOUR(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_BLIP_SHORT_RANGE( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_BLIP_SHORT_RANGE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_BLIP_ON_MINIMAP( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_BLIP_ON_MINIMAP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_DOES_BLIP_HAVE_GPS_ROUTE( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::DOES_BLIP_HAVE_GPS_ROUTE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_HIDDEN_ON_LEGEND( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_HIDDEN_ON_LEGEND(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_HIGH_DETAIL( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_HIGH_DETAIL(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_AS_MISSION_CREATOR_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_AS_MISSION_CREATOR_BLIP(blip, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_MISSION_CREATOR_BLIP( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_MISSION_CREATOR_BLIP(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_NEW_SELECTED_MISSION_CREATOR_BLIP(  )
	{
		auto retval = HUD::GET_NEW_SELECTED_MISSION_CREATOR_BLIP();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_HOVERING_OVER_MISSION_CREATOR_BLIP(  )
	{
		auto retval = (bool)HUD::IS_HOVERING_OVER_MISSION_CREATOR_BLIP();
		return retval;
	}

	void LUA_NATIVE_HUD_SHOW_START_MISSION_INSTRUCTIONAL_BUTTON( bool toggle) { invoke<void )
	{
		HUD::SHOW_START_MISSION_INSTRUCTIONAL_BUTTON(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_CONTACT_INSTRUCTIONAL_BUTTON( bool toggle) { invoke<void )
	{
		HUD::SHOW_CONTACT_INSTRUCTIONAL_BUTTON(invoke<void);
	}

	void LUA_NATIVE_HUD_RELOAD_MAP_MENU(  )
	{
		HUD::RELOAD_MAP_MENU();
	}

	void LUA_NATIVE_HUD_SET_BLIP_MARKER_LONG_DISTANCE( Any p0, Any p1) { invoke<void )
	{
		HUD::SET_BLIP_MARKER_LONG_DISTANCE(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_FLASHES( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_FLASHES(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_FLASHES_ALTERNATE( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_FLASHES_ALTERNATE(blip, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_BLIP_FLASHING( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_BLIP_FLASHING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_BLIP_AS_SHORT_RANGE( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_AS_SHORT_RANGE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_SCALE( int blip, float scale) { invoke<void )
	{
		HUD::SET_BLIP_SCALE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_SCALE_2D( int blip, float xScale, float yScale) { invoke<void )
	{
		HUD::SET_BLIP_SCALE_2D(blip, xScale, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_PRIORITY( int blip, int priority) { invoke<void )
	{
		HUD::SET_BLIP_PRIORITY(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_DISPLAY( int blip, int displayId) { invoke<void )
	{
		HUD::SET_BLIP_DISPLAY(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_CATEGORY( int blip, int index) { invoke<void )
	{
		HUD::SET_BLIP_CATEGORY(blip, invoke<void);
	}

	int blip) { LUA_NATIVE_HUD_REMOVE_BLIP( int blip) { invoke<void )
	{
		HUD::REMOVE_BLIP(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_HUD_SET_BLIP_AS_FRIENDLY( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_AS_FRIENDLY(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_PULSE_BLIP( int blip) { invoke<void )
	{
		HUD::PULSE_BLIP(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_NUMBER_ON_BLIP( int blip, int number) { invoke<void )
	{
		HUD::SHOW_NUMBER_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_HIDE_NUMBER_ON_BLIP( int blip) { invoke<void )
	{
		HUD::HIDE_NUMBER_ON_BLIP(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_HEIGHT_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_HEIGHT_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_TICK_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_TICK_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_GOLD_TICK_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_GOLD_TICK_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_FOR_SALE_ICON_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_FOR_SALE_ICON_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_HEADING_INDICATOR_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_HEADING_INDICATOR_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_OUTLINE_INDICATOR_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_OUTLINE_INDICATOR_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_FRIEND_INDICATOR_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_FRIEND_INDICATOR_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_CREW_INDICATOR_ON_BLIP( int blip, bool toggle) { invoke<void )
	{
		HUD::SHOW_CREW_INDICATOR_ON_BLIP(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_EXTENDED_HEIGHT_THRESHOLD( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_EXTENDED_HEIGHT_THRESHOLD(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_SHORT_HEIGHT_THRESHOLD( Any p0, Any p1) { invoke<void )
	{
		HUD::SET_BLIP_SHORT_HEIGHT_THRESHOLD(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_USE_HEIGHT_INDICATOR_ON_EDGE( int blip, Any p1) { invoke<void )
	{
		HUD::SET_BLIP_USE_HEIGHT_INDICATOR_ON_EDGE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_AS_MINIMAL_ON_EDGE( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_AS_MINIMAL_ON_EDGE(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADIUS_BLIP_EDGE( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_RADIUS_BLIP_EDGE(blip, invoke<void);
	}

	bool LUA_NATIVE_HUD_DOES_BLIP_EXIST( int blip) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::DOES_BLIP_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_WAYPOINT_OFF(  )
	{
		HUD::SET_WAYPOINT_OFF();
	}

	void LUA_NATIVE_HUD_DELETE_WAYPOINTS_FROM_THIS_PLAYER(  )
	{
		HUD::DELETE_WAYPOINTS_FROM_THIS_PLAYER();
	}

	void LUA_NATIVE_HUD_REFRESH_WAYPOINT(  )
	{
		HUD::REFRESH_WAYPOINT();
	}

	bool LUA_NATIVE_HUD_IS_WAYPOINT_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_WAYPOINT_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_NEW_WAYPOINT( float x, float y) { invoke<void )
	{
		HUD::SET_NEW_WAYPOINT(x, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_BRIGHT( int blip, bool toggle) { invoke<void )
	{
		HUD::SET_BLIP_BRIGHT(blip, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BLIP_SHOW_CONE( int blip, bool toggle, int hudColorIndex) { invoke<void )
	{
		HUD::SET_BLIP_SHOW_CONE(blip, toggle, invoke<void);
	}

	void LUA_NATIVE_HUD_REMOVE_COP_BLIP_FROM_PED( int ped) { invoke<void )
	{
		HUD::REMOVE_COP_BLIP_FROM_PED(invoke<void);
	}

	void LUA_NATIVE_HUD_SETUP_FAKE_CONE_DATA( int blip, float p1, float p2, float p3, float p4, float p5, float p6, Any p7, int p8) { invoke<void )
	{
		HUD::SETUP_FAKE_CONE_DATA(blip, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_HUD_REMOVE_FAKE_CONE_DATA( int blip) { invoke<void )
	{
		HUD::REMOVE_FAKE_CONE_DATA(invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_FAKE_CONE_ARRAY(  )
	{
		HUD::CLEAR_FAKE_CONE_ARRAY();
	}

	bool LUA_NATIVE_HUD_SET_MINIMAP_COMPONENT( int componentId, bool toggle, int overrideColor) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::SET_MINIMAP_COMPONENT(componentId, toggle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_SONAR_SWEEP( bool toggle) { invoke<void )
	{
		HUD::SET_MINIMAP_SONAR_SWEEP(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_ACCOUNT_PICKER(  )
	{
		HUD::SHOW_ACCOUNT_PICKER();
	}

	int LUA_NATIVE_HUD_GET_MAIN_PLAYER_BLIP_ID(  )
	{
		auto retval = HUD::GET_MAIN_PLAYER_BLIP_ID();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_PM_WARNINGSCREEN_ACTIVE( bool p0) { invoke<void )
	{
		HUD::SET_PM_WARNINGSCREEN_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_HUD_HIDE_LOADING_ON_FADE_THIS_FRAME(  )
	{
		HUD::HIDE_LOADING_ON_FADE_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_RADAR_AS_INTERIOR_THIS_FRAME( unsigned interior, float x, float y, int z, int zoom) { invoke<void )
	{
		HUD::SET_RADAR_AS_INTERIOR_THIS_FRAME(interior, x, y, z, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_INSIDE_VERY_SMALL_INTERIOR( bool toggle) { invoke<void )
	{
		HUD::SET_INSIDE_VERY_SMALL_INTERIOR(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_INSIDE_VERY_LARGE_INTERIOR( bool toggle) { invoke<void )
	{
		HUD::SET_INSIDE_VERY_LARGE_INTERIOR(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_RADAR_AS_EXTERIOR_THIS_FRAME(  )
	{
		HUD::SET_RADAR_AS_EXTERIOR_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_FAKE_PAUSEMAP_PLAYER_POSITION_THIS_FRAME( float x, float y) { invoke<void )
	{
		HUD::SET_FAKE_PAUSEMAP_PLAYER_POSITION_THIS_FRAME(x, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FAKE_GPS_PLAYER_POSITION_THIS_FRAME( float x, float y, Any p2) { invoke<void )
	{
		HUD::SET_FAKE_GPS_PLAYER_POSITION_THIS_FRAME(x, y, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_PAUSEMAP_IN_INTERIOR_MODE(  )
	{
		auto retval = (bool)HUD::IS_PAUSEMAP_IN_INTERIOR_MODE();
		return retval;
	}

	void LUA_NATIVE_HUD_HIDE_MINIMAP_EXTERIOR_MAP_THIS_FRAME(  )
	{
		HUD::HIDE_MINIMAP_EXTERIOR_MAP_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_HIDE_MINIMAP_INTERIOR_MAP_THIS_FRAME(  )
	{
		HUD::HIDE_MINIMAP_INTERIOR_MAP_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_USE_ISLAND_MAP( bool toggle) { invoke<void )
	{
		HUD::SET_USE_ISLAND_MAP(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PAUSE_EXTERIOR_RENDERING_WHILE_IN_INTERIOR_(  )
	{
		HUD::SET_PAUSE_EXTERIOR_RENDERING_WHILE_IN_INTERIOR_();
	}

	void LUA_NATIVE_HUD_DONT_TILT_MINIMAP_THIS_FRAME(  )
	{
		HUD::DONT_TILT_MINIMAP_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_DONT_ZOOM_MINIMAP_WHEN_RUNNING_THIS_FRAME(  )
	{
		HUD::DONT_ZOOM_MINIMAP_WHEN_RUNNING_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_DONT_ZOOM_MINIMAP_WHEN_SNIPING_THIS_FRAME(  )
	{
		HUD::DONT_ZOOM_MINIMAP_WHEN_SNIPING_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_WIDESCREEN_FORMAT( Any p0) { invoke<void )
	{
		HUD::SET_WIDESCREEN_FORMAT(invoke<void);
	}

	void LUA_NATIVE_HUD_DISPLAY_AREA_NAME( bool toggle) { invoke<void )
	{
		HUD::DISPLAY_AREA_NAME(invoke<void);
	}

	void LUA_NATIVE_HUD_DISPLAY_CASH( bool toggle) { invoke<void )
	{
		HUD::DISPLAY_CASH(invoke<void);
	}

	void LUA_NATIVE_HUD_USE_FAKE_MP_CASH( bool toggle) { invoke<void )
	{
		HUD::USE_FAKE_MP_CASH(invoke<void);
	}

	void LUA_NATIVE_HUD_CHANGE_FAKE_MP_CASH( int cash, int bank) { invoke<void )
	{
		HUD::CHANGE_FAKE_MP_CASH(cash, invoke<void);
	}

	void LUA_NATIVE_HUD_DISPLAY_AMMO_THIS_FRAME( bool display) { invoke<void )
	{
		HUD::DISPLAY_AMMO_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_HUD_DISPLAY_SNIPER_SCOPE_THIS_FRAME(  )
	{
		HUD::DISPLAY_SNIPER_SCOPE_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_HIDE_HUD_AND_RADAR_THIS_FRAME(  )
	{
		HUD::HIDE_HUD_AND_RADAR_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_ALLOW_DISPLAY_OF_MULTIPLAYER_CASH_TEXT( bool allow) { invoke<void )
	{
		HUD::ALLOW_DISPLAY_OF_MULTIPLAYER_CASH_TEXT(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MULTIPLAYER_WALLET_CASH(  )
	{
		HUD::SET_MULTIPLAYER_WALLET_CASH();
	}

	void LUA_NATIVE_HUD_REMOVE_MULTIPLAYER_WALLET_CASH(  )
	{
		HUD::REMOVE_MULTIPLAYER_WALLET_CASH();
	}

	void LUA_NATIVE_HUD_SET_MULTIPLAYER_BANK_CASH(  )
	{
		HUD::SET_MULTIPLAYER_BANK_CASH();
	}

	void LUA_NATIVE_HUD_REMOVE_MULTIPLAYER_BANK_CASH(  )
	{
		HUD::REMOVE_MULTIPLAYER_BANK_CASH();
	}

	void LUA_NATIVE_HUD_SET_MULTIPLAYER_HUD_CASH( int p0, bool p1) { invoke<void )
	{
		HUD::SET_MULTIPLAYER_HUD_CASH(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_REMOVE_MULTIPLAYER_HUD_CASH(  )
	{
		HUD::REMOVE_MULTIPLAYER_HUD_CASH();
	}

	void LUA_NATIVE_HUD_HIDE_HELP_TEXT_THIS_FRAME(  )
	{
		HUD::HIDE_HELP_TEXT_THIS_FRAME();
	}

	bool LUA_NATIVE_HUD_IS_IME_IN_PROGRESS(  )
	{
		auto retval = (bool)HUD::IS_IME_IN_PROGRESS();
		return retval;
	}

	void LUA_NATIVE_HUD_DISPLAY_HELP_TEXT_THIS_FRAME( const char* message, bool p1) { invoke<void )
	{
		HUD::DISPLAY_HELP_TEXT_THIS_FRAME(message, invoke<void);
	}

	void LUA_NATIVE_HUD_HUD_FORCE_WEAPON_WHEEL( bool show) { invoke<void )
	{
		HUD::HUD_FORCE_WEAPON_WHEEL(invoke<void);
	}

	void LUA_NATIVE_HUD_HUD_FORCE_SPECIAL_VEHICLE_WEAPON_WHEEL(  )
	{
		HUD::HUD_FORCE_SPECIAL_VEHICLE_WEAPON_WHEEL();
	}

	void LUA_NATIVE_HUD_HUD_SUPPRESS_WEAPON_WHEEL_RESULTS_THIS_FRAME(  )
	{
		HUD::HUD_SUPPRESS_WEAPON_WHEEL_RESULTS_THIS_FRAME();
	}

	unsigned LUA_NATIVE_HUD_HUD_GET_WEAPON_WHEEL_CURRENTLY_HIGHLIGHTED(  )
	{
		auto retval = HUD::HUD_GET_WEAPON_WHEEL_CURRENTLY_HIGHLIGHTED();
		return retval;
	}

	void LUA_NATIVE_HUD_HUD_SET_WEAPON_WHEEL_TOP_SLOT( unsigned weaponHash) { invoke<void )
	{
		HUD::HUD_SET_WEAPON_WHEEL_TOP_SLOT(invoke<void);
	}

	unsigned LUA_NATIVE_HUD_HUD_GET_WEAPON_WHEEL_TOP_SLOT( int weaponTypeIndex) { return invoke<unsigned )
	{
		auto retval = HUD::HUD_GET_WEAPON_WHEEL_TOP_SLOT(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_HUD_HUD_SHOWING_CHARACTER_SWITCH_SELECTION( bool toggle) { invoke<void )
	{
		HUD::HUD_SHOWING_CHARACTER_SWITCH_SELECTION(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_GPS_FLAGS( int p0, float p1) { invoke<void )
	{
		HUD::SET_GPS_FLAGS(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_GPS_FLAGS(  )
	{
		HUD::CLEAR_GPS_FLAGS();
	}

	void LUA_NATIVE_HUD_SET_RACE_TRACK_RENDER( bool toggle) { invoke<void )
	{
		HUD::SET_RACE_TRACK_RENDER(invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_GPS_RACE_TRACK(  )
	{
		HUD::CLEAR_GPS_RACE_TRACK();
	}

	void LUA_NATIVE_HUD_START_GPS_CUSTOM_ROUTE( int hudColor, bool displayOnFoot, bool followPlayer) { invoke<void )
	{
		HUD::START_GPS_CUSTOM_ROUTE(hudColor, displayOnFoot, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_POINT_TO_GPS_CUSTOM_ROUTE( float x, float y, float z) { invoke<void )
	{
		HUD::ADD_POINT_TO_GPS_CUSTOM_ROUTE(x, y, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_GPS_CUSTOM_ROUTE_RENDER( bool toggle, int radarThickness, int mapThickness) { invoke<void )
	{
		HUD::SET_GPS_CUSTOM_ROUTE_RENDER(toggle, radarThickness, invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_GPS_CUSTOM_ROUTE(  )
	{
		HUD::CLEAR_GPS_CUSTOM_ROUTE();
	}

	void LUA_NATIVE_HUD_START_GPS_MULTI_ROUTE( int hudColor, bool routeFromPlayer, bool displayOnFoot) { invoke<void )
	{
		HUD::START_GPS_MULTI_ROUTE(hudColor, routeFromPlayer, invoke<void);
	}

	void LUA_NATIVE_HUD_ADD_POINT_TO_GPS_MULTI_ROUTE( float x, float y, float z) { invoke<void )
	{
		HUD::ADD_POINT_TO_GPS_MULTI_ROUTE(x, y, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_GPS_MULTI_ROUTE_RENDER( bool toggle) { invoke<void )
	{
		HUD::SET_GPS_MULTI_ROUTE_RENDER(invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_GPS_MULTI_ROUTE(  )
	{
		HUD::CLEAR_GPS_MULTI_ROUTE();
	}

	void LUA_NATIVE_HUD_CLEAR_GPS_PLAYER_WAYPOINT(  )
	{
		HUD::CLEAR_GPS_PLAYER_WAYPOINT();
	}

	void LUA_NATIVE_HUD_SET_GPS_FLASHES( bool toggle) { invoke<void )
	{
		HUD::SET_GPS_FLASHES(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PLAYER_ICON_COLOUR( int color) { invoke<void )
	{
		HUD::SET_PLAYER_ICON_COLOUR(invoke<void);
	}

	void LUA_NATIVE_HUD_FLASH_MINIMAP_DISPLAY(  )
	{
		HUD::FLASH_MINIMAP_DISPLAY();
	}

	void LUA_NATIVE_HUD_FLASH_MINIMAP_DISPLAY_WITH_COLOR( int hudColorIndex) { invoke<void )
	{
		HUD::FLASH_MINIMAP_DISPLAY_WITH_COLOR(invoke<void);
	}

	void LUA_NATIVE_HUD_TOGGLE_STEALTH_RADAR( bool toggle) { invoke<void )
	{
		HUD::TOGGLE_STEALTH_RADAR(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_IN_SPECTATOR_MODE( bool toggle, int ped) { invoke<void )
	{
		HUD::SET_MINIMAP_IN_SPECTATOR_MODE(toggle, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MISSION_NAME( bool p0, const char* name) { invoke<void )
	{
		HUD::SET_MISSION_NAME(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MISSION_NAME_FOR_UGC_MISSION( bool p0, const char* name) { invoke<void )
	{
		HUD::SET_MISSION_NAME_FOR_UGC_MISSION(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_DESCRIPTION_FOR_UGC_MISSION_EIGHT_STRINGS( bool p0, const char* p1, const char* p2, const char* p3, const char* p4, const char* p5, const char* p6, const char* p7, const char* p8) { invoke<void )
	{
		HUD::SET_DESCRIPTION_FOR_UGC_MISSION_EIGHT_STRINGS(p0, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_BLOCK_WAYPOINT( bool toggle) { invoke<void )
	{
		HUD::SET_MINIMAP_BLOCK_WAYPOINT(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_IN_PROLOGUE( bool toggle) { invoke<void )
	{
		HUD::SET_MINIMAP_IN_PROLOGUE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_HIDE_FOW( bool toggle) { invoke<void )
	{
		HUD::SET_MINIMAP_HIDE_FOW(invoke<void);
	}

	float LUA_NATIVE_HUD_GET_MINIMAP_FOW_DISCOVERY_RATIO(  )
	{
		auto retval = HUD::GET_MINIMAP_FOW_DISCOVERY_RATIO();
		return retval;
	}

	bool LUA_NATIVE_HUD_GET_MINIMAP_FOW_COORDINATE_IS_REVEALED( float x, float y, float z) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::GET_MINIMAP_FOW_COORDINATE_IS_REVEALED(x, y, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_FOW_DO_NOT_UPDATE( bool p0) { invoke<void )
	{
		HUD::SET_MINIMAP_FOW_DO_NOT_UPDATE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_FOW_REVEAL_COORDINATE( float x, float y, float z) { invoke<void )
	{
		HUD::SET_MINIMAP_FOW_REVEAL_COORDINATE(x, y, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_GOLF_COURSE( int hole) { invoke<void )
	{
		HUD::SET_MINIMAP_GOLF_COURSE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MINIMAP_GOLF_COURSE_OFF(  )
	{
		HUD::SET_MINIMAP_GOLF_COURSE_OFF();
	}

	void LUA_NATIVE_HUD_LOCK_MINIMAP_ANGLE( int angle) { invoke<void )
	{
		HUD::LOCK_MINIMAP_ANGLE(invoke<void);
	}

	void LUA_NATIVE_HUD_UNLOCK_MINIMAP_ANGLE(  )
	{
		HUD::UNLOCK_MINIMAP_ANGLE();
	}

	void LUA_NATIVE_HUD_LOCK_MINIMAP_POSITION( float x, float y) { invoke<void )
	{
		HUD::LOCK_MINIMAP_POSITION(x, invoke<void);
	}

	void LUA_NATIVE_HUD_UNLOCK_MINIMAP_POSITION(  )
	{
		HUD::UNLOCK_MINIMAP_POSITION();
	}

	void LUA_NATIVE_HUD_SET_FAKE_MINIMAP_MAX_ALTIMETER_HEIGHT( float altitude, bool p1, Any p2) { invoke<void )
	{
		HUD::SET_FAKE_MINIMAP_MAX_ALTIMETER_HEIGHT(altitude, p1, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_HEALTH_HUD_DISPLAY_VALUES( int health, int capacity, bool wasAdded) { invoke<void )
	{
		HUD::SET_HEALTH_HUD_DISPLAY_VALUES(health, capacity, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MAX_HEALTH_HUD_DISPLAY( int maximumValue) { invoke<void )
	{
		HUD::SET_MAX_HEALTH_HUD_DISPLAY(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MAX_ARMOUR_HUD_DISPLAY( int maximumValue) { invoke<void )
	{
		HUD::SET_MAX_ARMOUR_HUD_DISPLAY(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_BIGMAP_ACTIVE( bool toggleBigMap, bool showFullMap) { invoke<void )
	{
		HUD::SET_BIGMAP_ACTIVE(toggleBigMap, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_HUD_COMPONENT_ACTIVE( int id) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_HUD_COMPONENT_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_SCRIPTED_HUD_COMPONENT_ACTIVE( int id) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_SCRIPTED_HUD_COMPONENT_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_HIDE_SCRIPTED_HUD_COMPONENT_THIS_FRAME( int id) { invoke<void )
	{
		HUD::HIDE_SCRIPTED_HUD_COMPONENT_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_SCRIPTED_HUD_COMPONENT_THIS_FRAME( int id) { invoke<void )
	{
		HUD::SHOW_SCRIPTED_HUD_COMPONENT_THIS_FRAME(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_SCRIPTED_HUD_COMPONENT_HIDDEN_THIS_FRAME( int id) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_SCRIPTED_HUD_COMPONENT_HIDDEN_THIS_FRAME(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_HIDE_HUD_COMPONENT_THIS_FRAME( int id) { invoke<void )
	{
		HUD::HIDE_HUD_COMPONENT_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_HUD_SHOW_HUD_COMPONENT_THIS_FRAME( int id) { invoke<void )
	{
		HUD::SHOW_HUD_COMPONENT_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_HUD_HIDE_STREET_AND_CAR_NAMES_THIS_FRAME(  )
	{
		HUD::HIDE_STREET_AND_CAR_NAMES_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_RESET_RETICULE_VALUES(  )
	{
		HUD::RESET_RETICULE_VALUES();
	}

	void LUA_NATIVE_HUD_RESET_HUD_COMPONENT_VALUES( int id) { invoke<void )
	{
		HUD::RESET_HUD_COMPONENT_VALUES(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_HUD_COMPONENT_POSITION( int id, float x, float y) { invoke<void )
	{
		HUD::SET_HUD_COMPONENT_POSITION(id, x, invoke<void);
	}

	Vector3 LUA_NATIVE_HUD_GET_HUD_COMPONENT_POSITION( int id) { return invoke<Vector3 )
	{
		auto retval = HUD::GET_HUD_COMPONENT_POSITION(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_HUD_CLEAR_REMINDER_MESSAGE(  )
	{
		HUD::CLEAR_REMINDER_MESSAGE();
	}

	std::tuple<int, float, float screenY) { return> LUA_NATIVE_HUD_GET_HUD_SCREEN_POSITION_FROM_WORLD_POSITION( float worldX, float worldY, float worldZ, float screenX, float screenY) { return invoke<int )
	{
		std::tuple<int, float, float screenY) { return> return_values;
		std::get<0>(return_values) = HUD::GET_HUD_SCREEN_POSITION_FROM_WORLD_POSITION(worldX, worldY, worldZ, &screenX, &invoke<int);
		std::get<1>(return_values) = screenX;
		std::get<2>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_HUD_OPEN_REPORTUGC_MENU(  )
	{
		HUD::OPEN_REPORTUGC_MENU();
	}

	void LUA_NATIVE_HUD_FORCE_CLOSE_REPORTUGC_MENU(  )
	{
		HUD::FORCE_CLOSE_REPORTUGC_MENU();
	}

	bool LUA_NATIVE_HUD_IS_REPORTUGC_MENU_OPEN(  )
	{
		auto retval = (bool)HUD::IS_REPORTUGC_MENU_OPEN();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_FLOATING_HELP_TEXT_ON_SCREEN( int hudIndex) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_FLOATING_HELP_TEXT_ON_SCREEN(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_FLOATING_HELP_TEXT_SCREEN_POSITION( int hudIndex, float x, float y) { invoke<void )
	{
		HUD::SET_FLOATING_HELP_TEXT_SCREEN_POSITION(hudIndex, x, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FLOATING_HELP_TEXT_WORLD_POSITION( int hudIndex, float x, float y, float z) { invoke<void )
	{
		HUD::SET_FLOATING_HELP_TEXT_WORLD_POSITION(hudIndex, x, y, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FLOATING_HELP_TEXT_TO_ENTITY( int hudIndex, int entity, float offsetX, float offsetY) { invoke<void )
	{
		HUD::SET_FLOATING_HELP_TEXT_TO_ENTITY(hudIndex, entity, offsetX, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_FLOATING_HELP_TEXT_STYLE( int hudIndex, int p1, int p2, int p3, int p4, int p5) { invoke<void )
	{
		HUD::SET_FLOATING_HELP_TEXT_STYLE(hudIndex, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_HUD_CLEAR_FLOATING_HELP( int hudIndex, bool p1) { invoke<void )
	{
		HUD::CLEAR_FLOATING_HELP(hudIndex, invoke<void);
	}

	void LUA_NATIVE_HUD_CREATE_MP_GAMER_TAG_WITH_CREW_COLOR( int player, const char* username, bool pointedClanTag, bool isRockstarClan, const char* clanTag, int clanFlag, int r, int g, int b) { invoke<void )
	{
		HUD::CREATE_MP_GAMER_TAG_WITH_CREW_COLOR(player, username, pointedClanTag, isRockstarClan, clanTag, clanFlag, r, g, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_MP_GAMER_TAG_MOVIE_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_MP_GAMER_TAG_MOVIE_ACTIVE();
		return retval;
	}

	int LUA_NATIVE_HUD_CREATE_FAKE_MP_GAMER_TAG( int ped, const char* username, bool pointedClanTag, bool isRockstarClan, const char* clanTag, int clanFlag) { return invoke<int )
	{
		auto retval = HUD::CREATE_FAKE_MP_GAMER_TAG(ped, username, pointedClanTag, isRockstarClan, clanTag, invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_REMOVE_MP_GAMER_TAG( int gamerTagId) { invoke<void )
	{
		HUD::REMOVE_MP_GAMER_TAG(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_MP_GAMER_TAG_ACTIVE( int gamerTagId) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_MP_GAMER_TAG_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_MP_GAMER_TAG_FREE( int gamerTagId) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_MP_GAMER_TAG_FREE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_VISIBILITY( int gamerTagId, int component, bool toggle, Any p3) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_VISIBILITY(gamerTagId, component, toggle, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_ALL_MP_GAMER_TAGS_VISIBILITY( int gamerTagId, bool toggle) { invoke<void )
	{
		HUD::SET_ALL_MP_GAMER_TAGS_VISIBILITY(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAGS_SHOULD_USE_VEHICLE_HEALTH( int gamerTagId, bool toggle) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAGS_SHOULD_USE_VEHICLE_HEALTH(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAGS_SHOULD_USE_POINTS_HEALTH( int gamerTagId, bool toggle) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAGS_SHOULD_USE_POINTS_HEALTH(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAGS_POINT_HEALTH( int gamerTagId, int value, int maximumValue) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAGS_POINT_HEALTH(gamerTagId, value, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_COLOUR( int gamerTagId, int component, int hudColorIndex) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_COLOUR(gamerTagId, component, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_HEALTH_BAR_COLOUR( int gamerTagId, int hudColorIndex) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_HEALTH_BAR_COLOUR(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_ALPHA( int gamerTagId, int component, int alpha) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_ALPHA(gamerTagId, component, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_WANTED_LEVEL( int gamerTagId, int wantedlvl) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_WANTED_LEVEL(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_NUM_PACKAGES( int gamerTagId, int p1) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_NUM_PACKAGES(gamerTagId, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_NAME( int gamerTagId, const char* string) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_NAME(gamerTagId, invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_UPDATING_MP_GAMER_TAG_NAME_AND_CREW_DETAILS( int gamerTagId) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::IS_UPDATING_MP_GAMER_TAG_NAME_AND_CREW_DETAILS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_MP_GAMER_TAG_BIG_TEXT( int gamerTagId, const char* string) { invoke<void )
	{
		HUD::SET_MP_GAMER_TAG_BIG_TEXT(gamerTagId, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_CURRENT_WEBPAGE_ID(  )
	{
		auto retval = HUD::GET_CURRENT_WEBPAGE_ID();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_CURRENT_WEBSITE_ID(  )
	{
		auto retval = HUD::GET_CURRENT_WEBSITE_ID();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_GLOBAL_ACTIONSCRIPT_FLAG( int flagIndex) { return invoke<int )
	{
		auto retval = HUD::GET_GLOBAL_ACTIONSCRIPT_FLAG(invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_RESET_GLOBAL_ACTIONSCRIPT_FLAG( int flagIndex) { invoke<void )
	{
		HUD::RESET_GLOBAL_ACTIONSCRIPT_FLAG(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_WARNING_MESSAGE_READY_FOR_CONTROL(  )
	{
		auto retval = (bool)HUD::IS_WARNING_MESSAGE_READY_FOR_CONTROL();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_WARNING_MESSAGE( const char* titleMsg, int flags, const char* promptMsg, bool p3, int p4, const char* p5, const char* p6, bool showBackground, int errorCode) { invoke<void )
	{
		HUD::SET_WARNING_MESSAGE(titleMsg, flags, promptMsg, p3, p4, p5, p6, showBackground, invoke<void);
	}

	std::tuple<Any, Any> LUA_NATIVE_HUD_SET_WARNING_MESSAGE_WITH_HEADER( const char* entryHeader, const char* entryLine1, int instructionalKey, const char* entryLine2, bool p4, Any p5, Any showBackground, Any p7, bool p8, Any p9) { invoke<void )
	{
		std::tuple<Any, Any> return_values;
		HUD::SET_WARNING_MESSAGE_WITH_HEADER(entryHeader, entryLine1, instructionalKey, entryLine2, p4, p5, &showBackground, &p7, p8, invoke<void);
		std::get<0>(return_values) = showBackground;
		std::get<1>(return_values) = p7;

		return return_values;
	}

	void LUA_NATIVE_HUD_SET_WARNING_MESSAGE_WITH_HEADER_AND_SUBSTRING_FLAGS( const char* entryHeader, const char* entryLine1, int instructionalKey, const char* entryLine2, bool p4, Any p5, Any additionalIntInfo, const char* additionalTextInfoLine1, const char* additionalTextInfoLine2, bool showBackground, int errorCode) { invoke<void )
	{
		HUD::SET_WARNING_MESSAGE_WITH_HEADER_AND_SUBSTRING_FLAGS(entryHeader, entryLine1, instructionalKey, entryLine2, p4, p5, additionalIntInfo, additionalTextInfoLine1, additionalTextInfoLine2, showBackground, invoke<void);
	}

	std::tuple<Any, Any> LUA_NATIVE_HUD_SET_WARNING_MESSAGE_WITH_HEADER_EXTENDED( const char* entryHeader, const char* entryLine1, int flags, const char* entryLine2, bool p4, Any p5, Any p6, Any p7, bool showBg, Any p9, Any p10) { invoke<void )
	{
		std::tuple<Any, Any> return_values;
		HUD::SET_WARNING_MESSAGE_WITH_HEADER_EXTENDED(entryHeader, entryLine1, flags, entryLine2, p4, p5, &p6, &p7, showBg, p9, invoke<void);
		std::get<0>(return_values) = p6;
		std::get<1>(return_values) = p7;

		return return_values;
	}

	void LUA_NATIVE_HUD_SET_WARNING_MESSAGE_WITH_HEADER_AND_SUBSTRING_FLAGS_EXTENDED( const char* labelTitle, const char* labelMessage, int p2, int p3, const char* labelMessage2, bool p5, int p6, int p7, const char* p8, const char* p9, bool background, int errorCode) { invoke<void )
	{
		HUD::SET_WARNING_MESSAGE_WITH_HEADER_AND_SUBSTRING_FLAGS_EXTENDED(labelTitle, labelMessage, p2, p3, labelMessage2, p5, p6, p7, p8, p9, background, invoke<void);
	}

	unsigned LUA_NATIVE_HUD_GET_WARNING_SCREEN_MESSAGE_HASH(  )
	{
		auto retval = HUD::GET_WARNING_SCREEN_MESSAGE_HASH();
		return retval;
	}

	bool LUA_NATIVE_HUD_SET_WARNING_MESSAGE_OPTION_ITEMS( int index, const char* name, int cash, int rp, int lvl, int colour) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::SET_WARNING_MESSAGE_OPTION_ITEMS(index, name, cash, rp, lvl, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_SET_WARNING_MESSAGE_OPTION_HIGHLIGHT( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::SET_WARNING_MESSAGE_OPTION_HIGHLIGHT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_REMOVE_WARNING_MESSAGE_OPTION_ITEMS(  )
	{
		HUD::REMOVE_WARNING_MESSAGE_OPTION_ITEMS();
	}

	bool LUA_NATIVE_HUD_IS_WARNING_MESSAGE_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_WARNING_MESSAGE_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_HUD_CLEAR_DYNAMIC_PAUSE_MENU_ERROR_MESSAGE(  )
	{
		HUD::CLEAR_DYNAMIC_PAUSE_MENU_ERROR_MESSAGE();
	}

	void LUA_NATIVE_HUD_CUSTOM_MINIMAP_SET_ACTIVE( bool toggle) { invoke<void )
	{
		HUD::CUSTOM_MINIMAP_SET_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_HUD_CUSTOM_MINIMAP_SET_BLIP_OBJECT( int spriteId) { invoke<void )
	{
		HUD::CUSTOM_MINIMAP_SET_BLIP_OBJECT(invoke<void);
	}

	int LUA_NATIVE_HUD_CUSTOM_MINIMAP_CREATE_BLIP( float x, float y, float z) { return invoke<int )
	{
		auto retval = HUD::CUSTOM_MINIMAP_CREATE_BLIP(x, y, invoke<int);
		return retval;
	}

	void LUA_NATIVE_HUD_CUSTOM_MINIMAP_CLEAR_BLIPS(  )
	{
		HUD::CUSTOM_MINIMAP_CLEAR_BLIPS();
	}

	bool LUA_NATIVE_HUD_FORCE_SONAR_BLIPS_THIS_FRAME(  )
	{
		auto retval = (bool)HUD::FORCE_SONAR_BLIPS_THIS_FRAME();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_NORTH_BLID_INDEX(  )
	{
		auto retval = HUD::GET_NORTH_BLID_INDEX();
		return retval;
	}

	void LUA_NATIVE_HUD_DISPLAY_PLAYER_NAME_TAGS_ON_BLIPS( bool toggle) { invoke<void )
	{
		HUD::DISPLAY_PLAYER_NAME_TAGS_ON_BLIPS(invoke<void);
	}

	void LUA_NATIVE_HUD_DRAW_FRONTEND_BACKGROUND_THIS_FRAME(  )
	{
		HUD::DRAW_FRONTEND_BACKGROUND_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_DRAW_HUD_OVER_FADE_THIS_FRAME(  )
	{
		HUD::DRAW_HUD_OVER_FADE_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_ACTIVATE_FRONTEND_MENU( unsigned menuhash, bool togglePause, int component) { invoke<void )
	{
		HUD::ACTIVATE_FRONTEND_MENU(menuhash, togglePause, invoke<void);
	}

	void LUA_NATIVE_HUD_RESTART_FRONTEND_MENU( unsigned menuHash, int p1) { invoke<void )
	{
		HUD::RESTART_FRONTEND_MENU(menuHash, invoke<void);
	}

	unsigned LUA_NATIVE_HUD_GET_CURRENT_FRONTEND_MENU_VERSION(  )
	{
		auto retval = HUD::GET_CURRENT_FRONTEND_MENU_VERSION();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_PAUSE_MENU_ACTIVE( bool toggle) { invoke<void )
	{
		HUD::SET_PAUSE_MENU_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_HUD_DISABLE_FRONTEND_THIS_FRAME(  )
	{
		HUD::DISABLE_FRONTEND_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SUPPRESS_FRONTEND_RENDERING_THIS_FRAME(  )
	{
		HUD::SUPPRESS_FRONTEND_RENDERING_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_ALLOW_PAUSE_WHEN_NOT_IN_STATE_OF_PLAY_THIS_FRAME(  )
	{
		HUD::ALLOW_PAUSE_WHEN_NOT_IN_STATE_OF_PLAY_THIS_FRAME();
	}

	void LUA_NATIVE_HUD_SET_FRONTEND_ACTIVE( bool active) { invoke<void )
	{
		HUD::SET_FRONTEND_ACTIVE(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_PAUSE_MENU_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_PAUSE_MENU_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_STORE_PENDING_NETWORK_SHUTDOWN_TO_OPEN(  )
	{
		auto retval = (bool)HUD::IS_STORE_PENDING_NETWORK_SHUTDOWN_TO_OPEN();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_PAUSE_MENU_STATE(  )
	{
		auto retval = HUD::GET_PAUSE_MENU_STATE();
		return retval;
	}

	Vector3 LUA_NATIVE_HUD_GET_PAUSE_MENU_POSITION(  )
	{
		auto retval = HUD::GET_PAUSE_MENU_POSITION();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_PAUSE_MENU_RESTARTING(  )
	{
		auto retval = (bool)HUD::IS_PAUSE_MENU_RESTARTING();
		return retval;
	}

	void LUA_NATIVE_HUD_FORCE_SCRIPTED_GFX_WHEN_FRONTEND_ACTIVE( const char* p0) { invoke<void )
	{
		HUD::FORCE_SCRIPTED_GFX_WHEN_FRONTEND_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENUCEPTION_GO_DEEPER( int page) { invoke<void )
	{
		HUD::PAUSE_MENUCEPTION_GO_DEEPER(invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENUCEPTION_THE_KICK(  )
	{
		HUD::PAUSE_MENUCEPTION_THE_KICK();
	}

	void LUA_NATIVE_HUD_PAUSE_TOGGLE_FULLSCREEN_MAP( Any p0) { invoke<void )
	{
		HUD::PAUSE_TOGGLE_FULLSCREEN_MAP(invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENU_ACTIVATE_CONTEXT( unsigned contextHash) { invoke<void )
	{
		HUD::PAUSE_MENU_ACTIVATE_CONTEXT(invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENU_DEACTIVATE_CONTEXT( unsigned contextHash) { invoke<void )
	{
		HUD::PAUSE_MENU_DEACTIVATE_CONTEXT(invoke<void);
	}

	bool LUA_NATIVE_HUD_PAUSE_MENU_IS_CONTEXT_ACTIVE( unsigned contextHash) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::PAUSE_MENU_IS_CONTEXT_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_HUD_PAUSE_MENU_IS_CONTEXT_MENU_ACTIVE(  )
	{
		auto retval = (bool)HUD::PAUSE_MENU_IS_CONTEXT_MENU_ACTIVE();
		return retval;
	}

	int LUA_NATIVE_HUD_PAUSE_MENU_GET_HAIR_COLOUR_INDEX(  )
	{
		auto retval = HUD::PAUSE_MENU_GET_HAIR_COLOUR_INDEX();
		return retval;
	}

	int LUA_NATIVE_HUD_PAUSE_MENU_GET_MOUSE_HOVER_INDEX(  )
	{
		auto retval = HUD::PAUSE_MENU_GET_MOUSE_HOVER_INDEX();
		return retval;
	}

	int LUA_NATIVE_HUD_PAUSE_MENU_GET_MOUSE_HOVER_UNIQUE_ID(  )
	{
		auto retval = HUD::PAUSE_MENU_GET_MOUSE_HOVER_UNIQUE_ID();
		return retval;
	}

	std::tuple<bool, Any, Any, Any p2) { return> LUA_NATIVE_HUD_PAUSE_MENU_GET_MOUSE_CLICK_EVENT( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any, Any p2) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::PAUSE_MENU_GET_MOUSE_CLICK_EVENT(&p0, &p1, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;
		std::get<3>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_HUD_PAUSE_MENU_REDRAW_INSTRUCTIONAL_BUTTONS( int p0) { invoke<void )
	{
		HUD::PAUSE_MENU_REDRAW_INSTRUCTIONAL_BUTTONS(invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENU_SET_BUSY_SPINNER( bool p0, int position, int spinnerIndex) { invoke<void )
	{
		HUD::PAUSE_MENU_SET_BUSY_SPINNER(p0, position, invoke<void);
	}

	void LUA_NATIVE_HUD_PAUSE_MENU_SET_WARN_ON_TAB_CHANGE( bool p0) { invoke<void )
	{
		HUD::PAUSE_MENU_SET_WARN_ON_TAB_CHANGE(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_FRONTEND_READY_FOR_CONTROL(  )
	{
		auto retval = (bool)HUD::IS_FRONTEND_READY_FOR_CONTROL();
		return retval;
	}

	void LUA_NATIVE_HUD_TAKE_CONTROL_OF_FRONTEND(  )
	{
		HUD::TAKE_CONTROL_OF_FRONTEND();
	}

	void LUA_NATIVE_HUD_RELEASE_CONTROL_OF_FRONTEND(  )
	{
		HUD::RELEASE_CONTROL_OF_FRONTEND();
	}

	bool LUA_NATIVE_HUD_CODE_WANTS_SCRIPT_TO_TAKE_CONTROL(  )
	{
		auto retval = (bool)HUD::CODE_WANTS_SCRIPT_TO_TAKE_CONTROL();
		return retval;
	}

	int LUA_NATIVE_HUD_GET_SCREEN_CODE_WANTS_SCRIPT_TO_CONTROL(  )
	{
		auto retval = HUD::GET_SCREEN_CODE_WANTS_SCRIPT_TO_CONTROL();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_NAVIGATING_MENU_CONTENT(  )
	{
		auto retval = (bool)HUD::IS_NAVIGATING_MENU_CONTENT();
		return retval;
	}

	bool LUA_NATIVE_HUD_HAS_MENU_TRIGGER_EVENT_OCCURRED(  )
	{
		auto retval = (bool)HUD::HAS_MENU_TRIGGER_EVENT_OCCURRED();
		return retval;
	}

	bool LUA_NATIVE_HUD_HAS_MENU_LAYOUT_CHANGED_EVENT_OCCURRED(  )
	{
		auto retval = (bool)HUD::HAS_MENU_LAYOUT_CHANGED_EVENT_OCCURRED();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_SAVEGAME_LIST_UNIQUE_ID( Any p0) { invoke<void )
	{
		HUD::SET_SAVEGAME_LIST_UNIQUE_ID(invoke<void);
	}

	std::tuple<int, int selectedItemUniqueId) {> LUA_NATIVE_HUD_GET_MENU_TRIGGER_EVENT_DETAILS( int lastItemMenuId, int selectedItemUniqueId) { invoke<void )
	{
		std::tuple<int, int selectedItemUniqueId) {> return_values;
		HUD::GET_MENU_TRIGGER_EVENT_DETAILS(&lastItemMenuId, &invoke<void);
		std::get<0>(return_values) = lastItemMenuId;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int, int selectedItemUniqueId) {> LUA_NATIVE_HUD_GET_MENU_LAYOUT_CHANGED_EVENT_DETAILS( int lastItemMenuId, int selectedItemMenuId, int selectedItemUniqueId) { invoke<void )
	{
		std::tuple<int, int, int selectedItemUniqueId) {> return_values;
		HUD::GET_MENU_LAYOUT_CHANGED_EVENT_DETAILS(&lastItemMenuId, &selectedItemMenuId, &invoke<void);
		std::get<0>(return_values) = lastItemMenuId;
		std::get<1>(return_values) = selectedItemMenuId;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<bool, int, int, int b) { return> LUA_NATIVE_HUD_GET_PM_PLAYER_CREW_COLOR( int r, int g, int b) { return invoke<BOOL )
	{
		std::tuple<bool, int, int, int b) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_PM_PLAYER_CREW_COLOR(&r, &g, &invoke<BOOL);
		std::get<1>(return_values) = r;
		std::get<2>(return_values) = g;
		std::get<3>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_HUD_GET_MENU_PED_INT_STAT( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_MENU_PED_INT_STAT(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_HUD_GET_CHARACTER_MENU_PED_INT_STAT( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_CHARACTER_MENU_PED_INT_STAT(p0, &p1, invoke<BOOL);
		std::get<1>(return_values) = p1;

		return return_values;
	}

	std::tuple<bool, int> LUA_NATIVE_HUD_GET_MENU_PED_MASKED_INT_STAT( unsigned statHash, int outValue, int mask, bool p3) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_MENU_PED_MASKED_INT_STAT(statHash, &outValue, mask, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_HUD_GET_CHARACTER_MENU_PED_MASKED_INT_STAT( unsigned statHash, Any outValue, int p2, int mask, bool p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_CHARACTER_MENU_PED_MASKED_INT_STAT(statHash, &outValue, p2, mask, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, float outValue) { return> LUA_NATIVE_HUD_GET_MENU_PED_FLOAT_STAT( unsigned statHash, float outValue) { return invoke<BOOL )
	{
		std::tuple<bool, float outValue) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_MENU_PED_FLOAT_STAT(statHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float> LUA_NATIVE_HUD_GET_CHARACTER_MENU_PED_FLOAT_STAT( float statHash, float outValue, bool p2) { return invoke<BOOL )
	{
		std::tuple<bool, float> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_CHARACTER_MENU_PED_FLOAT_STAT(statHash, &outValue, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, bool outValue) { return> LUA_NATIVE_HUD_GET_MENU_PED_BOOL_STAT( unsigned statHash, bool outValue) { return invoke<BOOL )
	{
		std::tuple<bool, bool outValue) { return> return_values;
		std::get<0>(return_values) = (bool)HUD::GET_MENU_PED_BOOL_STAT(statHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_HUD_CLEAR_PED_IN_PAUSE_MENU(  )
	{
		HUD::CLEAR_PED_IN_PAUSE_MENU();
	}

	void LUA_NATIVE_HUD_GIVE_PED_TO_PAUSE_MENU( int ped, int p1) { invoke<void )
	{
		HUD::GIVE_PED_TO_PAUSE_MENU(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PAUSE_MENU_PED_LIGHTING( bool state) { invoke<void )
	{
		HUD::SET_PAUSE_MENU_PED_LIGHTING(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PAUSE_MENU_PED_SLEEP_STATE( bool state) { invoke<void )
	{
		HUD::SET_PAUSE_MENU_PED_SLEEP_STATE(invoke<void);
	}

	void LUA_NATIVE_HUD_OPEN_ONLINE_POLICIES_MENU(  )
	{
		HUD::OPEN_ONLINE_POLICIES_MENU();
	}

	bool LUA_NATIVE_HUD_ARE_ONLINE_POLICIES_UP_TO_DATE(  )
	{
		auto retval = (bool)HUD::ARE_ONLINE_POLICIES_UP_TO_DATE();
		return retval;
	}

	bool LUA_NATIVE_HUD_IS_ONLINE_POLICIES_MENU_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_ONLINE_POLICIES_MENU_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_HUD_OPEN_SOCIAL_CLUB_MENU( unsigned menu) { invoke<void )
	{
		HUD::OPEN_SOCIAL_CLUB_MENU(invoke<void);
	}

	void LUA_NATIVE_HUD_CLOSE_SOCIAL_CLUB_MENU(  )
	{
		HUD::CLOSE_SOCIAL_CLUB_MENU();
	}

	void LUA_NATIVE_HUD_SET_SOCIAL_CLUB_TOUR( const char* name) { invoke<void )
	{
		HUD::SET_SOCIAL_CLUB_TOUR(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_SOCIAL_CLUB_ACTIVE(  )
	{
		auto retval = (bool)HUD::IS_SOCIAL_CLUB_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_TEXT_INPUT_BOX_ENABLED( bool p0) { invoke<void )
	{
		HUD::SET_TEXT_INPUT_BOX_ENABLED(invoke<void);
	}

	void LUA_NATIVE_HUD_FORCE_CLOSE_TEXT_INPUT_BOX(  )
	{
		HUD::FORCE_CLOSE_TEXT_INPUT_BOX();
	}

	void LUA_NATIVE_HUD_SET_ALLOW_COMMA_ON_TEXT_INPUT( Any p0) { invoke<void )
	{
		HUD::SET_ALLOW_COMMA_ON_TEXT_INPUT(invoke<void);
	}

	void LUA_NATIVE_HUD_OVERRIDE_MP_TEXT_CHAT_TEAM_STRING( unsigned gxtEntryHash) { invoke<void )
	{
		HUD::OVERRIDE_MP_TEXT_CHAT_TEAM_STRING(invoke<void);
	}

	bool LUA_NATIVE_HUD_IS_MP_TEXT_CHAT_TYPING(  )
	{
		auto retval = (bool)HUD::IS_MP_TEXT_CHAT_TYPING();
		return retval;
	}

	void LUA_NATIVE_HUD_CLOSE_MP_TEXT_CHAT(  )
	{
		HUD::CLOSE_MP_TEXT_CHAT();
	}

	void LUA_NATIVE_HUD_MP_TEXT_CHAT_IS_TEAM_JOB( Any p0) { invoke<void )
	{
		HUD::MP_TEXT_CHAT_IS_TEAM_JOB(invoke<void);
	}

	void LUA_NATIVE_HUD_OVERRIDE_MP_TEXT_CHAT_COLOR( int p0, int hudColor) { invoke<void )
	{
		HUD::OVERRIDE_MP_TEXT_CHAT_COLOR(p0, invoke<void);
	}

	void LUA_NATIVE_HUD_MP_TEXT_CHAT_DISABLE( bool toggle) { invoke<void )
	{
		HUD::MP_TEXT_CHAT_DISABLE(invoke<void);
	}

	void LUA_NATIVE_HUD_FLAG_PLAYER_CONTEXT_IN_TOURNAMENT( bool toggle) { invoke<void )
	{
		HUD::FLAG_PLAYER_CONTEXT_IN_TOURNAMENT(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_HAS_AI_BLIP( int ped, bool hasCone) { invoke<void )
	{
		HUD::SET_PED_HAS_AI_BLIP(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_HAS_AI_BLIP_WITH_COLOUR( int ped, bool hasCone, int color) { invoke<void )
	{
		HUD::SET_PED_HAS_AI_BLIP_WITH_COLOUR(ped, hasCone, invoke<void);
	}

	bool LUA_NATIVE_HUD_DOES_PED_HAVE_AI_BLIP( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)HUD::DOES_PED_HAVE_AI_BLIP(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_HUD_SET_PED_AI_BLIP_GANG_ID( int ped, int gangId) { invoke<void )
	{
		HUD::SET_PED_AI_BLIP_GANG_ID(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_AI_BLIP_HAS_CONE( int ped, bool toggle) { invoke<void )
	{
		HUD::SET_PED_AI_BLIP_HAS_CONE(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_AI_BLIP_FORCED_ON( int ped, bool toggle) { invoke<void )
	{
		HUD::SET_PED_AI_BLIP_FORCED_ON(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_AI_BLIP_NOTICE_RANGE( int ped, float range) { invoke<void )
	{
		HUD::SET_PED_AI_BLIP_NOTICE_RANGE(ped, invoke<void);
	}

	void LUA_NATIVE_HUD_SET_PED_AI_BLIP_SPRITE( int ped, int spriteId) { invoke<void )
	{
		HUD::SET_PED_AI_BLIP_SPRITE(ped, invoke<void);
	}

	int LUA_NATIVE_HUD_GET_AI_PED_PED_BLIP_INDEX( int ped) { return invoke<int )
	{
		auto retval = HUD::GET_AI_PED_PED_BLIP_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_HUD_GET_AI_PED_VEHICLE_BLIP_INDEX( int ped) { return invoke<int )
	{
		auto retval = HUD::GET_AI_PED_VEHICLE_BLIP_INDEX(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_HUD_HAS_DIRECTOR_MODE_BEEN_LAUNCHED_BY_CODE(  )
	{
		auto retval = (bool)HUD::HAS_DIRECTOR_MODE_BEEN_LAUNCHED_BY_CODE();
		return retval;
	}

	void LUA_NATIVE_HUD_SET_DIRECTOR_MODE_LAUNCHED_BY_SCRIPT(  )
	{
		HUD::SET_DIRECTOR_MODE_LAUNCHED_BY_SCRIPT();
	}

	void LUA_NATIVE_HUD_SET_PLAYER_IS_IN_DIRECTOR_MODE( bool toggle) { invoke<void )
	{
		HUD::SET_PLAYER_IS_IN_DIRECTOR_MODE(invoke<void);
	}

	void LUA_NATIVE_HUD_SET_DIRECTOR_MODE_AVAILABLE( bool toggle) { invoke<void )
	{
		HUD::SET_DIRECTOR_MODE_AVAILABLE(invoke<void);
	}

	void LUA_NATIVE_HUD_HIDE_HUDMARKERS_THIS_FRAME(  )
	{
		HUD::HIDE_HUDMARKERS_THIS_FRAME();
	}

	float LUA_NATIVE_INTERIOR_GET_INTERIOR_HEADING( int interior) { return invoke<float )
	{
		auto retval = INTERIOR::GET_INTERIOR_HEADING(invoke<float);
		return retval;
	}

	std::tuple<Vector3, unsigned nameHash) {> LUA_NATIVE_INTERIOR_GET_INTERIOR_LOCATION_AND_NAMEHASH( int interior, Vector3 position, unsigned nameHash) { invoke<void )
	{
		std::tuple<Vector3, unsigned nameHash) {> return_values;
		INTERIOR::GET_INTERIOR_LOCATION_AND_NAMEHASH(interior, &position, &invoke<void);
		std::get<0>(return_values) = position;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_GROUP_ID( int interior) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_GROUP_ID(invoke<int);
		return retval;
	}

	Vector3 LUA_NATIVE_INTERIOR_GET_OFFSET_FROM_INTERIOR_IN_WORLD_COORDS( int interior, float x, float y, float z) { return invoke<Vector3 )
	{
		auto retval = INTERIOR::GET_OFFSET_FROM_INTERIOR_IN_WORLD_COORDS(interior, x, y, invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_INTERIOR_IS_INTERIOR_SCENE(  )
	{
		auto retval = (bool)INTERIOR::IS_INTERIOR_SCENE();
		return retval;
	}

	bool LUA_NATIVE_INTERIOR_IS_VALID_INTERIOR( int interior) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_VALID_INTERIOR(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_CLEAR_ROOM_FOR_ENTITY( int entity) { invoke<void )
	{
		INTERIOR::CLEAR_ROOM_FOR_ENTITY(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_FORCE_ROOM_FOR_ENTITY( int entity, int interior, unsigned roomHashKey) { invoke<void )
	{
		INTERIOR::FORCE_ROOM_FOR_ENTITY(entity, interior, invoke<void);
	}

	unsigned LUA_NATIVE_INTERIOR_GET_ROOM_KEY_FROM_ENTITY( int entity) { return invoke<unsigned )
	{
		auto retval = INTERIOR::GET_ROOM_KEY_FROM_ENTITY(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_INTERIOR_GET_KEY_FOR_ENTITY_IN_ROOM( int entity) { return invoke<unsigned )
	{
		auto retval = INTERIOR::GET_KEY_FOR_ENTITY_IN_ROOM(invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_FROM_ENTITY( int entity) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_FROM_ENTITY(invoke<int);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_RETAIN_ENTITY_IN_INTERIOR( int entity, int interior) { invoke<void )
	{
		INTERIOR::RETAIN_ENTITY_IN_INTERIOR(entity, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_CLEAR_INTERIOR_STATE_OF_ENTITY( int entity) { invoke<void )
	{
		INTERIOR::CLEAR_INTERIOR_STATE_OF_ENTITY(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_FORCE_ACTIVATING_TRACKING_ON_ENTITY( Any p0, Any p1) { invoke<void )
	{
		INTERIOR::FORCE_ACTIVATING_TRACKING_ON_ENTITY(p0, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_FORCE_ROOM_FOR_GAME_VIEWPORT( int interiorID, unsigned roomHashKey) { invoke<void )
	{
		INTERIOR::FORCE_ROOM_FOR_GAME_VIEWPORT(interiorID, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_SET_ROOM_FOR_GAME_VIEWPORT_BY_NAME( const char* roomName) { invoke<void )
	{
		INTERIOR::SET_ROOM_FOR_GAME_VIEWPORT_BY_NAME(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_SET_ROOM_FOR_GAME_VIEWPORT_BY_KEY( unsigned roomHashKey) { invoke<void )
	{
		INTERIOR::SET_ROOM_FOR_GAME_VIEWPORT_BY_KEY(invoke<void);
	}

	unsigned LUA_NATIVE_INTERIOR_GET_ROOM_KEY_FOR_GAME_VIEWPORT(  )
	{
		auto retval = INTERIOR::GET_ROOM_KEY_FOR_GAME_VIEWPORT();
		return retval;
	}

	void LUA_NATIVE_INTERIOR_CLEAR_ROOM_FOR_GAME_VIEWPORT(  )
	{
		INTERIOR::CLEAR_ROOM_FOR_GAME_VIEWPORT();
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_FROM_PRIMARY_VIEW(  )
	{
		auto retval = INTERIOR::GET_INTERIOR_FROM_PRIMARY_VIEW();
		return retval;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_AT_COORDS( float x, float y, float z) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_AT_COORDS(x, y, invoke<int);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_ADD_PICKUP_TO_INTERIOR_ROOM_BY_NAME( int pickup, const char* roomName) { invoke<void )
	{
		INTERIOR::ADD_PICKUP_TO_INTERIOR_ROOM_BY_NAME(pickup, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_PIN_INTERIOR_IN_MEMORY( int interior) { invoke<void )
	{
		INTERIOR::PIN_INTERIOR_IN_MEMORY(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_UNPIN_INTERIOR( int interior) { invoke<void )
	{
		INTERIOR::UNPIN_INTERIOR(invoke<void);
	}

	bool LUA_NATIVE_INTERIOR_IS_INTERIOR_READY( int interior) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_INTERIOR_READY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_INTERIOR_SET_INTERIOR_IN_USE( int interior) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::SET_INTERIOR_IN_USE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_AT_COORDS_WITH_TYPE( float x, float y, float z, const char* interiorType) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_AT_COORDS_WITH_TYPE(x, y, z, invoke<int);
		return retval;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_AT_COORDS_WITH_TYPEHASH( float x, float y, float z, unsigned typeHash) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_AT_COORDS_WITH_TYPEHASH(x, y, z, invoke<int);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_ACTIVATE_INTERIOR_GROUPS_USING_CAMERA(  )
	{
		INTERIOR::ACTIVATE_INTERIOR_GROUPS_USING_CAMERA();
	}

	bool LUA_NATIVE_INTERIOR_IS_COLLISION_MARKED_OUTSIDE( float x, float y, float z) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_COLLISION_MARKED_OUTSIDE(x, y, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_INTERIOR_GET_INTERIOR_FROM_COLLISION( float x, float y, float z) { return invoke<int )
	{
		auto retval = INTERIOR::GET_INTERIOR_FROM_COLLISION(x, y, invoke<int);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_ENABLE_STADIUM_PROBES_THIS_FRAME( bool toggle) { invoke<void )
	{
		INTERIOR::ENABLE_STADIUM_PROBES_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_ACTIVATE_INTERIOR_ENTITY_SET( int interior, const char* entitySetName) { invoke<void )
	{
		INTERIOR::ACTIVATE_INTERIOR_ENTITY_SET(interior, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_DEACTIVATE_INTERIOR_ENTITY_SET( int interior, const char* entitySetName) { invoke<void )
	{
		INTERIOR::DEACTIVATE_INTERIOR_ENTITY_SET(interior, invoke<void);
	}

	bool LUA_NATIVE_INTERIOR_IS_INTERIOR_ENTITY_SET_ACTIVE( int interior, const char* entitySetName) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_INTERIOR_ENTITY_SET_ACTIVE(interior, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_SET_INTERIOR_ENTITY_SET_TINT_INDEX( int interior, const char* entitySetName, int color) { invoke<void )
	{
		INTERIOR::SET_INTERIOR_ENTITY_SET_TINT_INDEX(interior, entitySetName, invoke<void);
	}

	void LUA_NATIVE_INTERIOR_REFRESH_INTERIOR( int interior) { invoke<void )
	{
		INTERIOR::REFRESH_INTERIOR(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_ENABLE_EXTERIOR_CULL_MODEL_THIS_FRAME( unsigned mapObjectHash) { invoke<void )
	{
		INTERIOR::ENABLE_EXTERIOR_CULL_MODEL_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_ENABLE_SHADOW_CULL_MODEL_THIS_FRAME( unsigned mapObjectHash) { invoke<void )
	{
		INTERIOR::ENABLE_SHADOW_CULL_MODEL_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_DISABLE_INTERIOR( int interior, bool toggle) { invoke<void )
	{
		INTERIOR::DISABLE_INTERIOR(interior, invoke<void);
	}

	bool LUA_NATIVE_INTERIOR_IS_INTERIOR_DISABLED( int interior) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_INTERIOR_DISABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_CAP_INTERIOR( int interior, bool toggle) { invoke<void )
	{
		INTERIOR::CAP_INTERIOR(interior, invoke<void);
	}

	bool LUA_NATIVE_INTERIOR_IS_INTERIOR_CAPPED( int interior) { return invoke<BOOL )
	{
		auto retval = (bool)INTERIOR::IS_INTERIOR_CAPPED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_INTERIOR_DISABLE_METRO_SYSTEM( bool toggle) { invoke<void )
	{
		INTERIOR::DISABLE_METRO_SYSTEM(invoke<void);
	}

	void LUA_NATIVE_INTERIOR_SET_IS_EXTERIOR_ONLY( int entity, bool toggle) { invoke<void )
	{
		INTERIOR::SET_IS_EXTERIOR_ONLY(entity, invoke<void);
	}

	int LUA_NATIVE_ITEMSET_CREATE_ITEMSET( bool p0) { return invoke<int )
	{
		auto retval = ITEMSET::CREATE_ITEMSET(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ITEMSET_DESTROY_ITEMSET( int itemset) { invoke<void )
	{
		ITEMSET::DESTROY_ITEMSET(invoke<void);
	}

	bool LUA_NATIVE_ITEMSET_IS_ITEMSET_VALID( int itemset) { return invoke<BOOL )
	{
		auto retval = (bool)ITEMSET::IS_ITEMSET_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_ITEMSET_ADD_TO_ITEMSET( int item, int itemset) { return invoke<BOOL )
	{
		auto retval = (bool)ITEMSET::ADD_TO_ITEMSET(item, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ITEMSET_REMOVE_FROM_ITEMSET( int item, int itemset) { invoke<void )
	{
		ITEMSET::REMOVE_FROM_ITEMSET(item, invoke<void);
	}

	int LUA_NATIVE_ITEMSET_GET_ITEMSET_SIZE( int itemset) { return invoke<int )
	{
		auto retval = ITEMSET::GET_ITEMSET_SIZE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ITEMSET_GET_INDEXED_ITEM_IN_ITEMSET( int index, int itemset) { return invoke<int )
	{
		auto retval = ITEMSET::GET_INDEXED_ITEM_IN_ITEMSET(index, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_ITEMSET_IS_IN_ITEMSET( int item, int itemset) { return invoke<BOOL )
	{
		auto retval = (bool)ITEMSET::IS_IN_ITEMSET(item, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_ITEMSET_CLEAN_ITEMSET( int itemset) { invoke<void )
	{
		ITEMSET::CLEAN_ITEMSET(invoke<void);
	}

	bool LUA_NATIVE_LOADINGSCREEN_LOBBY_AUTO_MULTIPLAYER_MENU(  )
	{
		auto retval = (bool)LOADINGSCREEN::LOBBY_AUTO_MULTIPLAYER_MENU();
		return retval;
	}

	bool LUA_NATIVE_LOADINGSCREEN_LOBBY_AUTO_MULTIPLAYER_FREEMODE(  )
	{
		auto retval = (bool)LOADINGSCREEN::LOBBY_AUTO_MULTIPLAYER_FREEMODE();
		return retval;
	}

	void LUA_NATIVE_LOADINGSCREEN_LOBBY_SET_AUTO_MULTIPLAYER( bool toggle) { invoke<void )
	{
		LOADINGSCREEN::LOBBY_SET_AUTO_MULTIPLAYER(invoke<void);
	}

	bool LUA_NATIVE_LOADINGSCREEN_LOBBY_AUTO_MULTIPLAYER_EVENT(  )
	{
		auto retval = (bool)LOADINGSCREEN::LOBBY_AUTO_MULTIPLAYER_EVENT();
		return retval;
	}

	void LUA_NATIVE_LOADINGSCREEN_LOBBY_SET_AUTO_MULTIPLAYER_EVENT( bool toggle) { invoke<void )
	{
		LOADINGSCREEN::LOBBY_SET_AUTO_MULTIPLAYER_EVENT(invoke<void);
	}

	bool LUA_NATIVE_LOADINGSCREEN_LOBBY_AUTO_MULTIPLAYER_RANDOM_JOB(  )
	{
		auto retval = (bool)LOADINGSCREEN::LOBBY_AUTO_MULTIPLAYER_RANDOM_JOB();
		return retval;
	}

	void LUA_NATIVE_LOADINGSCREEN_LOBBY_SET_AUTO_MP_RANDOM_JOB( bool toggle) { invoke<void )
	{
		LOADINGSCREEN::LOBBY_SET_AUTO_MP_RANDOM_JOB(invoke<void);
	}

	void LUA_NATIVE_LOADINGSCREEN_SHUTDOWN_SESSION_CLEARS_AUTO_MULTIPLAYER( bool toggle) { invoke<void )
	{
		LOADINGSCREEN::SHUTDOWN_SESSION_CLEARS_AUTO_MULTIPLAYER(invoke<void);
	}

	int LUA_NATIVE_LOCALIZATION_LOCALIZATION_GET_SYSTEM_LANGUAGE(  )
	{
		auto retval = LOCALIZATION::LOCALIZATION_GET_SYSTEM_LANGUAGE();
		return retval;
	}

	int LUA_NATIVE_LOCALIZATION_GET_CURRENT_LANGUAGE(  )
	{
		auto retval = LOCALIZATION::GET_CURRENT_LANGUAGE();
		return retval;
	}

	int LUA_NATIVE_LOCALIZATION_LOCALIZATION_GET_SYSTEM_DATE_TYPE(  )
	{
		auto retval = LOCALIZATION::LOCALIZATION_GET_SYSTEM_DATE_TYPE();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_ALLOCATED_STACK_SIZE(  )
	{
		auto retval = MISC::GET_ALLOCATED_STACK_SIZE();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_NUMBER_OF_FREE_STACKS_OF_THIS_SIZE( int stackSize) { return invoke<int )
	{
		auto retval = MISC::GET_NUMBER_OF_FREE_STACKS_OF_THIS_SIZE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_SET_RANDOM_SEED( int seed) { invoke<void )
	{
		MISC::SET_RANDOM_SEED(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_TIME_SCALE( float timeScale) { invoke<void )
	{
		MISC::SET_TIME_SCALE(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_MISSION_FLAG( bool toggle) { invoke<void )
	{
		MISC::SET_MISSION_FLAG(invoke<void);
	}

	bool LUA_NATIVE_MISC_GET_MISSION_FLAG(  )
	{
		auto retval = (bool)MISC::GET_MISSION_FLAG();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_RANDOM_EVENT_FLAG( bool toggle) { invoke<void )
	{
		MISC::SET_RANDOM_EVENT_FLAG(invoke<void);
	}

	bool LUA_NATIVE_MISC_GET_RANDOM_EVENT_FLAG(  )
	{
		auto retval = (bool)MISC::GET_RANDOM_EVENT_FLAG();
		return retval;
	}

	const char* LUA_NATIVE_MISC_GET_CONTENT_TO_LOAD(  )
	{
		auto retval = MISC::GET_CONTENT_TO_LOAD();
		return retval;
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_CREATE( const char* p0, const char* p1) { invoke<void )
	{
		MISC::ACTIVITY_FEED_CREATE(p0, invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ADD_SUBSTRING_TO_CAPTION( const char* p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ADD_SUBSTRING_TO_CAPTION(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ADD_LITERAL_SUBSTRING_TO_CAPTION( const char* p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ADD_LITERAL_SUBSTRING_TO_CAPTION(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ADD_INT_TO_CAPTION( Any p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ADD_INT_TO_CAPTION(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_LARGE_IMAGE_URL( const char* p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_LARGE_IMAGE_URL(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ACTION_START_WITH_COMMAND_LINE( const char* p0, const char* p1) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ACTION_START_WITH_COMMAND_LINE(p0, invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ACTION_START_WITH_COMMAND_LINE_ADD( const char* p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ACTION_START_WITH_COMMAND_LINE_ADD(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_POST(  )
	{
		MISC::ACTIVITY_FEED_POST();
	}

	void LUA_NATIVE_MISC_ACTIVITY_FEED_ONLINE_PLAYED_WITH_POST( const char* p0) { invoke<void )
	{
		MISC::ACTIVITY_FEED_ONLINE_PLAYED_WITH_POST(invoke<void);
	}

	bool LUA_NATIVE_MISC_HAS_RESUMED_FROM_SUSPEND(  )
	{
		auto retval = (bool)MISC::HAS_RESUMED_FROM_SUSPEND();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_SCRIPT_HIGH_PRIO( bool toggle) { invoke<void )
	{
		MISC::SET_SCRIPT_HIGH_PRIO(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_THIS_IS_A_TRIGGER_SCRIPT( bool toggle) { invoke<void )
	{
		MISC::SET_THIS_IS_A_TRIGGER_SCRIPT(invoke<void);
	}

	void LUA_NATIVE_MISC_INFORM_CODE_OF_CONTENT_ID_OF_CURRENT_UGC_MISSION( const char* p0) { invoke<void )
	{
		MISC::INFORM_CODE_OF_CONTENT_ID_OF_CURRENT_UGC_MISSION(invoke<void);
	}

	std::tuple<bool, Any, Any> LUA_NATIVE_MISC_GET_BASE_ELEMENT_LOCATION_FROM_METADATA_BLOCK( Any p0, Any p1, Any p2, bool p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_BASE_ELEMENT_LOCATION_FROM_METADATA_BLOCK(&p0, &p1, p2, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;

		return return_values;
	}

	unsigned LUA_NATIVE_MISC_GET_PREV_WEATHER_TYPE_HASH_NAME(  )
	{
		auto retval = MISC::GET_PREV_WEATHER_TYPE_HASH_NAME();
		return retval;
	}

	unsigned LUA_NATIVE_MISC_GET_NEXT_WEATHER_TYPE_HASH_NAME(  )
	{
		auto retval = MISC::GET_NEXT_WEATHER_TYPE_HASH_NAME();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PREV_WEATHER_TYPE( const char* weatherType) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_PREV_WEATHER_TYPE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_NEXT_WEATHER_TYPE( const char* weatherType) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_NEXT_WEATHER_TYPE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_SET_WEATHER_TYPE_PERSIST( const char* weatherType) { invoke<void )
	{
		MISC::SET_WEATHER_TYPE_PERSIST(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_WEATHER_TYPE_NOW_PERSIST( const char* weatherType) { invoke<void )
	{
		MISC::SET_WEATHER_TYPE_NOW_PERSIST(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_WEATHER_TYPE_NOW( const char* weatherType) { invoke<void )
	{
		MISC::SET_WEATHER_TYPE_NOW(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_WEATHER_TYPE_OVERTIME_PERSIST( const char* weatherType, float time) { invoke<void )
	{
		MISC::SET_WEATHER_TYPE_OVERTIME_PERSIST(weatherType, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_RANDOM_WEATHER_TYPE(  )
	{
		MISC::SET_RANDOM_WEATHER_TYPE();
	}

	void LUA_NATIVE_MISC_CLEAR_WEATHER_TYPE_PERSIST(  )
	{
		MISC::CLEAR_WEATHER_TYPE_PERSIST();
	}

	void LUA_NATIVE_MISC_CLEAR_WEATHER_TYPE_NOW_PERSIST_NETWORK( int milliseconds) { invoke<void )
	{
		MISC::CLEAR_WEATHER_TYPE_NOW_PERSIST_NETWORK(invoke<void);
	}

	std::tuple<unsigned, unsigned, float percentWeather2) {> LUA_NATIVE_MISC_GET_CURR_WEATHER_STATE( unsigned weatherType1, unsigned weatherType2, float percentWeather2) { invoke<void )
	{
		std::tuple<unsigned, unsigned, float percentWeather2) {> return_values;
		MISC::GET_CURR_WEATHER_STATE(&weatherType1, &weatherType2, &invoke<void);
		std::get<0>(return_values) = weatherType1;
		std::get<1>(return_values) = weatherType2;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_MISC_SET_CURR_WEATHER_STATE( unsigned weatherType1, unsigned weatherType2, float percentWeather2) { invoke<void )
	{
		MISC::SET_CURR_WEATHER_STATE(weatherType1, weatherType2, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_OVERRIDE_WEATHER( const char* weatherType) { invoke<void )
	{
		MISC::SET_OVERRIDE_WEATHER(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_OVERRIDE_WEATHEREX( const char* weatherType, bool p1) { invoke<void )
	{
		MISC::SET_OVERRIDE_WEATHEREX(weatherType, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_OVERRIDE_WEATHER(  )
	{
		MISC::CLEAR_OVERRIDE_WEATHER();
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_SHOREWAVEAMPLITUDE( float amplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_SHOREWAVEAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_SHOREWAVEMINAMPLITUDE( float minAmplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_SHOREWAVEMINAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_SHOREWAVEMAXAMPLITUDE( float maxAmplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_SHOREWAVEMAXAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_OCEANNOISEMINAMPLITUDE( float minAmplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_OCEANNOISEMINAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_OCEANWAVEAMPLITUDE( float amplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_OCEANWAVEAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_OCEANWAVEMINAMPLITUDE( float minAmplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_OCEANWAVEMINAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_OCEANWAVEMAXAMPLITUDE( float maxAmplitude) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_OCEANWAVEMAXAMPLITUDE(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_RIPPLEBUMPINESS( float bumpiness) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_RIPPLEBUMPINESS(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_RIPPLEMINBUMPINESS( float minBumpiness) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_RIPPLEMINBUMPINESS(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_RIPPLEMAXBUMPINESS( float maxBumpiness) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_RIPPLEMAXBUMPINESS(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_RIPPLEDISTURB( float disturb) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_RIPPLEDISTURB(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_SET_STRENGTH( float strength) { invoke<void )
	{
		MISC::WATER_OVERRIDE_SET_STRENGTH(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_FADE_IN( float p0) { invoke<void )
	{
		MISC::WATER_OVERRIDE_FADE_IN(invoke<void);
	}

	void LUA_NATIVE_MISC_WATER_OVERRIDE_FADE_OUT( float p0) { invoke<void )
	{
		MISC::WATER_OVERRIDE_FADE_OUT(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_WIND( float speed) { invoke<void )
	{
		MISC::SET_WIND(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_WIND_SPEED( float speed) { invoke<void )
	{
		MISC::SET_WIND_SPEED(invoke<void);
	}

	float LUA_NATIVE_MISC_GET_WIND_SPEED(  )
	{
		auto retval = MISC::GET_WIND_SPEED();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_WIND_DIRECTION( float direction) { invoke<void )
	{
		MISC::SET_WIND_DIRECTION(invoke<void);
	}

	Vector3 LUA_NATIVE_MISC_GET_WIND_DIRECTION(  )
	{
		auto retval = MISC::GET_WIND_DIRECTION();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_RAIN( float intensity) { invoke<void )
	{
		MISC::SET_RAIN(invoke<void);
	}

	float LUA_NATIVE_MISC_GET_RAIN_LEVEL(  )
	{
		auto retval = MISC::GET_RAIN_LEVEL();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_SNOW( float level) { invoke<void )
	{
		MISC::SET_SNOW(invoke<void);
	}

	float LUA_NATIVE_MISC_GET_SNOW_LEVEL(  )
	{
		auto retval = MISC::GET_SNOW_LEVEL();
		return retval;
	}

	void LUA_NATIVE_MISC_FORCE_LIGHTNING_FLASH(  )
	{
		MISC::FORCE_LIGHTNING_FLASH();
	}

	void LUA_NATIVE_MISC_SET_CLOUD_SETTINGS_OVERRIDE( const char* p0) { invoke<void )
	{
		MISC::SET_CLOUD_SETTINGS_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_MISC_PRELOAD_CLOUD_HAT( const char* name) { invoke<void )
	{
		MISC::PRELOAD_CLOUD_HAT(invoke<void);
	}

	void LUA_NATIVE_MISC_LOAD_CLOUD_HAT( const char* name, float transitionTime) { invoke<void )
	{
		MISC::LOAD_CLOUD_HAT(name, invoke<void);
	}

	void LUA_NATIVE_MISC_UNLOAD_CLOUD_HAT( const char* name, float p1) { invoke<void )
	{
		MISC::UNLOAD_CLOUD_HAT(name, invoke<void);
	}

	void LUA_NATIVE_MISC_UNLOAD_ALL_CLOUD_HATS(  )
	{
		MISC::UNLOAD_ALL_CLOUD_HATS();
	}

	void LUA_NATIVE_MISC_SET_CLOUDS_ALPHA( float opacity) { invoke<void )
	{
		MISC::SET_CLOUDS_ALPHA(invoke<void);
	}

	float LUA_NATIVE_MISC_GET_CLOUDS_ALPHA(  )
	{
		auto retval = MISC::GET_CLOUDS_ALPHA();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_GAME_TIMER(  )
	{
		auto retval = MISC::GET_GAME_TIMER();
		return retval;
	}

	float LUA_NATIVE_MISC_GET_FRAME_TIME(  )
	{
		auto retval = MISC::GET_FRAME_TIME();
		return retval;
	}

	float LUA_NATIVE_MISC_GET_SYSTEM_TIME_STEP(  )
	{
		auto retval = MISC::GET_SYSTEM_TIME_STEP();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_FRAME_COUNT(  )
	{
		auto retval = MISC::GET_FRAME_COUNT();
		return retval;
	}

	float LUA_NATIVE_MISC_GET_RANDOM_FLOAT_IN_RANGE( float startRange, float endRange) { return invoke<float )
	{
		auto retval = MISC::GET_RANDOM_FLOAT_IN_RANGE(startRange, invoke<float);
		return retval;
	}

	int LUA_NATIVE_MISC_GET_RANDOM_INT_IN_RANGE( int startRange, int endRange) { return invoke<int )
	{
		auto retval = MISC::GET_RANDOM_INT_IN_RANGE(startRange, invoke<int);
		return retval;
	}

	int LUA_NATIVE_MISC_GET_RANDOM_MWC_INT_IN_RANGE( int startRange, int endRange) { return invoke<int )
	{
		auto retval = MISC::GET_RANDOM_MWC_INT_IN_RANGE(startRange, invoke<int);
		return retval;
	}

	std::tuple<bool, float> LUA_NATIVE_MISC_GET_GROUND_Z_FOR_3D_COORD( float x, float y, float z, float groundZ, bool ignoreWater, bool p5) { return invoke<BOOL )
	{
		std::tuple<bool, float> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_GROUND_Z_FOR_3D_COORD(x, y, z, &groundZ, ignoreWater, invoke<BOOL);
		std::get<1>(return_values) = groundZ;

		return return_values;
	}

	std::tuple<bool, float, Vector3 normal) { return> LUA_NATIVE_MISC_GET_GROUND_Z_AND_NORMAL_FOR_3D_COORD( float x, float y, float z, float groundZ, Vector3 normal) { return invoke<BOOL )
	{
		std::tuple<bool, float, Vector3 normal) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_GROUND_Z_AND_NORMAL_FOR_3D_COORD(x, y, z, &groundZ, &invoke<BOOL);
		std::get<1>(return_values) = groundZ;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float> LUA_NATIVE_MISC_GET_GROUND_Z_EXCLUDING_OBJECTS_FOR_3D_COORD( float x, float y, float z, float groundZ, bool p4, bool p5) { return invoke<BOOL )
	{
		std::tuple<bool, float> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_GROUND_Z_EXCLUDING_OBJECTS_FOR_3D_COORD(x, y, z, &groundZ, p4, invoke<BOOL);
		std::get<1>(return_values) = groundZ;

		return return_values;
	}

	float LUA_NATIVE_MISC_ASIN( float p0) { return invoke<float )
	{
		auto retval = MISC::ASIN(invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_ACOS( float p0) { return invoke<float )
	{
		auto retval = MISC::ACOS(invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_TAN( float p0) { return invoke<float )
	{
		auto retval = MISC::TAN(invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_ATAN( float p0) { return invoke<float )
	{
		auto retval = MISC::ATAN(invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_ATAN2( float p0, float p1) { return invoke<float )
	{
		auto retval = MISC::ATAN2(p0, invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_GET_DISTANCE_BETWEEN_COORDS( float x1, float y1, float z1, float x2, float y2, float z2, bool useZ) { return invoke<float )
	{
		auto retval = MISC::GET_DISTANCE_BETWEEN_COORDS(x1, y1, z1, x2, y2, z2, invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_GET_ANGLE_BETWEEN_2D_VECTORS( float x1, float y1, float x2, float y2) { return invoke<float )
	{
		auto retval = MISC::GET_ANGLE_BETWEEN_2D_VECTORS(x1, y1, x2, invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_GET_HEADING_FROM_VECTOR_2D( float dx, float dy) { return invoke<float )
	{
		auto retval = MISC::GET_HEADING_FROM_VECTOR_2D(dx, invoke<float);
		return retval;
	}

	float LUA_NATIVE_MISC_GET_RATIO_OF_CLOSEST_POINT_ON_LINE( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, bool clamp) { return invoke<float )
	{
		auto retval = MISC::GET_RATIO_OF_CLOSEST_POINT_ON_LINE(x1, y1, z1, x2, y2, z2, x3, y3, z3, invoke<float);
		return retval;
	}

	Vector3 LUA_NATIVE_MISC_GET_CLOSEST_POINT_ON_LINE( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, bool clamp) { return invoke<Vector3 )
	{
		auto retval = MISC::GET_CLOSEST_POINT_ON_LINE(x1, y1, z1, x2, y2, z2, x3, y3, z3, invoke<Vector3);
		return retval;
	}

	std::tuple<bool, float p12) { return> LUA_NATIVE_MISC_GET_LINE_PLANE_INTERSECTION( float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12) { return invoke<BOOL )
	{
		std::tuple<bool, float p12) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_LINE_PLANE_INTERSECTION(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_MISC_GET_POINT_AREA_OVERLAP( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12, Any p13) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::GET_POINT_AREA_OVERLAP(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_MISC_SET_BIT( int address, int offset) { invoke<void )
	{
		MISC::SET_BIT(&address, invoke<void);
		return address;
	}

	int LUA_NATIVE_MISC_CLEAR_BIT( int address, int offset) { invoke<void )
	{
		MISC::CLEAR_BIT(&address, invoke<void);
		return address;
	}

	unsigned LUA_NATIVE_MISC_GET_HASH_KEY( const char* string) { return invoke<unsigned )
	{
		auto retval = MISC::GET_HASH_KEY(invoke<unsigned);
		return retval;
	}

	std::tuple<float, float, float, float outW) {> LUA_NATIVE_MISC_SLERP_NEAR_QUATERNION( float t, float x, float y, float z, float w, float x1, float y1, float z1, float w1, float outX, float outY, float outZ, float outW) { invoke<void )
	{
		std::tuple<float, float, float, float outW) {> return_values;
		MISC::SLERP_NEAR_QUATERNION(t, x, y, z, w, x1, y1, z1, w1, &outX, &outY, &outZ, &invoke<void);
		std::get<0>(return_values) = outX;
		std::get<1>(return_values) = outY;
		std::get<2>(return_values) = outZ;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	bool LUA_NATIVE_MISC_IS_AREA_OCCUPIED( float p0, float p1, float p2, float p3, float p4, float p5, bool p6, bool p7, bool p8, bool p9, bool p10, Any p11, bool p12) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_AREA_OCCUPIED(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_AREA_OCCUPIED_SLOW( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_AREA_OCCUPIED_SLOW(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_POSITION_OCCUPIED( float x, float y, float z, float range, bool p4, bool checkVehicles, bool checkPeds, bool p7, bool p8, int ignoreEntity, bool p10) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_POSITION_OCCUPIED(x, y, z, range, p4, checkVehicles, checkPeds, p7, p8, ignoreEntity, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_POINT_OBSCURED_BY_A_MISSION_ENTITY( float p0, float p1, float p2, float p3, float p4, float p5, Any p6) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_POINT_OBSCURED_BY_A_MISSION_ENTITY(p0, p1, p2, p3, p4, p5, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_CLEAR_AREA( float X, float Y, float Z, float radius, bool p4, bool ignoreCopCars, bool ignoreObjects, bool p7) { invoke<void )
	{
		MISC::CLEAR_AREA(X, Y, Z, radius, p4, ignoreCopCars, ignoreObjects, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_LEAVE_VEHICLE_HEALTH( float x, float y, float z, float radius, bool p4, bool p5, bool p6, bool p7) { invoke<void )
	{
		MISC::CLEAR_AREA_LEAVE_VEHICLE_HEALTH(x, y, z, radius, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_OF_VEHICLES( float x, float y, float z, float radius, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, Any p10) { invoke<void )
	{
		MISC::CLEAR_AREA_OF_VEHICLES(x, y, z, radius, p4, p5, p6, p7, p8, p9, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_ANGLED_AREA_OF_VEHICLES( float x1, float y1, float z1, float x2, float y2, float z2, float width, bool p7, bool p8, bool p9, bool p10, bool p11, Any p12, Any p13) { invoke<void )
	{
		MISC::CLEAR_ANGLED_AREA_OF_VEHICLES(x1, y1, z1, x2, y2, z2, width, p7, p8, p9, p10, p11, p12, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_OF_OBJECTS( float x, float y, float z, float radius, int flags) { invoke<void )
	{
		MISC::CLEAR_AREA_OF_OBJECTS(x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_OF_PEDS( float x, float y, float z, float radius, int flags) { invoke<void )
	{
		MISC::CLEAR_AREA_OF_PEDS(x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_OF_COPS( float x, float y, float z, float radius, int flags) { invoke<void )
	{
		MISC::CLEAR_AREA_OF_COPS(x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_AREA_OF_PROJECTILES( float x, float y, float z, float radius, int flags) { invoke<void )
	{
		MISC::CLEAR_AREA_OF_PROJECTILES(x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_SCENARIO_SPAWN_HISTORY(  )
	{
		MISC::CLEAR_SCENARIO_SPAWN_HISTORY();
	}

	void LUA_NATIVE_MISC_SET_SAVE_MENU_ACTIVE( bool ignoreVehicle) { invoke<void )
	{
		MISC::SET_SAVE_MENU_ACTIVE(invoke<void);
	}

	int LUA_NATIVE_MISC_GET_STATUS_OF_MANUAL_SAVE(  )
	{
		auto retval = MISC::GET_STATUS_OF_MANUAL_SAVE();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_CREDITS_ACTIVE( bool toggle) { invoke<void )
	{
		MISC::SET_CREDITS_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_CREDITS_FADE_OUT_WITH_SCREEN( bool toggle) { invoke<void )
	{
		MISC::SET_CREDITS_FADE_OUT_WITH_SCREEN(invoke<void);
	}

	bool LUA_NATIVE_MISC_HAVE_CREDITS_REACHED_END(  )
	{
		auto retval = (bool)MISC::HAVE_CREDITS_REACHED_END();
		return retval;
	}

	bool LUA_NATIVE_MISC_ARE_CREDITS_RUNNING(  )
	{
		auto retval = (bool)MISC::ARE_CREDITS_RUNNING();
		return retval;
	}

	void LUA_NATIVE_MISC_TERMINATE_ALL_SCRIPTS_WITH_THIS_NAME( const char* scriptName) { invoke<void )
	{
		MISC::TERMINATE_ALL_SCRIPTS_WITH_THIS_NAME(invoke<void);
	}

	void LUA_NATIVE_MISC_NETWORK_SET_SCRIPT_IS_SAFE_FOR_NETWORK_GAME(  )
	{
		MISC::NETWORK_SET_SCRIPT_IS_SAFE_FOR_NETWORK_GAME();
	}

	int LUA_NATIVE_MISC_ADD_HOSPITAL_RESTART( float x, float y, float z, float p3, Any p4) { return invoke<int )
	{
		auto retval = MISC::ADD_HOSPITAL_RESTART(x, y, z, p3, invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_DISABLE_HOSPITAL_RESTART( int hospitalIndex, bool toggle) { invoke<void )
	{
		MISC::DISABLE_HOSPITAL_RESTART(hospitalIndex, invoke<void);
	}

	int LUA_NATIVE_MISC_ADD_POLICE_RESTART( float p0, float p1, float p2, float p3, Any p4) { return invoke<int )
	{
		auto retval = MISC::ADD_POLICE_RESTART(p0, p1, p2, p3, invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_DISABLE_POLICE_RESTART( int policeIndex, bool toggle) { invoke<void )
	{
		MISC::DISABLE_POLICE_RESTART(policeIndex, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_RESTART_COORD_OVERRIDE( float x, float y, float z, float heading) { invoke<void )
	{
		MISC::SET_RESTART_COORD_OVERRIDE(x, y, z, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_RESTART_COORD_OVERRIDE(  )
	{
		MISC::CLEAR_RESTART_COORD_OVERRIDE();
	}

	void LUA_NATIVE_MISC_PAUSE_DEATH_ARREST_RESTART( bool toggle) { invoke<void )
	{
		MISC::PAUSE_DEATH_ARREST_RESTART(invoke<void);
	}

	void LUA_NATIVE_MISC_IGNORE_NEXT_RESTART( bool toggle) { invoke<void )
	{
		MISC::IGNORE_NEXT_RESTART(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FADE_OUT_AFTER_DEATH( bool toggle) { invoke<void )
	{
		MISC::SET_FADE_OUT_AFTER_DEATH(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FADE_OUT_AFTER_ARREST( bool toggle) { invoke<void )
	{
		MISC::SET_FADE_OUT_AFTER_ARREST(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FADE_IN_AFTER_DEATH_ARREST( bool toggle) { invoke<void )
	{
		MISC::SET_FADE_IN_AFTER_DEATH_ARREST(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FADE_IN_AFTER_LOAD( bool toggle) { invoke<void )
	{
		MISC::SET_FADE_IN_AFTER_LOAD(invoke<void);
	}

	int LUA_NATIVE_MISC_REGISTER_SAVE_HOUSE( float x, float y, float z, float p3, const char* p4, Any p5, Any p6) { return invoke<int )
	{
		auto retval = MISC::REGISTER_SAVE_HOUSE(x, y, z, p3, p4, p5, invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_SET_SAVE_HOUSE( int savehouseHandle, bool p1, bool p2) { invoke<void )
	{
		MISC::SET_SAVE_HOUSE(savehouseHandle, p1, invoke<void);
	}

	bool LUA_NATIVE_MISC_OVERRIDE_SAVE_HOUSE( bool p0, float p1, float p2, float p3, float p4, bool p5, float p6, float p7) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::OVERRIDE_SAVE_HOUSE(p0, p1, p2, p3, p4, p5, p6, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Vector3, float, bool, bool p3) { return> LUA_NATIVE_MISC_GET_SAVE_HOUSE_DETAILS_AFTER_SUCCESSFUL_LOAD( Vector3 p0, float p1, bool fadeInAfterLoad, bool p3) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, float, bool, bool p3) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_SAVE_HOUSE_DETAILS_AFTER_SUCCESSFUL_LOAD(&p0, &p1, (BOOL*)&fadeInAfterLoad, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;
		std::get<3>(return_values) = fadeInAfterLoad;
		std::get<4>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_MISC_DO_AUTO_SAVE(  )
	{
		MISC::DO_AUTO_SAVE();
	}

	bool LUA_NATIVE_MISC_GET_IS_AUTO_SAVE_OFF(  )
	{
		auto retval = (bool)MISC::GET_IS_AUTO_SAVE_OFF();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_AUTO_SAVE_IN_PROGRESS(  )
	{
		auto retval = (bool)MISC::IS_AUTO_SAVE_IN_PROGRESS();
		return retval;
	}

	bool LUA_NATIVE_MISC_HAS_CODE_REQUESTED_AUTOSAVE(  )
	{
		auto retval = (bool)MISC::HAS_CODE_REQUESTED_AUTOSAVE();
		return retval;
	}

	void LUA_NATIVE_MISC_CLEAR_CODE_REQUESTED_AUTOSAVE(  )
	{
		MISC::CLEAR_CODE_REQUESTED_AUTOSAVE();
	}

	void LUA_NATIVE_MISC_BEGIN_REPLAY_STATS( Any p0, Any p1) { invoke<void )
	{
		MISC::BEGIN_REPLAY_STATS(p0, invoke<void);
	}

	void LUA_NATIVE_MISC_ADD_REPLAY_STAT_VALUE( Any value) { invoke<void )
	{
		MISC::ADD_REPLAY_STAT_VALUE(invoke<void);
	}

	void LUA_NATIVE_MISC_END_REPLAY_STATS(  )
	{
		MISC::END_REPLAY_STATS();
	}

	bool LUA_NATIVE_MISC_HAVE_REPLAY_STATS_BEEN_STORED(  )
	{
		auto retval = (bool)MISC::HAVE_REPLAY_STATS_BEEN_STORED();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_REPLAY_STAT_MISSION_ID(  )
	{
		auto retval = MISC::GET_REPLAY_STAT_MISSION_ID();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_REPLAY_STAT_MISSION_TYPE(  )
	{
		auto retval = MISC::GET_REPLAY_STAT_MISSION_TYPE();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_REPLAY_STAT_COUNT(  )
	{
		auto retval = MISC::GET_REPLAY_STAT_COUNT();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_REPLAY_STAT_AT_INDEX( int index) { return invoke<int )
	{
		auto retval = MISC::GET_REPLAY_STAT_AT_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_CLEAR_REPLAY_STATS(  )
	{
		MISC::CLEAR_REPLAY_STATS();
	}

	bool LUA_NATIVE_MISC_QUEUE_MISSION_REPEAT_LOAD(  )
	{
		auto retval = (bool)MISC::QUEUE_MISSION_REPEAT_LOAD();
		return retval;
	}

	bool LUA_NATIVE_MISC_QUEUE_MISSION_REPEAT_SAVE(  )
	{
		auto retval = (bool)MISC::QUEUE_MISSION_REPEAT_SAVE();
		return retval;
	}

	bool LUA_NATIVE_MISC_QUEUE_MISSION_REPEAT_SAVE_FOR_BENCHMARK_TEST(  )
	{
		auto retval = (bool)MISC::QUEUE_MISSION_REPEAT_SAVE_FOR_BENCHMARK_TEST();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_STATUS_OF_MISSION_REPEAT_SAVE(  )
	{
		auto retval = MISC::GET_STATUS_OF_MISSION_REPEAT_SAVE();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_MEMORY_CARD_IN_USE(  )
	{
		auto retval = (bool)MISC::IS_MEMORY_CARD_IN_USE();
		return retval;
	}

	void LUA_NATIVE_MISC_SHOOT_SINGLE_BULLET_BETWEEN_COORDS( float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, unsigned weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed) { invoke<void )
	{
		MISC::SHOOT_SINGLE_BULLET_BETWEEN_COORDS(x1, y1, z1, x2, y2, z2, damage, p7, weaponHash, ownerPed, isAudible, isInvisible, invoke<void);
	}

	void LUA_NATIVE_MISC_SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY( float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, unsigned weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed, int entity, Any p14) { invoke<void )
	{
		MISC::SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY(x1, y1, z1, x2, y2, z2, damage, p7, weaponHash, ownerPed, isAudible, isInvisible, speed, entity, invoke<void);
	}

	void LUA_NATIVE_MISC_SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW( float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, unsigned weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed, int entity, bool p14, bool p15, int targetEntity, bool p17, Any p18, Any p19, Any p20) { invoke<void )
	{
		MISC::SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW(x1, y1, z1, x2, y2, z2, damage, p7, weaponHash, ownerPed, isAudible, isInvisible, speed, entity, p14, p15, targetEntity, p17, p18, p19, invoke<void);
	}

	std::tuple<Vector3, Vector3 maximum) {> LUA_NATIVE_MISC_GET_MODEL_DIMENSIONS( unsigned modelHash, Vector3 minimum, Vector3 maximum) { invoke<void )
	{
		std::tuple<Vector3, Vector3 maximum) {> return_values;
		MISC::GET_MODEL_DIMENSIONS(modelHash, &minimum, &invoke<void);
		std::get<0>(return_values) = minimum;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_MISC_SET_FAKE_WANTED_LEVEL( int fakeWantedLevel) { invoke<void )
	{
		MISC::SET_FAKE_WANTED_LEVEL(invoke<void);
	}

	int LUA_NATIVE_MISC_GET_FAKE_WANTED_LEVEL(  )
	{
		auto retval = MISC::GET_FAKE_WANTED_LEVEL();
		return retval;
	}

	void LUA_NATIVE_MISC_USING_MISSION_CREATOR( bool toggle) { invoke<void )
	{
		MISC::USING_MISSION_CREATOR(invoke<void);
	}

	void LUA_NATIVE_MISC_ALLOW_MISSION_CREATOR_WARP( bool toggle) { invoke<void )
	{
		MISC::ALLOW_MISSION_CREATOR_WARP(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_MINIGAME_IN_PROGRESS( bool toggle) { invoke<void )
	{
		MISC::SET_MINIGAME_IN_PROGRESS(invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_MINIGAME_IN_PROGRESS(  )
	{
		auto retval = (bool)MISC::IS_MINIGAME_IN_PROGRESS();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_THIS_A_MINIGAME_SCRIPT(  )
	{
		auto retval = (bool)MISC::IS_THIS_A_MINIGAME_SCRIPT();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_SNIPER_INVERTED(  )
	{
		auto retval = (bool)MISC::IS_SNIPER_INVERTED();
		return retval;
	}

	bool LUA_NATIVE_MISC_SHOULD_USE_METRIC_MEASUREMENTS(  )
	{
		auto retval = (bool)MISC::SHOULD_USE_METRIC_MEASUREMENTS();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_PROFILE_SETTING( int profileSetting) { return invoke<int )
	{
		auto retval = MISC::GET_PROFILE_SETTING(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_MISC_ARE_STRINGS_EQUAL( const char* string1, const char* string2) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::ARE_STRINGS_EQUAL(string1, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_MISC_COMPARE_STRINGS( const char* str1, const char* str2, bool matchCase, int maxLength) { return invoke<int )
	{
		auto retval = MISC::COMPARE_STRINGS(str1, str2, matchCase, invoke<int);
		return retval;
	}

	int LUA_NATIVE_MISC_ABSI( int value) { return invoke<int )
	{
		auto retval = MISC::ABSI(invoke<int);
		return retval;
	}

	float LUA_NATIVE_MISC_ABSF( float value) { return invoke<float )
	{
		auto retval = MISC::ABSF(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_SNIPER_BULLET_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_SNIPER_BULLET_IN_AREA(x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PROJECTILE_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_PROJECTILE_IN_AREA(x1, y1, z1, x2, y2, z2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PROJECTILE_TYPE_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, int type, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_PROJECTILE_TYPE_IN_AREA(x1, y1, z1, x2, y2, z2, type, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PROJECTILE_TYPE_IN_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width, Any p7, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_PROJECTILE_TYPE_IN_ANGLED_AREA(x1, y1, z1, x2, y2, z2, width, p7, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PROJECTILE_TYPE_WITHIN_DISTANCE( float x, float y, float z, unsigned projectileHash, float radius, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_PROJECTILE_TYPE_WITHIN_DISTANCE(x, y, z, projectileHash, radius, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_MISC_GET_COORDS_OF_PROJECTILE_TYPE_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, unsigned projectileHash, Vector3 projectilePos, bool ownedByPlayer) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_COORDS_OF_PROJECTILE_TYPE_IN_AREA(x1, y1, z1, x2, y2, z2, projectileHash, &projectilePos, invoke<BOOL);
		std::get<1>(return_values) = projectilePos;

		return return_values;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_MISC_GET_COORDS_OF_PROJECTILE_TYPE_IN_ANGLED_AREA( float vecAngledAreaPoint1X, float vecAngledAreaPoint1Y, float vecAngledAreaPoint1Z, float vecAngledAreaPoint2X, float vecAngledAreaPoint2Y, float vecAngledAreaPoint2Z, float distanceOfOppositeFace, unsigned weaponType, Vector3 positionOut, bool bIsPlayer) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_COORDS_OF_PROJECTILE_TYPE_IN_ANGLED_AREA(vecAngledAreaPoint1X, vecAngledAreaPoint1Y, vecAngledAreaPoint1Z, vecAngledAreaPoint2X, vecAngledAreaPoint2Y, vecAngledAreaPoint2Z, distanceOfOppositeFace, weaponType, &positionOut, invoke<BOOL);
		std::get<1>(return_values) = positionOut;

		return return_values;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_MISC_GET_COORDS_OF_PROJECTILE_TYPE_WITHIN_DISTANCE( int ped, unsigned weaponHash, float distance, Vector3 outCoords, bool p4) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_COORDS_OF_PROJECTILE_TYPE_WITHIN_DISTANCE(ped, weaponHash, distance, &outCoords, invoke<BOOL);
		std::get<1>(return_values) = outCoords;

		return return_values;
	}

	std::tuple<bool, Vector3, Object> LUA_NATIVE_MISC_GET_PROJECTILE_OF_PROJECTILE_TYPE_WITHIN_DISTANCE( int ped, unsigned weaponHash, float distance, Vector3 outCoords, Object outProjectile, bool p5) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, Object> return_values;
		std::get<0>(return_values) = (bool)MISC::GET_PROJECTILE_OF_PROJECTILE_TYPE_WITHIN_DISTANCE(ped, weaponHash, distance, &outCoords, &outProjectile, invoke<BOOL);
		std::get<1>(return_values) = outCoords;
		std::get<2>(return_values) = outProjectile;

		return return_values;
	}

	bool LUA_NATIVE_MISC_IS_BULLET_IN_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_BULLET_IN_ANGLED_AREA(x1, y1, z1, x2, y2, z2, width, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_BULLET_IN_AREA( float x, float y, float z, float radius, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_BULLET_IN_AREA(x, y, z, radius, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_BULLET_IN_BOX( float x1, float y1, float z1, float x2, float y2, float z2, bool ownedByPlayer) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_BULLET_IN_BOX(x1, y1, z1, x2, y2, z2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_HAS_BULLET_IMPACTED_IN_AREA( float x, float y, float z, float p3, bool p4, bool p5) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::HAS_BULLET_IMPACTED_IN_AREA(x, y, z, p3, p4, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_HAS_BULLET_IMPACTED_IN_BOX( float p0, float p1, float p2, float p3, float p4, float p5, bool p6, bool p7) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::HAS_BULLET_IMPACTED_IN_BOX(p0, p1, p2, p3, p4, p5, p6, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_ORBIS_VERSION(  )
	{
		auto retval = (bool)MISC::IS_ORBIS_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_DURANGO_VERSION(  )
	{
		auto retval = (bool)MISC::IS_DURANGO_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_XBOX360_VERSION(  )
	{
		auto retval = (bool)MISC::IS_XBOX360_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PS3_VERSION(  )
	{
		auto retval = (bool)MISC::IS_PS3_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PC_VERSION(  )
	{
		auto retval = (bool)MISC::IS_PC_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_STEAM_VERSION(  )
	{
		auto retval = (bool)MISC::IS_STEAM_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_AUSSIE_VERSION(  )
	{
		auto retval = (bool)MISC::IS_AUSSIE_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_JAPANESE_VERSION(  )
	{
		auto retval = (bool)MISC::IS_JAPANESE_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_XBOX_PLATFORM(  )
	{
		auto retval = (bool)MISC::IS_XBOX_PLATFORM();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_SCARLETT_VERSION(  )
	{
		auto retval = (bool)MISC::IS_SCARLETT_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_SCE_PLATFORM(  )
	{
		auto retval = (bool)MISC::IS_SCE_PLATFORM();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_PROSPERO_VERSION(  )
	{
		auto retval = (bool)MISC::IS_PROSPERO_VERSION();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_STRING_NULL( const char* string) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_STRING_NULL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_STRING_NULL_OR_EMPTY( const char* string) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_STRING_NULL_OR_EMPTY(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int outInteger) { return> LUA_NATIVE_MISC_STRING_TO_INT( const char* string, int outInteger) { return invoke<BOOL )
	{
		std::tuple<bool, int outInteger) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::STRING_TO_INT(string, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_MISC_SET_BITS_IN_RANGE( int var, int rangeStart, int rangeEnd, int p3) { invoke<void )
	{
		MISC::SET_BITS_IN_RANGE(&var, rangeStart, rangeEnd, invoke<void);
		return var;
	}

	int LUA_NATIVE_MISC_GET_BITS_IN_RANGE( int var, int rangeStart, int rangeEnd) { return invoke<int )
	{
		auto retval = MISC::GET_BITS_IN_RANGE(var, rangeStart, invoke<int);
		return retval;
	}

	int LUA_NATIVE_MISC_ADD_STUNT_JUMP( float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float camX, float camY, float camZ, int p15, int p16, int p17) { return invoke<int )
	{
		auto retval = MISC::ADD_STUNT_JUMP(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, camX, camY, camZ, p15, p16, invoke<int);
		return retval;
	}

	int LUA_NATIVE_MISC_ADD_STUNT_JUMP_ANGLED( float x1, float y1, float z1, float x2, float y2, float z2, float radius1, float x3, float y3, float z3, float x4, float y4, float z4, float radius2, float camX, float camY, float camZ, int p17, int p18, int p19) { return invoke<int )
	{
		auto retval = MISC::ADD_STUNT_JUMP_ANGLED(x1, y1, z1, x2, y2, z2, radius1, x3, y3, z3, x4, y4, z4, radius2, camX, camY, camZ, p17, p18, invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_TOGGLE_SHOW_OPTIONAL_STUNT_JUMP_CAMERA( bool toggle) { invoke<void )
	{
		MISC::TOGGLE_SHOW_OPTIONAL_STUNT_JUMP_CAMERA(invoke<void);
	}

	void LUA_NATIVE_MISC_DELETE_STUNT_JUMP( int p0) { invoke<void )
	{
		MISC::DELETE_STUNT_JUMP(invoke<void);
	}

	void LUA_NATIVE_MISC_ENABLE_STUNT_JUMP_SET( int p0) { invoke<void )
	{
		MISC::ENABLE_STUNT_JUMP_SET(invoke<void);
	}

	void LUA_NATIVE_MISC_DISABLE_STUNT_JUMP_SET( int p0) { invoke<void )
	{
		MISC::DISABLE_STUNT_JUMP_SET(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_STUNT_JUMPS_CAN_TRIGGER( bool toggle) { invoke<void )
	{
		MISC::SET_STUNT_JUMPS_CAN_TRIGGER(invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_STUNT_JUMP_IN_PROGRESS(  )
	{
		auto retval = (bool)MISC::IS_STUNT_JUMP_IN_PROGRESS();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_STUNT_JUMP_MESSAGE_SHOWING(  )
	{
		auto retval = (bool)MISC::IS_STUNT_JUMP_MESSAGE_SHOWING();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_NUM_SUCCESSFUL_STUNT_JUMPS(  )
	{
		auto retval = MISC::GET_NUM_SUCCESSFUL_STUNT_JUMPS();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_TOTAL_SUCCESSFUL_STUNT_JUMPS(  )
	{
		auto retval = MISC::GET_TOTAL_SUCCESSFUL_STUNT_JUMPS();
		return retval;
	}

	void LUA_NATIVE_MISC_CANCEL_STUNT_JUMP(  )
	{
		MISC::CANCEL_STUNT_JUMP();
	}

	void LUA_NATIVE_MISC_SET_GAME_PAUSED( bool toggle) { invoke<void )
	{
		MISC::SET_GAME_PAUSED(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_THIS_SCRIPT_CAN_BE_PAUSED( bool toggle) { invoke<void )
	{
		MISC::SET_THIS_SCRIPT_CAN_BE_PAUSED(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_THIS_SCRIPT_CAN_REMOVE_BLIPS_CREATED_BY_ANY_SCRIPT( bool toggle) { invoke<void )
	{
		MISC::SET_THIS_SCRIPT_CAN_REMOVE_BLIPS_CREATED_BY_ANY_SCRIPT(invoke<void);
	}

	bool LUA_NATIVE_MISC_HAS_CHEAT_WITH_HASH_BEEN_ACTIVATED( unsigned hash, int amount) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::HAS_CHEAT_WITH_HASH_BEEN_ACTIVATED(hash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_HAS_PC_CHEAT_WITH_HASH_BEEN_ACTIVATED( unsigned hash) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::HAS_PC_CHEAT_WITH_HASH_BEEN_ACTIVATED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_OVERRIDE_FREEZE_FLAGS( bool p0) { invoke<void )
	{
		MISC::OVERRIDE_FREEZE_FLAGS(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_INSTANCE_PRIORITY_MODE( int p0) { invoke<void )
	{
		MISC::SET_INSTANCE_PRIORITY_MODE(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_INSTANCE_PRIORITY_HINT( int flag) { invoke<void )
	{
		MISC::SET_INSTANCE_PRIORITY_HINT(invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_FRONTEND_FADING(  )
	{
		auto retval = (bool)MISC::IS_FRONTEND_FADING();
		return retval;
	}

	void LUA_NATIVE_MISC_POPULATE_NOW(  )
	{
		MISC::POPULATE_NOW();
	}

	int LUA_NATIVE_MISC_GET_INDEX_OF_CURRENT_LEVEL(  )
	{
		auto retval = MISC::GET_INDEX_OF_CURRENT_LEVEL();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_GRAVITY_LEVEL( int level) { invoke<void )
	{
		MISC::SET_GRAVITY_LEVEL(invoke<void);
	}

	Any LUA_NATIVE_MISC_START_SAVE_DATA( Any p0, Any p1, bool p2) { invoke<void )
	{
		MISC::START_SAVE_DATA(&p0, p1, invoke<void);
		return p0;
	}

	void LUA_NATIVE_MISC_STOP_SAVE_DATA(  )
	{
		MISC::STOP_SAVE_DATA();
	}

	int LUA_NATIVE_MISC_GET_SIZE_OF_SAVE_DATA( bool p0) { return invoke<int )
	{
		auto retval = MISC::GET_SIZE_OF_SAVE_DATA(invoke<int);
		return retval;
	}

	Any LUA_NATIVE_MISC_REGISTER_INT_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_INT_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_INT64_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_INT64_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_ENUM_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_ENUM_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_FLOAT_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_FLOAT_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_BOOL_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_BOOL_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_TEXT_LABEL_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_TEXT_LABEL_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_TEXT_LABEL_15_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_TEXT_LABEL_15_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_TEXT_LABEL_23_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_TEXT_LABEL_23_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_TEXT_LABEL_31_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_TEXT_LABEL_31_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_REGISTER_TEXT_LABEL_63_TO_SAVE( Any p0, const char* name) { invoke<void )
	{
		MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&p0, invoke<void);
		return p0;
	}

	Any LUA_NATIVE_MISC_START_SAVE_STRUCT_WITH_SIZE( Any p0, int size, const char* structName) { invoke<void )
	{
		MISC::START_SAVE_STRUCT_WITH_SIZE(&p0, size, invoke<void);
		return p0;
	}

	void LUA_NATIVE_MISC_STOP_SAVE_STRUCT(  )
	{
		MISC::STOP_SAVE_STRUCT();
	}

	Any LUA_NATIVE_MISC_START_SAVE_ARRAY_WITH_SIZE( Any p0, int size, const char* arrayName) { invoke<void )
	{
		MISC::START_SAVE_ARRAY_WITH_SIZE(&p0, size, invoke<void);
		return p0;
	}

	void LUA_NATIVE_MISC_STOP_SAVE_ARRAY(  )
	{
		MISC::STOP_SAVE_ARRAY();
	}

	std::tuple<Any, Any> LUA_NATIVE_MISC_COPY_SCRIPT_STRUCT( Any dst, Any src, int size) { invoke<void )
	{
		std::tuple<Any, Any> return_values;
		MISC::COPY_SCRIPT_STRUCT(&dst, &src, invoke<void);
		std::get<0>(return_values) = dst;
		std::get<1>(return_values) = src;

		return return_values;
	}

	void LUA_NATIVE_MISC_ENABLE_DISPATCH_SERVICE( int dispatchService, bool toggle) { invoke<void )
	{
		MISC::ENABLE_DISPATCH_SERVICE(dispatchService, invoke<void);
	}

	void LUA_NATIVE_MISC_BLOCK_DISPATCH_SERVICE_RESOURCE_CREATION( int dispatchService, bool toggle) { invoke<void )
	{
		MISC::BLOCK_DISPATCH_SERVICE_RESOURCE_CREATION(dispatchService, invoke<void);
	}

	int LUA_NATIVE_MISC_GET_NUMBER_RESOURCES_ALLOCATED_TO_WANTED_LEVEL( int dispatchService) { return invoke<int )
	{
		auto retval = MISC::GET_NUMBER_RESOURCES_ALLOCATED_TO_WANTED_LEVEL(invoke<int);
		return retval;
	}

	std::tuple<bool, int> LUA_NATIVE_MISC_CREATE_INCIDENT( int dispatchService, float x, float y, float z, int numUnits, float radius, int outIncidentID, Any p7, Any p8) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)MISC::CREATE_INCIDENT(dispatchService, x, y, z, numUnits, radius, &outIncidentID, p7, invoke<BOOL);
		std::get<1>(return_values) = outIncidentID;

		return return_values;
	}

	std::tuple<bool, int> LUA_NATIVE_MISC_CREATE_INCIDENT_WITH_ENTITY( int dispatchService, int ped, int numUnits, float radius, int outIncidentID, Any p5, Any p6) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)MISC::CREATE_INCIDENT_WITH_ENTITY(dispatchService, ped, numUnits, radius, &outIncidentID, p5, invoke<BOOL);
		std::get<1>(return_values) = outIncidentID;

		return return_values;
	}

	void LUA_NATIVE_MISC_DELETE_INCIDENT( int incidentId) { invoke<void )
	{
		MISC::DELETE_INCIDENT(invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_INCIDENT_VALID( int incidentId) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_INCIDENT_VALID(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_SET_INCIDENT_REQUESTED_UNITS( int incidentId, int dispatchService, int numUnits) { invoke<void )
	{
		MISC::SET_INCIDENT_REQUESTED_UNITS(incidentId, dispatchService, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_IDEAL_SPAWN_DISTANCE_FOR_INCIDENT( int incidentId, float p1) { invoke<void )
	{
		MISC::SET_IDEAL_SPAWN_DISTANCE_FOR_INCIDENT(incidentId, invoke<void);
	}

	std::tuple<bool, Vector3 spawnPoint) { return> LUA_NATIVE_MISC_FIND_SPAWN_POINT_IN_DIRECTION( float posX, float posY, float posZ, float fwdVecX, float fwdVecY, float fwdVecZ, float distance, Vector3 spawnPoint) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 spawnPoint) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::FIND_SPAWN_POINT_IN_DIRECTION(posX, posY, posZ, fwdVecX, fwdVecY, fwdVecZ, distance, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_MISC_ADD_POP_MULTIPLIER_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float p6, float p7, bool p8, bool p9) { return invoke<int )
	{
		auto retval = MISC::ADD_POP_MULTIPLIER_AREA(x1, y1, z1, x2, y2, z2, p6, p7, p8, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_MISC_DOES_POP_MULTIPLIER_AREA_EXIST( int id) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::DOES_POP_MULTIPLIER_AREA_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_REMOVE_POP_MULTIPLIER_AREA( int id, bool p1) { invoke<void )
	{
		MISC::REMOVE_POP_MULTIPLIER_AREA(id, invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_POP_MULTIPLIER_AREA_NETWORKED( int id) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_POP_MULTIPLIER_AREA_NETWORKED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_MISC_ADD_POP_MULTIPLIER_SPHERE( float x, float y, float z, float radius, float pedMultiplier, float vehicleMultiplier, bool p6, bool p7) { return invoke<int )
	{
		auto retval = MISC::ADD_POP_MULTIPLIER_SPHERE(x, y, z, radius, pedMultiplier, vehicleMultiplier, p6, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_MISC_DOES_POP_MULTIPLIER_SPHERE_EXIST( int id) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::DOES_POP_MULTIPLIER_SPHERE_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_REMOVE_POP_MULTIPLIER_SPHERE( int id, bool p1) { invoke<void )
	{
		MISC::REMOVE_POP_MULTIPLIER_SPHERE(id, invoke<void);
	}

	void LUA_NATIVE_MISC_ENABLE_TENNIS_MODE( int ped, bool toggle, bool p2) { invoke<void )
	{
		MISC::ENABLE_TENNIS_MODE(ped, toggle, invoke<void);
	}

	bool LUA_NATIVE_MISC_IS_TENNIS_MODE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::IS_TENNIS_MODE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_PLAY_TENNIS_SWING_ANIM( int ped, const char* animDict, const char* animName, float p3, float p4, bool p5) { invoke<void )
	{
		MISC::PLAY_TENNIS_SWING_ANIM(ped, animDict, animName, p3, p4, invoke<void);
	}

	bool LUA_NATIVE_MISC_GET_TENNIS_SWING_ANIM_COMPLETE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::GET_TENNIS_SWING_ANIM_COMPLETE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_GET_TENNIS_SWING_ANIM_CAN_BE_INTERRUPTED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::GET_TENNIS_SWING_ANIM_CAN_BE_INTERRUPTED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MISC_GET_TENNIS_SWING_ANIM_SWUNG( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)MISC::GET_TENNIS_SWING_ANIM_SWUNG(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MISC_PLAY_TENNIS_DIVE_ANIM( int ped, int p1, float p2, float p3, float p4, bool p5) { invoke<void )
	{
		MISC::PLAY_TENNIS_DIVE_ANIM(ped, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_TENNIS_MOVE_NETWORK_SIGNAL_FLOAT( int ped, const char* p1, float p2) { invoke<void )
	{
		MISC::SET_TENNIS_MOVE_NETWORK_SIGNAL_FLOAT(ped, p1, invoke<void);
	}

	void LUA_NATIVE_MISC_RESET_DISPATCH_SPAWN_LOCATION(  )
	{
		MISC::RESET_DISPATCH_SPAWN_LOCATION();
	}

	void LUA_NATIVE_MISC_SET_DISPATCH_SPAWN_LOCATION( float x, float y, float z) { invoke<void )
	{
		MISC::SET_DISPATCH_SPAWN_LOCATION(x, y, invoke<void);
	}

	void LUA_NATIVE_MISC_RESET_DISPATCH_IDEAL_SPAWN_DISTANCE(  )
	{
		MISC::RESET_DISPATCH_IDEAL_SPAWN_DISTANCE();
	}

	void LUA_NATIVE_MISC_SET_DISPATCH_IDEAL_SPAWN_DISTANCE( float distance) { invoke<void )
	{
		MISC::SET_DISPATCH_IDEAL_SPAWN_DISTANCE(invoke<void);
	}

	void LUA_NATIVE_MISC_RESET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS( Any p0) { invoke<void )
	{
		MISC::RESET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS( Any p0, float p1) { invoke<void )
	{
		MISC::SET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS(p0, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS_MULTIPLIER( Any p0, float p1) { invoke<void )
	{
		MISC::SET_DISPATCH_TIME_BETWEEN_SPAWN_ATTEMPTS_MULTIPLIER(p0, invoke<void);
	}

	int LUA_NATIVE_MISC_ADD_DISPATCH_SPAWN_ANGLED_BLOCKING_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width) { return invoke<int )
	{
		auto retval = MISC::ADD_DISPATCH_SPAWN_ANGLED_BLOCKING_AREA(x1, y1, z1, x2, y2, z2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_MISC_ADD_DISPATCH_SPAWN_SPHERE_BLOCKING_AREA( float x1, float y1, float x2, float y2) { return invoke<int )
	{
		auto retval = MISC::ADD_DISPATCH_SPAWN_SPHERE_BLOCKING_AREA(x1, y1, x2, invoke<int);
		return retval;
	}

	void LUA_NATIVE_MISC_REMOVE_DISPATCH_SPAWN_BLOCKING_AREA( int p0) { invoke<void )
	{
		MISC::REMOVE_DISPATCH_SPAWN_BLOCKING_AREA(invoke<void);
	}

	void LUA_NATIVE_MISC_RESET_DISPATCH_SPAWN_BLOCKING_AREAS(  )
	{
		MISC::RESET_DISPATCH_SPAWN_BLOCKING_AREAS();
	}

	void LUA_NATIVE_MISC_RESET_WANTED_RESPONSE_NUM_PEDS_TO_SPAWN(  )
	{
		MISC::RESET_WANTED_RESPONSE_NUM_PEDS_TO_SPAWN();
	}

	void LUA_NATIVE_MISC_SET_WANTED_RESPONSE_NUM_PEDS_TO_SPAWN( int p0, int p1) { invoke<void )
	{
		MISC::SET_WANTED_RESPONSE_NUM_PEDS_TO_SPAWN(p0, invoke<void);
	}

	void LUA_NATIVE_MISC_ADD_TACTICAL_NAV_MESH_POINT( float x, float y, float z) { invoke<void )
	{
		MISC::ADD_TACTICAL_NAV_MESH_POINT(x, y, invoke<void);
	}

	void LUA_NATIVE_MISC_CLEAR_TACTICAL_NAV_MESH_POINTS(  )
	{
		MISC::CLEAR_TACTICAL_NAV_MESH_POINTS();
	}

	void LUA_NATIVE_MISC_SET_RIOT_MODE_ENABLED( bool toggle) { invoke<void )
	{
		MISC::SET_RIOT_MODE_ENABLED(invoke<void);
	}

	Any LUA_NATIVE_MISC_DISPLAY_ONSCREEN_KEYBOARD_WITH_LONGER_INITIAL_STRING( int p0, const char* windowTitle, Any p2, const char* defaultText, const char* defaultConcat1, const char* defaultConcat2, const char* defaultConcat3, const char* defaultConcat4, const char* defaultConcat5, const char* defaultConcat6, const char* defaultConcat7, int maxInputLength) { invoke<void )
	{
		MISC::DISPLAY_ONSCREEN_KEYBOARD_WITH_LONGER_INITIAL_STRING(p0, windowTitle, &p2, defaultText, defaultConcat1, defaultConcat2, defaultConcat3, defaultConcat4, defaultConcat5, defaultConcat6, defaultConcat7, invoke<void);
		return p2;
	}

	void LUA_NATIVE_MISC_DISPLAY_ONSCREEN_KEYBOARD( int p0, const char* windowTitle, const char* p2, const char* defaultText, const char* defaultConcat1, const char* defaultConcat2, const char* defaultConcat3, int maxInputLength) { invoke<void )
	{
		MISC::DISPLAY_ONSCREEN_KEYBOARD(p0, windowTitle, p2, defaultText, defaultConcat1, defaultConcat2, defaultConcat3, invoke<void);
	}

	int LUA_NATIVE_MISC_UPDATE_ONSCREEN_KEYBOARD(  )
	{
		auto retval = MISC::UPDATE_ONSCREEN_KEYBOARD();
		return retval;
	}

	const char* LUA_NATIVE_MISC_GET_ONSCREEN_KEYBOARD_RESULT(  )
	{
		auto retval = MISC::GET_ONSCREEN_KEYBOARD_RESULT();
		return retval;
	}

	void LUA_NATIVE_MISC_CANCEL_ONSCREEN_KEYBOARD(  )
	{
		MISC::CANCEL_ONSCREEN_KEYBOARD();
	}

	void LUA_NATIVE_MISC_NEXT_ONSCREEN_KEYBOARD_RESULT_WILL_DISPLAY_USING_THESE_FONTS( int p0) { invoke<void )
	{
		MISC::NEXT_ONSCREEN_KEYBOARD_RESULT_WILL_DISPLAY_USING_THESE_FONTS(invoke<void);
	}

	void LUA_NATIVE_MISC_ACTION_MANAGER_ENABLE_ACTION( unsigned hash, bool enable) { invoke<void )
	{
		MISC::ACTION_MANAGER_ENABLE_ACTION(hash, invoke<void);
	}

	int LUA_NATIVE_MISC_GET_REAL_WORLD_TIME(  )
	{
		auto retval = MISC::GET_REAL_WORLD_TIME();
		return retval;
	}

	void LUA_NATIVE_MISC_SUPRESS_RANDOM_EVENT_THIS_FRAME( int eventType, bool suppress) { invoke<void )
	{
		MISC::SUPRESS_RANDOM_EVENT_THIS_FRAME(eventType, invoke<void);
	}

	void LUA_NATIVE_MISC_SET_EXPLOSIVE_AMMO_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_EXPLOSIVE_AMMO_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FIRE_AMMO_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_FIRE_AMMO_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_EXPLOSIVE_MELEE_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_EXPLOSIVE_MELEE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_SUPER_JUMP_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_SUPER_JUMP_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_BEAST_JUMP_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_BEAST_JUMP_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_MISC_SET_FORCED_JUMP_THIS_FRAME( int player) { invoke<void )
	{
		MISC::SET_FORCED_JUMP_THIS_FRAME(invoke<void);
	}

	bool LUA_NATIVE_MISC_HAS_GAME_INSTALLED_THIS_SESSION(  )
	{
		auto retval = (bool)MISC::HAS_GAME_INSTALLED_THIS_SESSION();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_TICKER_JOHNMARSTON_IS_DONE(  )
	{
		MISC::SET_TICKER_JOHNMARSTON_IS_DONE();
	}

	bool LUA_NATIVE_MISC_ARE_PROFILE_SETTINGS_VALID(  )
	{
		auto retval = (bool)MISC::ARE_PROFILE_SETTINGS_VALID();
		return retval;
	}

	void LUA_NATIVE_MISC_PREVENT_ARREST_STATE_THIS_FRAME(  )
	{
		MISC::PREVENT_ARREST_STATE_THIS_FRAME();
	}

	void LUA_NATIVE_MISC_FORCE_GAME_STATE_PLAYING(  )
	{
		MISC::FORCE_GAME_STATE_PLAYING();
	}

	void LUA_NATIVE_MISC_SCRIPT_RACE_INIT( int p0, int p1, Any p2, Any p3) { invoke<void )
	{
		MISC::SCRIPT_RACE_INIT(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MISC_SCRIPT_RACE_SHUTDOWN(  )
	{
		MISC::SCRIPT_RACE_SHUTDOWN();
	}

	void LUA_NATIVE_MISC_SCRIPT_RACE_PLAYER_HIT_CHECKPOINT( int player, Any p1, Any p2, Any p3) { invoke<void )
	{
		MISC::SCRIPT_RACE_PLAYER_HIT_CHECKPOINT(player, p1, p2, invoke<void);
	}

	std::tuple<bool, int, int p2) { return> LUA_NATIVE_MISC_SCRIPT_RACE_GET_PLAYER_SPLIT_TIME( int player, int p1, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int, int p2) { return> return_values;
		std::get<0>(return_values) = (bool)MISC::SCRIPT_RACE_GET_PLAYER_SPLIT_TIME(player, &p1, &invoke<BOOL);
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_MISC_START_END_USER_BENCHMARK(  )
	{
		MISC::START_END_USER_BENCHMARK();
	}

	void LUA_NATIVE_MISC_STOP_END_USER_BENCHMARK(  )
	{
		MISC::STOP_END_USER_BENCHMARK();
	}

	void LUA_NATIVE_MISC_RESET_END_USER_BENCHMARK(  )
	{
		MISC::RESET_END_USER_BENCHMARK();
	}

	void LUA_NATIVE_MISC_SAVE_END_USER_BENCHMARK(  )
	{
		MISC::SAVE_END_USER_BENCHMARK();
	}

	bool LUA_NATIVE_MISC_UI_STARTED_END_USER_BENCHMARK(  )
	{
		auto retval = (bool)MISC::UI_STARTED_END_USER_BENCHMARK();
		return retval;
	}

	bool LUA_NATIVE_MISC_LANDING_SCREEN_STARTED_END_USER_BENCHMARK(  )
	{
		auto retval = (bool)MISC::LANDING_SCREEN_STARTED_END_USER_BENCHMARK();
		return retval;
	}

	bool LUA_NATIVE_MISC_IS_COMMANDLINE_END_USER_BENCHMARK(  )
	{
		auto retval = (bool)MISC::IS_COMMANDLINE_END_USER_BENCHMARK();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_BENCHMARK_ITERATIONS(  )
	{
		auto retval = MISC::GET_BENCHMARK_ITERATIONS();
		return retval;
	}

	int LUA_NATIVE_MISC_GET_BENCHMARK_PASS(  )
	{
		auto retval = MISC::GET_BENCHMARK_PASS();
		return retval;
	}

	void LUA_NATIVE_MISC_RESTART_GAME(  )
	{
		MISC::RESTART_GAME();
	}

	void LUA_NATIVE_MISC_QUIT_GAME(  )
	{
		MISC::QUIT_GAME();
	}

	bool LUA_NATIVE_MISC_HAS_ASYNC_INSTALL_FINISHED(  )
	{
		auto retval = (bool)MISC::HAS_ASYNC_INSTALL_FINISHED();
		return retval;
	}

	void LUA_NATIVE_MISC_CLEANUP_ASYNC_INSTALL(  )
	{
		MISC::CLEANUP_ASYNC_INSTALL();
	}

	bool LUA_NATIVE_MISC_PLM_IS_IN_CONSTRAINED_MODE(  )
	{
		auto retval = (bool)MISC::PLM_IS_IN_CONSTRAINED_MODE();
		return retval;
	}

	int LUA_NATIVE_MISC_PLM_GET_CONSTRAINED_DURATION_MS(  )
	{
		auto retval = MISC::PLM_GET_CONSTRAINED_DURATION_MS();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_PLAYER_IS_IN_ANIMAL_FORM( bool toggle) { invoke<void )
	{
		MISC::SET_PLAYER_IS_IN_ANIMAL_FORM(invoke<void);
	}

	bool LUA_NATIVE_MISC_GET_IS_PLAYER_IN_ANIMAL_FORM(  )
	{
		auto retval = (bool)MISC::GET_IS_PLAYER_IN_ANIMAL_FORM();
		return retval;
	}

	void LUA_NATIVE_MISC_SET_PLAYER_IS_REPEATING_A_MISSION( bool toggle) { invoke<void )
	{
		MISC::SET_PLAYER_IS_REPEATING_A_MISSION(invoke<void);
	}

	void LUA_NATIVE_MISC_DISABLE_SCREEN_DIMMING_THIS_FRAME(  )
	{
		MISC::DISABLE_SCREEN_DIMMING_THIS_FRAME();
	}

	float LUA_NATIVE_MISC_GET_CITY_DENSITY(  )
	{
		auto retval = MISC::GET_CITY_DENSITY();
		return retval;
	}

	void LUA_NATIVE_MISC_USE_ACTIVE_CAMERA_FOR_TIMESLICING_CENTRE(  )
	{
		MISC::USE_ACTIVE_CAMERA_FOR_TIMESLICING_CENTRE();
	}

	void LUA_NATIVE_MISC_SET_CONTENT_ID_INDEX( unsigned contentId, int index) { invoke<void )
	{
		MISC::SET_CONTENT_ID_INDEX(contentId, invoke<void);
	}

	int LUA_NATIVE_MISC_GET_CONTENT_ID_INDEX( unsigned contentId) { return invoke<int )
	{
		auto retval = MISC::GET_CONTENT_ID_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_MOBILE_CREATE_MOBILE_PHONE( int phoneType) { invoke<void )
	{
		MOBILE::CREATE_MOBILE_PHONE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_DESTROY_MOBILE_PHONE(  )
	{
		MOBILE::DESTROY_MOBILE_PHONE();
	}

	void LUA_NATIVE_MOBILE_SET_MOBILE_PHONE_SCALE( float scale) { invoke<void )
	{
		MOBILE::SET_MOBILE_PHONE_SCALE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_SET_MOBILE_PHONE_ROTATION( float rotX, float rotY, float rotZ, Any p3) { invoke<void )
	{
		MOBILE::SET_MOBILE_PHONE_ROTATION(rotX, rotY, rotZ, invoke<void);
	}

	Vector3 LUA_NATIVE_MOBILE_GET_MOBILE_PHONE_ROTATION( Vector3 rotation, int p1) { invoke<void )
	{
		MOBILE::GET_MOBILE_PHONE_ROTATION(&rotation, invoke<void);
		return rotation;
	}

	void LUA_NATIVE_MOBILE_SET_MOBILE_PHONE_POSITION( float posX, float posY, float posZ) { invoke<void )
	{
		MOBILE::SET_MOBILE_PHONE_POSITION(posX, posY, invoke<void);
	}

	Vector3 position) { LUA_NATIVE_MOBILE_GET_MOBILE_PHONE_POSITION( Vector3 position) { invoke<void )
	{
		MOBILE::GET_MOBILE_PHONE_POSITION(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_MOBILE_SCRIPT_IS_MOVING_MOBILE_PHONE_OFFSCREEN( bool toggle) { invoke<void )
	{
		MOBILE::SCRIPT_IS_MOVING_MOBILE_PHONE_OFFSCREEN(invoke<void);
	}

	bool LUA_NATIVE_MOBILE_CAN_PHONE_BE_SEEN_ON_SCREEN(  )
	{
		auto retval = (bool)MOBILE::CAN_PHONE_BE_SEEN_ON_SCREEN();
		return retval;
	}

	void LUA_NATIVE_MOBILE_SET_MOBILE_PHONE_DOF_STATE( bool toggle) { invoke<void )
	{
		MOBILE::SET_MOBILE_PHONE_DOF_STATE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_SET_INPUT( int direction) { invoke<void )
	{
		MOBILE::CELL_SET_INPUT(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_HORIZONTAL_MODE_TOGGLE( bool toggle) { invoke<void )
	{
		MOBILE::CELL_HORIZONTAL_MODE_TOGGLE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_ACTIVATE( bool p0, bool p1) { invoke<void )
	{
		MOBILE::CELL_CAM_ACTIVATE(p0, invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_ACTIVATE_SELFIE_MODE( bool toggle) { invoke<void )
	{
		MOBILE::CELL_CAM_ACTIVATE_SELFIE_MODE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_ACTIVATE_SHALLOW_DOF_MODE( bool toggle) { invoke<void )
	{
		MOBILE::CELL_CAM_ACTIVATE_SHALLOW_DOF_MODE(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_SIDE_OFFSET_SCALING( float p0) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_SIDE_OFFSET_SCALING(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_HORZ_PAN_OFFSET( float horizontalPan) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_HORZ_PAN_OFFSET(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_VERT_PAN_OFFSET( float vertPan) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_VERT_PAN_OFFSET(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_ROLL_OFFSET( float roll) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_ROLL_OFFSET(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_DISTANCE_SCALING( float distanceScaling) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_DISTANCE_SCALING(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_HEAD_YAW_OFFSET( float yaw) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_HEAD_YAW_OFFSET(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_HEAD_ROLL_OFFSET( float roll) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_HEAD_ROLL_OFFSET(invoke<void);
	}

	void LUA_NATIVE_MOBILE_CELL_CAM_SET_SELFIE_MODE_HEAD_PITCH_OFFSET( float pitch) { invoke<void )
	{
		MOBILE::CELL_CAM_SET_SELFIE_MODE_HEAD_PITCH_OFFSET(invoke<void);
	}

	bool LUA_NATIVE_MOBILE_CELL_CAM_IS_CHAR_VISIBLE_NO_FACE_CHECK( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)MOBILE::CELL_CAM_IS_CHAR_VISIBLE_NO_FACE_CHECK(invoke<BOOL);
		return retval;
	}

	int renderId) { LUA_NATIVE_MOBILE_GET_MOBILE_PHONE_RENDER_ID( int renderId) { invoke<void )
	{
		MOBILE::GET_MOBILE_PHONE_RENDER_ID(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_MONEY_NETWORK_INITIALIZE_CASH( int wallet, int bank) { invoke<void )
	{
		MONEY::NETWORK_INITIALIZE_CASH(wallet, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_DELETE_CHARACTER( int characterSlot, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_DELETE_CHARACTER(characterSlot, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_MANUAL_DELETE_CHARACTER( int characterSlot) { invoke<void )
	{
		MONEY::NETWORK_MANUAL_DELETE_CHARACTER(invoke<void);
	}

	bool LUA_NATIVE_MONEY_NETWORK_GET_PLAYER_IS_HIGH_EARNER(  )
	{
		auto retval = (bool)MONEY::NETWORK_GET_PLAYER_IS_HIGH_EARNER();
		return retval;
	}

	void LUA_NATIVE_MONEY_NETWORK_CLEAR_CHARACTER_WALLET( int characterSlot) { invoke<void )
	{
		MONEY::NETWORK_CLEAR_CHARACTER_WALLET(invoke<void);
	}

	Any gamerHandle) { LUA_NATIVE_MONEY_NETWORK_GIVE_PLAYER_JOBSHARE_CASH( int amount, Any gamerHandle) { invoke<void )
	{
		MONEY::NETWORK_GIVE_PLAYER_JOBSHARE_CASH(amount, &invoke<void);
		return invoke<void;
	}

	Any gamerHandle) { LUA_NATIVE_MONEY_NETWORK_RECEIVE_PLAYER_JOBSHARE_CASH( int value, Any gamerHandle) { invoke<void )
	{
		MONEY::NETWORK_RECEIVE_PLAYER_JOBSHARE_CASH(value, &invoke<void);
		return invoke<void;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CAN_SHARE_JOB_CASH(  )
	{
		auto retval = (bool)MONEY::NETWORK_CAN_SHARE_JOB_CASH();
		return retval;
	}

	void LUA_NATIVE_MONEY_NETWORK_REFUND_CASH( int index, const char* context, const char* reason, bool p3) { invoke<void )
	{
		MONEY::NETWORK_REFUND_CASH(index, context, reason, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_DEDUCT_CASH( int amount, const char* p1, const char* p2, bool p3, bool p4, bool p5) { invoke<void )
	{
		MONEY::NETWORK_DEDUCT_CASH(amount, p1, p2, p3, p4, invoke<void);
	}

	bool LUA_NATIVE_MONEY_NETWORK_MONEY_CAN_BET( int amount, bool p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_MONEY_CAN_BET(amount, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CAN_BET( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CAN_BET(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_CAN_BET( unsigned hash) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_CAN_BET(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_CAN_BET_PVC(  )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_CAN_BET_PVC();
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_CAN_BET_AMOUNT( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_CAN_BET_AMOUNT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_CAN_BUY_CHIPS_PVC(  )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_CAN_BUY_CHIPS_PVC();
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_BUY_CHIPS( int p0, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_BUY_CHIPS(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CASINO_SELL_CHIPS( int p0, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CASINO_SELL_CHIPS(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MONEY_NETWORK_DEFER_CASH_TRANSACTIONS_UNTIL_SHOP_SAVE(  )
	{
		MONEY::NETWORK_DEFER_CASH_TRANSACTIONS_UNTIL_SHOP_SAVE();
	}

	std::tuple<bool, int p3) { return> LUA_NATIVE_MONEY_CAN_PAY_AMOUNT_TO_BOSS( int p0, int p1, int amount, int p3) { return invoke<BOOL )
	{
		std::tuple<bool, int p3) { return> return_values;
		std::get<0>(return_values) = (bool)MONEY::CAN_PAY_AMOUNT_TO_BOSS(p0, p1, amount, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_PICKUP( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_PICKUP(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CASHING_OUT( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CASHING_OUT(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_GANGATTACK_PICKUP( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_GANGATTACK_PICKUP(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ASSASSINATE_TARGET_KILLED( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_ASSASSINATE_TARGET_KILLED(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_ROB_ARMORED_CARS( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_ROB_ARMORED_CARS(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CRATE_DROP( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CRATE_DROP(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BETTING( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_BETTING(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_JOB( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_JOB(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_JOBX2( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_JOBX2(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_PREMIUM_JOB( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_PREMIUM_JOB(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BEND_JOB( int amount, const char* heistHash) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_BEND_JOB(amount, invoke<void);
	}

	Any LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CHALLENGE_WIN( Any p0, Any p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CHALLENGE_WIN(p0, &p1, invoke<void);
		return p1;
	}

	std::tuple<Any, Any> LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BOUNTY( int amount, Any gamerHandle, Any p2, Any p3) { invoke<void )
	{
		std::tuple<Any, Any> return_values;
		MONEY::NETWORK_EARN_FROM_BOUNTY(amount, &gamerHandle, &p2, invoke<void);
		std::get<0>(return_values) = gamerHandle;
		std::get<1>(return_values) = p2;

		return return_values;
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_IMPORT_EXPORT( int amount, unsigned modelHash) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_IMPORT_EXPORT(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_HOLDUPS( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_HOLDUPS(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_PROPERTY( int amount, unsigned propertyName) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_PROPERTY(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_AI_TARGET_KILL( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_AI_TARGET_KILL(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_NOT_BADSPORT( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_NOT_BADSPORT(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_VEHICLE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_VEHICLE(p0, p1, p2, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_PERSONAL_VEHICLE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_PERSONAL_VEHICLE(p0, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_DAILY_OBJECTIVES( int amount, const char* type, int characterSlot) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_DAILY_OBJECTIVES(amount, type, invoke<void);
	}

	Any p2) { LUA_NATIVE_MONEY_NETWORK_EARN_FROM_AMBIENT_JOB( int p0, const char* p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_AMBIENT_JOB(p0, p1, &invoke<void);
		return invoke<void;
	}

	std::tuple<Any, Any p2) {> LUA_NATIVE_MONEY_NETWORK_EARN_FROM_JOB_BONUS( Any p0, Any p1, Any p2) { invoke<void )
	{
		std::tuple<Any, Any p2) {> return_values;
		MONEY::NETWORK_EARN_FROM_JOB_BONUS(p0, &p1, &invoke<void);
		std::get<0>(return_values) = p1;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CRIMINAL_MASTERMIND( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CRIMINAL_MASTERMIND(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_HEIST_AWARD( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_HEIST_AWARD(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FIRST_TIME_BONUS( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FIRST_TIME_BONUS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GOON( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_GOON(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BOSS( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_BOSS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AGENCY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_AGENCY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_WAREHOUSE( int amount, int id) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_WAREHOUSE(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CONTRABAND( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CONTRABAND(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_DESTROYING_CONTRABAND( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_DESTROYING_CONTRABAND(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_SMUGGLER_WORK( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_SMUGGLER_WORK(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_HANGAR_TRADE( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_HANGAR_TRADE(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_PURCHASE_CLUB_HOUSE( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_PURCHASE_CLUB_HOUSE(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BUSINESS_PRODUCT( int amount, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_BUSINESS_PRODUCT(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_VEHICLE_EXPORT( int amount, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_VEHICLE_EXPORT(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SMUGGLER_AGENCY( int amount, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_SMUGGLER_AGENCY(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BOUNTY_HUNTER_REWARD( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_BOUNTY_HUNTER_REWARD(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BUSINESS_BATTLE( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_BUSINESS_BATTLE(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_CLUB_MANAGEMENT_PARTICIPATION( Any p0, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_CLUB_MANAGEMENT_PARTICIPATION(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_FMBB_PHONECALL_MISSION( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_FMBB_PHONECALL_MISSION(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_BUSINESS_HUB_SELL( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_BUSINESS_HUB_SELL(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_FMBB_BOSS_WORK( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_FMBB_BOSS_WORK(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FMBB_WAGE_BONUS( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_FMBB_WAGE_BONUS(invoke<void);
	}

	bool LUA_NATIVE_MONEY_NETWORK_CAN_SPEND_MONEY( Any p0, bool p1, bool p2, bool p3, Any p4, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CAN_SPEND_MONEY(p0, p1, p2, p3, p4, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_MONEY_NETWORK_CAN_SPEND_MONEY2( Any p0, bool p1, bool p2, bool p3, Any p4, Any p5, Any p6) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)MONEY::NETWORK_CAN_SPEND_MONEY2(p0, p1, p2, p3, &p4, p5, invoke<BOOL);
		std::get<1>(return_values) = p4;

		return return_values;
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_ITEM( int amount, unsigned item, Any p2, Any p3, bool p4, const char* item_name, Any p6, Any p7, Any p8, bool p9) { invoke<void )
	{
		MONEY::NETWORK_BUY_ITEM(amount, item, p2, p3, p4, item_name, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_TAXI( int amount, bool p1, bool p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_TAXI(amount, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_PAY_EMPLOYEE_WAGE( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_PAY_EMPLOYEE_WAGE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_PAY_MATCH_ENTRY_FEE( int amount, const char* matchId, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_PAY_MATCH_ENTRY_FEE(amount, matchId, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BETTING( int amount, int p1, const char* matchId, bool p3, bool p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BETTING(amount, p1, matchId, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_WAGER( Any p0, Any p1, int amount) { invoke<void )
	{
		MONEY::NETWORK_SPENT_WAGER(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_IN_STRIPCLUB( Any p0, bool p1, Any p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_IN_STRIPCLUB(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_HEALTHCARE( int cost, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_BUY_HEALTHCARE(cost, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_AIRSTRIKE( int cost, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_BUY_AIRSTRIKE(cost, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_BACKUP_GANG( int p0, int p1, bool p2, bool p3, int npcProvider) { invoke<void )
	{
		MONEY::NETWORK_BUY_BACKUP_GANG(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_HELI_STRIKE( int cost, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_BUY_HELI_STRIKE(cost, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_AMMO_DROP( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_AMMO_DROP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_BOUNTY( int amount, int victim, bool p2, bool p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_BUY_BOUNTY(amount, victim, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_PROPERTY( int cost, unsigned propertyName, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_BUY_PROPERTY(cost, propertyName, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_SMOKES( int p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_BUY_SMOKES(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HELI_PICKUP( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HELI_PICKUP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BOAT_PICKUP( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BOAT_PICKUP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BULL_SHARK( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BULL_SHARK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_CASH_DROP( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CASH_DROP(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HIRE_MUGGER( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HIRE_MUGGER(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_ROBBED_BY_MUGGER( int amount, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_ROBBED_BY_MUGGER(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HIRE_MERCENARY( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HIRE_MERCENARY(p0, p1, p2, invoke<void);
	}

	Any LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_WANTEDLEVEL( Any p0, Any p1, bool p2, bool p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_WANTEDLEVEL(p0, &p1, p2, p3, invoke<void);
		return p1;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_OFFTHERADAR( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_OFFTHERADAR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_REVEAL_PLAYERS( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_REVEAL_PLAYERS(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_CARWASH( Any p0, Any p1, Any p2, bool p3, bool p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CARWASH(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_CINEMA( Any p0, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CINEMA(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_TELESCOPE( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_TELESCOPE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HOLDUPS( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HOLDUPS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_PASSIVE_MODE( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_PASSIVE_MODE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BANK_INTEREST( int p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BANK_INTEREST(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PROSTITUTES( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PROSTITUTES(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_ARREST_BAIL( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_ARREST_BAIL(p0, p1, invoke<void);
	}

	Any LUA_NATIVE_MONEY_NETWORK_SPENT_PAY_VEHICLE_INSURANCE_PREMIUM( int amount, unsigned vehicleModel, Any gamerHandle, bool notBankrupt, bool hasTheMoney) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PAY_VEHICLE_INSURANCE_PREMIUM(amount, vehicleModel, &gamerHandle, notBankrupt, invoke<void);
		return gamerHandle;
	}

	Any LUA_NATIVE_MONEY_NETWORK_SPENT_CALL_PLAYER( Any p0, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CALL_PLAYER(p0, &p1, p2, invoke<void);
		return p1;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BOUNTY( Any p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BOUNTY(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_FROM_ROCKSTAR( int p0, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_FROM_ROCKSTAR(p0, p1, invoke<void);
	}

	int LUA_NATIVE_MONEY_NETWORK_SPEND_EARNED_FROM_BANK_AND_WALLETS( int amount) { return invoke<int )
	{
		auto retval = MONEY::NETWORK_SPEND_EARNED_FROM_BANK_AND_WALLETS(invoke<int);
		return retval;
	}

	std::tuple<const char*, int, int> LUA_NATIVE_MONEY_PROCESS_CASH_GIFT( int p0, int p1, const char* p2) { return invoke<const char* )
	{
		std::tuple<const char*, int, int> return_values;
		std::get<0>(return_values) = MONEY::PROCESS_CASH_GIFT(&p0, &p1, char*);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;

		return return_values;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_MOVE_SUBMARINE( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_MOVE_SUBMARINE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PLAYER_HEALTHCARE( int p0, int p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PLAYER_HEALTHCARE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_NO_COPS( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_NO_COPS(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_CARGO_SOURCING( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CARGO_SOURCING(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_REQUEST_JOB( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_REQUEST_JOB(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_REQUEST_HEIST( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_REQUEST_HEIST(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_FAIRGROUND_RIDE( int amount, Any p1, bool p2, bool p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_BUY_FAIRGROUND_RIDE(amount, p1, p2, p3, invoke<void);
	}

	bool LUA_NATIVE_MONEY_NETWORK_ECONOMY_HAS_FIXED_CRAZY_NUMBERS(  )
	{
		auto retval = (bool)MONEY::NETWORK_ECONOMY_HAS_FIXED_CRAZY_NUMBERS();
		return retval;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_JOB_SKIP( int amount, const char* matchId, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_JOB_SKIP(amount, matchId, p2, invoke<void);
	}

	bool LUA_NATIVE_MONEY_NETWORK_SPENT_BOSS_GOON( int amount, bool p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_SPENT_BOSS_GOON(amount, p1, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GOON( int p0, int p1, int amount) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GOON(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BOSS( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BOSS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_MOVE_YACHT( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_MOVE_YACHT(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_RENAME_ORGANIZATION( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_RENAME_ORGANIZATION(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_BUY_CONTRABAND_MISSION( int p0, int p1, unsigned p2, bool p3, bool p4) { invoke<void )
	{
		MONEY::NETWORK_BUY_CONTRABAND_MISSION(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_SERVICE_HELI( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_SERVICE_HELI(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_SERVICE_VEHICLE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_SERVICE_VEHICLE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_SERVICE_SNACK( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_SERVICE_SNACK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_SERVICE_DANCER( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_SERVICE_DANCER(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_SERVICE_IMPOUND( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_SERVICE_IMPOUND(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PA_HELI_PICKUP( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PA_HELI_PICKUP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_OFFICE_PROPERTY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_OFFICE_PROPERTY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_OFFICE_PROPERTY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_OFFICE_PROPERTY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_WAREHOUSE_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_WAREHOUSE_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_WAREHOUSE_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_WAREHOUSE_PROPERTY(p0, p1, p2, invoke<void);
	}

	Any LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_IMPEXP_WAREHOUSE_PROPERTY( int amount, Any data, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_IMPEXP_WAREHOUSE_PROPERTY(amount, &data, p2, invoke<void);
		return data;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_IMPEXP_WAREHOUSE_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_IMPEXP_WAREHOUSE_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_TRADE_IMPEXP_WAREHOUSE_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_TRADE_IMPEXP_WAREHOUSE_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_ORDER_WAREHOUSE_VEHICLE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_ORDER_WAREHOUSE_VEHICLE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_ORDER_BODYGUARD_VEHICLE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_ORDER_BODYGUARD_VEHICLE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_JUKEBOX( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_JUKEBOX(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_CLUB_HOUSE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_CLUB_HOUSE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_CLUB_HOUSE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_CLUB_HOUSE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_BUSINESS_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_BUSINESS_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_BUSINESS_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_BUSINESS_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_TRADE_BUSINESS_PROPERTY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_TRADE_BUSINESS_PROPERTY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_MC_ABILITY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPENT_MC_ABILITY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PAY_BUSINESS_SUPPLIES( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PAY_BUSINESS_SUPPLIES(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_CHANGE_APPEARANCE( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_CHANGE_APPEARANCE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_VEHICLE_EXPORT_MODS( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<void )
	{
		MONEY::NETWORK_SPENT_VEHICLE_EXPORT_MODS(p0, p1, p2, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_OFFICE_GARAGE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_OFFICE_GARAGE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_OFFICE_GARAGE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_OFFICE_GARAGE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_IMPORT_EXPORT_REPAIR( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_IMPORT_EXPORT_REPAIR(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_HANGAR( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_HANGAR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_HANGAR( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_HANGAR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HANGAR_UTILITY_CHARGES( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HANGAR_UTILITY_CHARGES(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_HANGAR_STAFF_CHARGES( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_HANGAR_STAFF_CHARGES(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_TRUCK( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_TRUCK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_TRUCK( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_TRUCK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_BUNKER( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_BUNKER(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPRADE_BUNKER( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPRADE_BUNKER(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_SELL_BUNKER( int amount, unsigned bunkerHash) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_SELL_BUNKER(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BALLISTIC_EQUIPMENT( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BALLISTIC_EQUIPMENT(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_RDR_BONUS( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_RDR_BONUS(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_WAGE_PAYMENT( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_WAGE_PAYMENT(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_WAGE_PAYMENT_BONUS( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_WAGE_PAYMENT_BONUS(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_BASE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_BASE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_BASE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_BASE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_BUY_TILTROTOR( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_BUY_TILTROTOR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_TILTROTOR( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_TILTROTOR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_EMPLOY_ASSASSINS( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_EMPLOY_ASSASSINS(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GANGOPS_CANNON( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GANGOPS_CANNON(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GANGOPS_SKIP_MISSION( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GANGOPS_SKIP_MISSION(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CASINO_HEIST_SKIP_MISSION( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CASINO_HEIST_SKIP_MISSION(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SELL_BASE( int amount, unsigned baseNameHash) { invoke<void )
	{
		MONEY::NETWORK_EARN_SELL_BASE(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_TARGET_REFUND( int amount, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_TARGET_REFUND(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_WAGES( int amount, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_WAGES(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_WAGES_BONUS( int amount, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_WAGES_BONUS(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAR_CHALLENGE( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAR_CHALLENGE(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DOOMSDAY_FINALE_BONUS( int amount, unsigned vehicleHash) { invoke<void )
	{
		MONEY::NETWORK_EARN_DOOMSDAY_FINALE_BONUS(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_AWARD( int amount, const char* p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_AWARD(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_ELITE( int amount, const char* p1, int actIndex) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_ELITE(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SERVICE_EARN_GANGOPS_RIVAL_DELIVERY( int earnedMoney) { invoke<void )
	{
		MONEY::NETWORK_SERVICE_EARN_GANGOPS_RIVAL_DELIVERY(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GANGOPS_START_STRAND( int type, int amount, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GANGOPS_START_STRAND(type, amount, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GANGOPS_TRIP_SKIP( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GANGOPS_TRIP_SKIP(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_PREP_PARTICIPATION( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_PREP_PARTICIPATION(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_SETUP( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_SETUP(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_GANGOPS_FINALE( int amount, const char* p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_GANGOPS_FINALE(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GANGOPS_REPAIR_COST( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GANGOPS_REPAIR_COST(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_NIGHTCLUB( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_NIGHTCLUB(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_NIGHTCLUB_DANCING( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_NIGHTCLUB_DANCING(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BB_EVENT_BONUS( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_BB_EVENT_BONUS(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_HACKER_TRUCK( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_HACKER_TRUCK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_HACKER_TRUCK( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_HACKER_TRUCK(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_HACKER_TRUCK( Any p0, int amount, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_HACKER_TRUCK(p0, amount, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_PURCHASE_NIGHTCLUB_AND_WAREHOUSE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_PURCHASE_NIGHTCLUB_AND_WAREHOUSE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_UPGRADE_NIGHTCLUB_AND_WAREHOUSE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_UPGRADE_NIGHTCLUB_AND_WAREHOUSE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_NIGHTCLUB_AND_WAREHOUSE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		MONEY::NETWORK_EARN_NIGHTCLUB_AND_WAREHOUSE(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_NIGHTCLUB_AND_WAREHOUSE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_NIGHTCLUB_AND_WAREHOUSE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_RDR_HATCHET_BONUS( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPENT_RDR_HATCHET_BONUS(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_NIGHTCLUB_ENTRY_FEE( int player, int amount, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_NIGHTCLUB_ENTRY_FEE(player, amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_NIGHTCLUB_BAR_DRINK( int amount, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_NIGHTCLUB_BAR_DRINK(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BOUNTY_HUNTER_MISSION( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BOUNTY_HUNTER_MISSION(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_REHIRE_DJ( int amount, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_REHIRE_DJ(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_ARENA_JOIN_SPECTATOR( int amount, Any p1, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_ARENA_JOIN_SPECTATOR(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARENA_SKILL_LEVEL_PROGRESSION( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARENA_SKILL_LEVEL_PROGRESSION(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARENA_CAREER_PROGRESSION( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARENA_CAREER_PROGRESSION(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_MAKE_IT_RAIN( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_MAKE_IT_RAIN(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_ARENA( int amount, bool p1, bool p2, const char* p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_ARENA(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ARENA( int amount, bool p1, bool p2, const char* p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ARENA(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_ARENA_SPECTATOR_BOX( int amount, int type, bool p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_ARENA_SPECTATOR_BOX(amount, type, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SPIN_THE_WHEEL_PAYMENT( int amount, Any p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SPIN_THE_WHEEL_PAYMENT(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SPIN_THE_WHEEL_CASH( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_SPIN_THE_WHEEL_CASH(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_ARENA_PREMIUM( int amount, bool p1, bool p2) { invoke<void )
	{
		MONEY::NETWORK_SPEND_ARENA_PREMIUM(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARENA_WAR( int amount, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARENA_WAR(amount, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARENA_WAR_ASSASSINATE_TARGET( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARENA_WAR_ASSASSINATE_TARGET(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARENA_WAR_EVENT_CARGO( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARENA_WAR_EVENT_CARGO(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_RC_TIME_TRIAL( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_RC_TIME_TRIAL(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAILY_OBJECTIVE_EVENT( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAILY_OBJECTIVE_EVENT(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CASINO_MEMBERSHIP( int amount, bool p1, bool p2, int p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CASINO_MEMBERSHIP(amount, p1, p2, invoke<void);
	}

	Any data) { LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_CASINO( int amount, bool p1, bool p2, Any data) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_CASINO(amount, p1, p2, &invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_CASINO( int amount, bool p1, bool p2, Any data) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_CASINO(amount, p1, p2, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CASINO_GENERIC( int amount, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CASINO_GENERIC(amount, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_TIME_TRIAL_WIN( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_TIME_TRIAL_WIN(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_COLLECTABLES_ACTION_FIGURES( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_COLLECTABLES_ACTION_FIGURES(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_COLLECTABLE_COMPLETED_COLLECTION( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_COLLECTABLE_COMPLETED_COLLECTION(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SELL_PRIZE_VEHICLE( int amount, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_SELL_PRIZE_VEHICLE(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_MISSION_REWARD( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_MISSION_REWARD(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_STORY_MISSION_REWARD( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_STORY_MISSION_REWARD(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_MISSION_PARTICIPATION( int amount) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_MISSION_PARTICIPATION(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_AWARD( int amount, unsigned hash) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_AWARD(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_ARCADE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_ARCADE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ARCADE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ARCADE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CASINO_HEIST( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CASINO_HEIST(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_ARCADE_MGMT( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_ARCADE_MGMT(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_PLAY_ARCADE( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_PLAY_ARCADE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_ARCADE( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_ARCADE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_HEIST( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_HEIST(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_UPGRADE_ARCADE( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_UPGRADE_ARCADE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ARCADE( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_EARN_ARCADE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_COLLECTABLES( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_COLLECTABLES(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CHALLENGE( int amount, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_CHALLENGE(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CASINO_HEIST_AWARDS( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_EARN_CASINO_HEIST_AWARDS(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_COLLECTABLE_ITEM( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_COLLECTABLE_ITEM(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_COLLECTABLE_COMPLETED_COLLECTION( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_COLLECTABLE_COMPLETED_COLLECTION(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_YATCH_MISSION( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_YATCH_MISSION(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DISPATCH_CALL( int amount, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_DISPATCH_CALL(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BEACH_PARTY( Any p0) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BEACH_PARTY(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SUBMARINE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SUBMARINE(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CASINO_CLUB( int amount1, Any p1, bool p2, Any p3, int p4, int p5, int p6, int amount2, Any p8) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CASINO_CLUB(amount1, p1, p2, p3, p4, p5, p6, amount2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_SUB( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_SUB(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_SUB( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_SUB(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_ISLAND_HEIST( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_ISLAND_HEIST(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_ISLAND_HEIST( int amount1, Any p1, Any p2, Any p3, int amount2, int p5) { invoke<void )
	{
		MONEY::NETWORK_EARN_ISLAND_HEIST(amount1, p1, p2, p3, amount2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BEACH_PARTY_LOST_FOUND( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_BEACH_PARTY_LOST_FOUND(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FROM_ISLAND_HEIST_DJ_MISSION( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FROM_ISLAND_HEIST_DJ_MISSION(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CAR_CLUB_MEMBERSHIP( int amount1, Any p1, Any p2, int amount2, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CAR_CLUB_MEMBERSHIP(amount1, p1, p2, amount2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CAR_CLUB_BAR( Any p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CAR_CLUB_BAR(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_AUTOSHOP_MODIFY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_AUTOSHOP_MODIFY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_CAR_CLUB_TAKEOVER( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_CAR_CLUB_TAKEOVER(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_AUTOSHOP( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_AUTOSHOP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_AUTOSHOP( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_AUTOSHOP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AUTOSHOP_BUSINESS( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_AUTOSHOP_BUSINESS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AUTOSHOP_INCOME( Any p0, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AUTOSHOP_INCOME(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_CARCLUB_MEMBERSHIP( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_CARCLUB_MEMBERSHIP(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAILY_VEHICLE( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAILY_VEHICLE(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAILY_VEHICLE_BONUS( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAILY_VEHICLE_BONUS(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_TUNER_AWARD( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_TUNER_AWARD(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_TUNER_ROBBERY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_EARN_TUNER_ROBBERY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_UPGRADE_AUTOSHOP( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_UPGRADE_AUTOSHOP(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_INTERACTION_MENU_ABILITY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_INTERACTION_MENU_ABILITY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SET_COMMON_FIELDS( Any p0, Any p1, Any p2, bool p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SET_COMMON_FIELDS(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SET_DISCOUNT( bool p0) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SET_DISCOUNT(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_AGENCY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_AGENCY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_AGENCY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_AGENCY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_AGENCY( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_AGENCY(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_HIDDEN( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_HIDDEN(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SOURCE_BIKE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SOURCE_BIKE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_COMP_SUV( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_COMP_SUV(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SUV_FST_TRVL( int p0, bool p1, bool p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SUV_FST_TRVL(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_SUPPLY( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_SUPPLY(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BIKE_SHOP( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BIKE_SHOP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_VEHICLE_REQUESTED( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		MONEY::NETWORK_SPEND_VEHICLE_REQUESTED(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_GUNRUNNING( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_GUNRUNNING(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AGENCY_SAFE( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_AGENCY_SAFE(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_CONTRACT( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_CONTRACT(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AGENCY_CONTRACT( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AGENCY_CONTRACT(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_PHONE( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_PHONE(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AGENCY_PHONE( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_AGENCY_PHONE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_FIXER_MISSION( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_FIXER_MISSION(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FIXER_PREP( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FIXER_PREP(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FIXER_FINALE( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FIXER_FINALE(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FIXER_AGENCY_SHORT_TRIP( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FIXER_AGENCY_SHORT_TRIP(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_SHORT_TRIP( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_SHORT_TRIP(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FIXER_RIVAL_DELIVERY( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FIXER_RIVAL_DELIVERY(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_UPGRADE_AGENCY( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_UPGRADE_AGENCY(p0, invoke<void);
	}

	Any data) { LUA_NATIVE_MONEY_NETWORK_SPEND_APARTMENT_UTILITIES( int amount, bool p1, bool p2, Any data) { invoke<void )
	{
		MONEY::NETWORK_SPEND_APARTMENT_UTILITIES(amount, p1, p2, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUSINESS_PROPERTY_FEES( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUSINESS_PROPERTY_FEES(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SIGHTSEEING_REWARD( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_EARN_SIGHTSEEING_REWARD(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BIKER_SHOP( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_BIKER_SHOP(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BIKER( Any p0) { invoke<void )
	{
		MONEY::NETWORK_EARN_BIKER(invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_YOHAN_SOURCE_GOODS( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_YOHAN_SOURCE_GOODS(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_MFGARAGE_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_MFGARAGE_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_MFGARAGE_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_MFGARAGE_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_SUPPLIES_( int p0, bool p1, bool p2, int p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_SUPPLIES_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_BUY_ACID_LAB_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_BUY_ACID_LAB_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ACID_LAB_EQUIPMENT_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ACID_LAB_EQUIPMENT_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ACID_LAB_ARMOR_( int p0, bool p1, bool p2, int p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ACID_LAB_ARMOR_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ACID_LAB_SCOOP_( int p0, bool p1, bool p2, int p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ACID_LAB_SCOOP_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_UPGRADE_ACID_LAB_MINES_( int p0, bool p1, bool p2, int p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_UPGRADE_ACID_LAB_MINES_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_RENAME_ACID_LAB_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_RENAME_ACID_LAB_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPEND_RENAME_ACID_PRODUCT_( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		MONEY::NETWORK_SPEND_RENAME_ACID_PRODUCT_(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_JUGGALO_MISSION_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_JUGGALO_MISSION_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_ACID_LAB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_ACID_LAB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_DAILY_STASH_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_DAILY_STASH_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_DEAD_DROP_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_DEAD_DROP_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_RANDOM_EVENT_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_RANDOM_EVENT_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AWARD_TAXI_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AWARD_TAXI_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_STREET_DEALER_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_STREET_DEALER_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SELL_ACID_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_SELL_ACID_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SETUP_PARTICIPATION_ACID_LAB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_SETUP_PARTICIPATION_ACID_LAB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SOURCE_PARTICIPATION_ACID_LAB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_SOURCE_PARTICIPATION_ACID_LAB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SELL_PARTICIPATION_ACID_LAB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_SELL_PARTICIPATION_ACID_LAB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_JUGGALO_STORY_MISSION_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_JUGGALO_STORY_MISSION_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_JUGGALO_STORY_MISSION_PARTICIPATION_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_JUGGALO_STORY_MISSION_PARTICIPATION_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FOOLIGAN_JOB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FOOLIGAN_JOB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_FOOLIGAN_JOB_PARTICIPATION_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_FOOLIGAN_JOB_PARTICIPATION_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_TAXI_JOB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_TAXI_JOB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAILY_STASH_HOUSE_COMPLETED_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAILY_STASH_HOUSE_COMPLETED_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_DAILY_STASH_HOUSE_PARTICIPATION_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_DAILY_STASH_HOUSE_PARTICIPATION_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_AVENGER_( int amount, int p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_AVENGER_(amount, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_SMUGGLER_OPS_( Any p0, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_SMUGGLER_OPS_(p0, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_BONUS_OBJECTIVE_( int amount, Any p1, Any p2) { invoke<void )
	{
		MONEY::NETWORK_EARN_BONUS_OBJECTIVE_(amount, p1, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_EARN_PROGRESS_HUB_( Any p0, Any p1) { invoke<void )
	{
		MONEY::NETWORK_EARN_PROGRESS_HUB_(p0, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_AIR_FREIGHT_( int hangarCargoSourcingPrice, bool fromBank, bool fromBankAndWallet, int cost, int warehouseId, int warehouseSlot) { invoke<void )
	{
		MONEY::NETWORK_SPENT_AIR_FREIGHT_(hangarCargoSourcingPrice, fromBank, fromBankAndWallet, cost, warehouseId, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_SKIP_CARGO_SOURCE_SETUP_( int amount, bool fromBank, bool fromBankAndWallet, int cost) { invoke<void )
	{
		MONEY::NETWORK_SPENT_SKIP_CARGO_SOURCE_SETUP_(amount, fromBank, fromBankAndWallet, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_STEALTH_MODULE_( int amount, bool fromBank, bool fromBankAndWallet, unsigned p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_STEALTH_MODULE_(amount, fromBank, fromBankAndWallet, invoke<void);
	}

	void LUA_NATIVE_MONEY_NETWORK_SPENT_MISSILE_JAMMER_( int amount, bool fromBank, bool fromBankAndWallet, unsigned p3) { invoke<void )
	{
		MONEY::NETWORK_SPENT_MISSILE_JAMMER_(amount, fromBank, fromBankAndWallet, invoke<void);
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_VC_BANK_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_VC_BANK_BALANCE();
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_VC_WALLET_BALANCE( int characterSlot) { return invoke<int )
	{
		auto retval = MONEY::NETWORK_GET_VC_WALLET_BALANCE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_VC_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_VC_BALANCE();
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_EVC_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_EVC_BALANCE();
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_PVC_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_PVC_BALANCE();
		return retval;
	}

	const char* LUA_NATIVE_MONEY_NETWORK_GET_STRING_WALLET_BALANCE( int characterSlot) { return invoke<const char* )
	{
		auto retval = MONEY::NETWORK_GET_STRING_WALLET_BALANCE(char*);
		return retval;
	}

	const char* LUA_NATIVE_MONEY_NETWORK_GET_STRING_BANK_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_STRING_BANK_BALANCE();
		return retval;
	}

	const char* LUA_NATIVE_MONEY_NETWORK_GET_STRING_BANK_WALLET_BALANCE( int character) { return invoke<const char* )
	{
		auto retval = MONEY::NETWORK_GET_STRING_BANK_WALLET_BALANCE(char*);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_GET_CAN_SPEND_FROM_WALLET( int amount, int characterSlot) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_GET_CAN_SPEND_FROM_WALLET(amount, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_GET_CAN_SPEND_FROM_BANK( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_GET_CAN_SPEND_FROM_BANK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_GET_CAN_SPEND_FROM_BANK_AND_WALLET( int amount, int characterSlot) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_GET_CAN_SPEND_FROM_BANK_AND_WALLET(amount, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_PVC_TRANSFER_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_PVC_TRANSFER_BALANCE();
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_GET_CAN_TRANSFER_CASH( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_GET_CAN_TRANSFER_CASH(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_NETWORK_CAN_RECEIVE_PLAYER_CASH( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::NETWORK_CAN_RECEIVE_PLAYER_CASH(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_MONEY_NETWORK_GET_REMAINING_TRANSFER_BALANCE(  )
	{
		auto retval = MONEY::NETWORK_GET_REMAINING_TRANSFER_BALANCE();
		return retval;
	}

	int LUA_NATIVE_MONEY_WITHDRAW_VC( int amount) { return invoke<int )
	{
		auto retval = MONEY::WITHDRAW_VC(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_MONEY_DEPOSIT_VC( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::DEPOSIT_VC(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_HAS_VC_WITHDRAWAL_COMPLETED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::HAS_VC_WITHDRAWAL_COMPLETED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_MONEY_WAS_VC_WITHDRAWAL_SUCCESSFUL( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)MONEY::WAS_VC_WITHDRAWAL_SUCCESSFUL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_USE_SERVER_TRANSACTIONS(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_USE_SERVER_TRANSACTIONS();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_CATALOG_ITEM_IS_VALID( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_CATALOG_ITEM_IS_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_CATALOG_ITEM_KEY_IS_VALID( unsigned hash) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_CATALOG_ITEM_KEY_IS_VALID(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_GET_PRICE( unsigned itemHash, unsigned categoryHash, bool p2) { return invoke<int )
	{
		auto retval = NETSHOPPING::NET_GAMESERVER_GET_PRICE(itemHash, categoryHash, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_CATALOG_IS_VALID(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_CATALOG_IS_VALID();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_IS_CATALOG_CURRENT(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_IS_CATALOG_CURRENT();
		return retval;
	}

	unsigned LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_GET_CATALOG_CLOUD_CRC(  )
	{
		auto retval = NETSHOPPING::NET_GAMESERVER_GET_CATALOG_CLOUD_CRC();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_REFRESH_SERVER_CATALOG(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_REFRESH_SERVER_CATALOG();
		return retval;
	}

	std::tuple<bool, int state) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_RETRIEVE_CATALOG_REFRESH_STATUS( int state) { return invoke<BOOL )
	{
		std::tuple<bool, int state) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_RETRIEVE_CATALOG_REFRESH_STATUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_INIT_SESSION(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_INIT_SESSION();
		return retval;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_RETRIEVE_INIT_SESSION_STATUS( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_RETRIEVE_INIT_SESSION_STATUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_START_SESSION( int charSlot) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_START_SESSION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_START_SESSION_PENDING(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_START_SESSION_PENDING();
		return retval;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_RETRIEVE_START_SESSION_STATUS( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_RETRIEVE_START_SESSION_STATUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_RETRIEVE_SESSION_ERROR_CODE( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_RETRIEVE_SESSION_ERROR_CODE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_IS_SESSION_VALID( int charSlot) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_IS_SESSION_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_CLEAR_SESSION( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_CLEAR_SESSION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_SESSION_APPLY_RECEIVED_DATA( int charSlot) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_SESSION_APPLY_RECEIVED_DATA(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_IS_SESSION_REFRESH_PENDING(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_IS_SESSION_REFRESH_PENDING();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_START_SESSION_RESTART( bool inventory, bool playerbalance) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_START_SESSION_RESTART(inventory, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSACTION_IN_PROGRESS(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_TRANSACTION_IN_PROGRESS();
		return retval;
	}

	std::tuple<bool, int, bool p1) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_GET_SESSION_STATE_AND_STATUS( int p0, bool p1) { return invoke<BOOL )
	{
		std::tuple<bool, int, bool p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_GET_SESSION_STATE_AND_STATUS(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_START( int transactionId, unsigned categoryHash, unsigned actionHash, int flags) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_START(&transactionId, categoryHash, actionHash, invoke<BOOL);
		std::get<1>(return_values) = transactionId;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_END(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_END();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_IS_ACTIVE(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_IS_ACTIVE();
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_ADD_ITEM( Any itemData, int quantity) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_ADD_ITEM(&itemData, invoke<BOOL);
		std::get<1>(return_values) = itemData;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_IS_FULL(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_IS_FULL();
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BASKET_APPLY_SERVER_DATA( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_BASKET_APPLY_SERVER_DATA(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_CHECKOUT_START( int transactionId) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_CHECKOUT_START(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int> LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_BEGIN_SERVICE( int transactionId, unsigned categoryHash, unsigned itemHash, unsigned actionTypeHash, int value, int flags) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)NETSHOPPING::NET_GAMESERVER_BEGIN_SERVICE(&transactionId, categoryHash, itemHash, actionTypeHash, value, invoke<BOOL);
		std::get<1>(return_values) = transactionId;

		return return_values;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_END_SERVICE( int transactionId) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_END_SERVICE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_DELETE_CHARACTER( int slot, bool transfer, unsigned reason) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_DELETE_CHARACTER(slot, transfer, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_DELETE_CHARACTER_GET_STATUS(  )
	{
		auto retval = NETSHOPPING::NET_GAMESERVER_DELETE_CHARACTER_GET_STATUS();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_DELETE_SET_TELEMETRY_NONCE_SEED(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_DELETE_SET_TELEMETRY_NONCE_SEED();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSFER_BANK_TO_WALLET( int charSlot, int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_TRANSFER_BANK_TO_WALLET(charSlot, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSFER_WALLET_TO_BANK( int charSlot, int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_TRANSFER_WALLET_TO_BANK(charSlot, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSFER_BANK_TO_WALLET_GET_STATUS(  )
	{
		auto retval = NETSHOPPING::NET_GAMESERVER_TRANSFER_BANK_TO_WALLET_GET_STATUS();
		return retval;
	}

	int LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSFER_WALLET_TO_BANK_GET_STATUS(  )
	{
		auto retval = NETSHOPPING::NET_GAMESERVER_TRANSFER_WALLET_TO_BANK_GET_STATUS();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_TRANSFER_CASH_SET_TELEMETRY_NONCE_SEED(  )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_TRANSFER_CASH_SET_TELEMETRY_NONCE_SEED();
		return retval;
	}

	bool LUA_NATIVE_NETSHOPPING_NET_GAMESERVER_SET_TELEMETRY_NONCE_SEED( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETSHOPPING::NET_GAMESERVER_SET_TELEMETRY_NONCE_SEED(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_ONLINE_VERSION(  )
	{
		auto retval = NETWORK::GET_ONLINE_VERSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SIGNED_IN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SIGNED_IN();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SIGNED_ONLINE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SIGNED_ONLINE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_NP_AVAILABLE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_NP_AVAILABLE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_NP_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_NP_PENDING();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NP_UNAVAILABLE_REASON(  )
	{
		auto retval = NETWORK::NETWORK_GET_NP_UNAVAILABLE_REASON();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CONNETED_TO_NP_PRESENCE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CONNETED_TO_NP_PRESENCE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_LOGGED_IN_TO_PSN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_LOGGED_IN_TO_PSN();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_VALID_ROS_CREDENTIALS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_VALID_ROS_CREDENTIALS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_REFRESHING_ROS_CREDENTIALS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_REFRESHING_ROS_CREDENTIALS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CLOUD_AVAILABLE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CLOUD_AVAILABLE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_SOCIAL_CLUB_ACCOUNT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_SOCIAL_CLUB_ACCOUNT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ARE_SOCIAL_CLUB_POLICIES_CURRENT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_ARE_SOCIAL_CLUB_POLICIES_CURRENT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_HOST(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_HOST();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_HOST_PLAYER_INDEX(  )
	{
		auto retval = NETWORK::NETWORK_GET_HOST_PLAYER_INDEX();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_WAS_GAME_SUSPENDED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_WAS_GAME_SUSPENDED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ONLINE_PRIVILEGES(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ONLINE_PRIVILEGES();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_AGE_RESTRICTIONS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_AGE_RESTRICTIONS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_USER_CONTENT_PRIVILEGES( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_USER_CONTENT_PRIVILEGES(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_COMMUNICATION_PRIVILEGES( int p0, int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_COMMUNICATION_PRIVILEGES(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_ONLINE_PRIVILEGES( Any p0, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_ONLINE_PRIVILEGES(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_USER_CONTENT_PRIVILEGES( int p0, int p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_USER_CONTENT_PRIVILEGES(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_COMMUNICATION_PRIVILEGES( int p0, int p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_COMMUNICATION_PRIVILEGES(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_TEXT_COMMUNICATION_PRIVILEGES( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_TEXT_COMMUNICATION_PRIVILEGES(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_USING_ONLINE_PROMOTION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_USING_ONLINE_PROMOTION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SHOULD_SHOW_PROMOTION_ALERT_SCREEN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SHOULD_SHOW_PROMOTION_ALERT_SCREEN();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_SOCIAL_NETWORKING_SHARING_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_SOCIAL_NETWORKING_SHARING_PRIV();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_AGE_GROUP(  )
	{
		auto retval = NETWORK::NETWORK_GET_AGE_GROUP();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_PRIVILEGES( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_PRIVILEGES(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PRIVILEGE_CHECK_IN_PROGRESS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PRIVILEGE_CHECK_IN_PROGRESS();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PRIVILEGE_CHECK_RESULT_NOT_NEEDED(  )
	{
		NETWORK::NETWORK_SET_PRIVILEGE_CHECK_RESULT_NOT_NEEDED();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_RESOLVE_PRIVILEGE_USER_CONTENT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_RESOLVE_PRIVILEGE_USER_CONTENT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_PLATFORM_SUBSCRIPTION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_PLATFORM_SUBSCRIPTION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLATFORM_SUBSCRIPTION_CHECK_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLATFORM_SUBSCRIPTION_CHECK_PENDING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SHOW_ACCOUNT_UPGRADE_UI(  )
	{
		NETWORK::NETWORK_SHOW_ACCOUNT_UPGRADE_UI();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SHOWING_SYSTEM_UI_OR_RECENTLY_REQUESTED_UPSELL(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SHOWING_SYSTEM_UI_OR_RECENTLY_REQUESTED_UPSELL();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_NEED_TO_START_NEW_GAME_BUT_BLOCKED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_NEED_TO_START_NEW_GAME_BUT_BLOCKED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CAN_BAIL(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CAN_BAIL();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_BAIL( int p0, int p1, int p2) { invoke<void )
	{
		NETWORK::NETWORK_BAIL(p0, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ON_RETURN_TO_SINGLE_PLAYER(  )
	{
		NETWORK::NETWORK_ON_RETURN_TO_SINGLE_PLAYER();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TRANSITION_START( int p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_TRANSITION_START(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TRANSITION_ADD_STAGE( unsigned hash, int p1, int p2, int state, int p4) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_TRANSITION_ADD_STAGE(hash, p1, p2, state, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TRANSITION_FINISH( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_TRANSITION_FINISH(p0, p1, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int loadingState) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_ACCESS_MULTIPLAYER( int loadingState) { return invoke<BOOL )
	{
		std::tuple<bool, int loadingState) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_ACCESS_MULTIPLAYER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_MULTIPLAYER_DISABLED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_MULTIPLAYER_DISABLED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CAN_ENTER_MULTIPLAYER(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CAN_ENTER_MULTIPLAYER();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_DO_FREEROAM_QUICKMATCH( Any p0, Any p1, Any p2, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_DO_FREEROAM_QUICKMATCH(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_DO_FRIEND_MATCHMAKING( int p0, int p1, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_DO_FRIEND_MATCHMAKING(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_DO_CREW_MATCHMAKING( int crewId, int p1, int p2, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_DO_CREW_MATCHMAKING(crewId, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_DO_ACTIVITY_QUICKMATCH( Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_DO_ACTIVITY_QUICKMATCH(p0, p1, p2, p3, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_HOST( int p0, int maxPlayers, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_HOST(p0, maxPlayers, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_HOST_CLOSED( int p0, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_HOST_CLOSED(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_HOST_FRIENDS_ONLY( int p0, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_HOST_FRIENDS_ONLY(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_CLOSED_FRIENDS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_CLOSED_FRIENDS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_CLOSED_CREW(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_CLOSED_CREW();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_SOLO(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_SOLO();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_PRIVATE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_PRIVATE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_END( bool p0, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_END(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_LEAVE( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_LEAVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_KICK_PLAYER( int player) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_KICK_PLAYER(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_GET_KICK_VOTE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_GET_KICK_VOTE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_RESERVE_SLOTS_TRANSITION( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_RESERVE_SLOTS_TRANSITION(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_JOIN_PREVIOUSLY_FAILED_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_JOIN_PREVIOUSLY_FAILED_SESSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_JOIN_PREVIOUSLY_FAILED_TRANSITION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_JOIN_PREVIOUSLY_FAILED_TRANSITION();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_MATCHMAKING_GROUP( int matchmakingGroup) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_MATCHMAKING_GROUP(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_MATCHMAKING_GROUP_MAX( int playerType, int playerCount) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_MATCHMAKING_GROUP_MAX(playerType, invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_SESSION_GET_MATCHMAKING_GROUP_FREE( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_SESSION_GET_MATCHMAKING_GROUP_FREE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_ADD_ACTIVE_MATCHMAKING_GROUP( int groupId) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_ADD_ACTIVE_MATCHMAKING_GROUP(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_UNIQUE_CREW_LIMIT( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_UNIQUE_CREW_LIMIT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_UNIQUE_CREW_LIMIT_TRANSITION( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_UNIQUE_CREW_LIMIT_TRANSITION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_UNIQUE_CREW_ONLY_CREWS_TRANSITION( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_UNIQUE_CREW_ONLY_CREWS_TRANSITION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_CREW_LIMIT_MAX_MEMBERS_TRANSITION( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_CREW_LIMIT_MAX_MEMBERS_TRANSITION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_MATCHMAKING_PROPERTY_ID( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_MATCHMAKING_PROPERTY_ID(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_MATCHMAKING_MENTAL_STATE( int p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_MATCHMAKING_MENTAL_STATE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_NUM_BOSSES( int num) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_NUM_BOSSES(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_SCRIPT_VALIDATE_JOIN(  )
	{
		NETWORK::NETWORK_SESSION_SET_SCRIPT_VALIDATE_JOIN();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_VALIDATE_JOIN( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_VALIDATE_JOIN(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_ADD_FOLLOWERS( int p0, int p1) { invoke<void )
	{
		NETWORK::NETWORK_ADD_FOLLOWERS(&p0, invoke<void);
		return p0;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_FOLLOWERS(  )
	{
		NETWORK::NETWORK_CLEAR_FOLLOWERS();
	}

	std::tuple<int, int, int seconds) {> LUA_NATIVE_NETWORK_NETWORK_GET_GLOBAL_MULTIPLAYER_CLOCK( int hours, int minutes, int seconds) { invoke<void )
	{
		std::tuple<int, int, int seconds) {> return_values;
		NETWORK::NETWORK_GET_GLOBAL_MULTIPLAYER_CLOCK(&hours, &minutes, &invoke<void);
		std::get<0>(return_values) = hours;
		std::get<1>(return_values) = minutes;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_SET_GAMEMODE( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_SET_GAMEMODE(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_SESSION_GET_HOST_AIM_PREFERENCE(  )
	{
		auto retval = NETWORK::NETWORK_SESSION_GET_HOST_AIM_PREFERENCE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_FIND_GAMERS_IN_CREW( int crewId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_FIND_GAMERS_IN_CREW(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_FIND_MATCHED_GAMERS( int attribute, float fallbackLimit, float lowerLimit, float upperLimit) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_FIND_MATCHED_GAMERS(attribute, fallbackLimit, lowerLimit, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_FINDING_GAMERS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_FINDING_GAMERS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DID_FIND_GAMERS_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_DID_FIND_GAMERS_SUCCEED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_FOUND_GAMERS(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_FOUND_GAMERS();
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_GET_FOUND_GAMER( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_FOUND_GAMER(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_FOUND_GAMERS(  )
	{
		NETWORK::NETWORK_CLEAR_FOUND_GAMERS();
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_QUEUE_GAMER_FOR_STATUS( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_QUEUE_GAMER_FOR_STATUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_GAMER_STATUS_FROM_QUEUE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_GAMER_STATUS_FROM_QUEUE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_GETTING_GAMER_STATUS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_GETTING_GAMER_STATUS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DID_GET_GAMER_STATUS_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_DID_GET_GAMER_STATUS_SUCCEED();
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_GET_GAMER_STATUS_RESULT( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_GAMER_STATUS_RESULT(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_GET_GAMER_STATUS(  )
	{
		NETWORK::NETWORK_CLEAR_GET_GAMER_STATUS();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_JOIN_INVITE(  )
	{
		NETWORK::NETWORK_SESSION_JOIN_INVITE();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_CANCEL_INVITE(  )
	{
		NETWORK::NETWORK_SESSION_CANCEL_INVITE();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_FORCE_CANCEL_INVITE(  )
	{
		NETWORK::NETWORK_SESSION_FORCE_CANCEL_INVITE();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_PENDING_INVITE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_PENDING_INVITE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CONFIRMED_INVITE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CONFIRMED_INVITE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REQUEST_INVITE_CONFIRMED_EVENT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_REQUEST_INVITE_CONFIRMED_EVENT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_WAS_INVITED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_WAS_INVITED();
		return retval;
	}

	Any gamerHandle) { LUA_NATIVE_NETWORK_NETWORK_SESSION_GET_INVITER( Any gamerHandle) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_GET_INVITER(&invoke<void);
		return invoke<void;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_AWAITING_INVITE_RESPONSE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_AWAITING_INVITE_RESPONSE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_DISPLAYING_INVITE_CONFIRMATION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_DISPLAYING_INVITE_CONFIRMATION();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SUPPRESS_INVITE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SUPPRESS_INVITE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_BLOCK_INVITES( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_BLOCK_INVITES(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_BLOCK_JOIN_QUEUE_INVITES( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_BLOCK_JOIN_QUEUE_INVITES(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_CAN_RECEIVE_RS_INVITES( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_CAN_RECEIVE_RS_INVITES(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_STORE_INVITE_THROUGH_RESTART(  )
	{
		NETWORK::NETWORK_STORE_INVITE_THROUGH_RESTART();
	}

	void LUA_NATIVE_NETWORK_NETWORK_ALLOW_INVITE_PROCESS_IN_PLAYER_SWITCH( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_ALLOW_INVITE_PROCESS_IN_PLAYER_SWITCH(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_SCRIPT_READY_FOR_EVENTS( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_SCRIPT_READY_FOR_EVENTS(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_OFFLINE_INVITE_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_OFFLINE_INVITE_PENDING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_OFFLINE_INVITE_PENDING(  )
	{
		NETWORK::NETWORK_CLEAR_OFFLINE_INVITE_PENDING();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_HOST_SINGLE_PLAYER( int p0) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_HOST_SINGLE_PLAYER(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_LEAVE_SINGLE_PLAYER(  )
	{
		NETWORK::NETWORK_SESSION_LEAVE_SINGLE_PLAYER();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_GAME_IN_PROGRESS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_GAME_IN_PROGRESS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SESSION_ACTIVE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SESSION_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_SESSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SESSION_STARTED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SESSION_STARTED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SESSION_BUSY(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SESSION_BUSY();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CAN_SESSION_END(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CAN_SESSION_END();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_GAME_MODE(  )
	{
		auto retval = NETWORK::NETWORK_GET_GAME_MODE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_MARK_VISIBLE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_MARK_VISIBLE(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_VISIBLE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_VISIBLE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_BLOCK_JOIN_REQUESTS( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_BLOCK_JOIN_REQUESTS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_CHANGE_SLOTS( int slots, bool p1) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_CHANGE_SLOTS(slots, invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_SESSION_GET_PRIVATE_SLOTS(  )
	{
		auto retval = NETWORK::NETWORK_SESSION_GET_PRIVATE_SLOTS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_VOICE_HOST(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_VOICE_HOST();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_VOICE_LEAVE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_VOICE_LEAVE();
		return retval;
	}

	Any gamerHandle) { LUA_NATIVE_NETWORK_NETWORK_SESSION_VOICE_CONNECT_TO_PLAYER( Any gamerHandle) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_VOICE_CONNECT_TO_PLAYER(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_VOICE_RESPOND_TO_REQUEST( bool p0, int p1) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_VOICE_RESPOND_TO_REQUEST(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SESSION_VOICE_SET_TIMEOUT( int timeout) { invoke<void )
	{
		NETWORK::NETWORK_SESSION_VOICE_SET_TIMEOUT(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_IN_VOICE_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_IN_VOICE_SESSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_VOICE_SESSION_ACTIVE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_VOICE_SESSION_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SESSION_IS_VOICE_SESSION_BUSY(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SESSION_IS_VOICE_SESSION_BUSY();
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_SEND_TEXT_MESSAGE( const char* message, Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SEND_TEXT_MESSAGE(message, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ACTIVITY_SPECTATOR( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_ACTIVITY_SPECTATOR(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ACTIVITY_SPECTATOR(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ACTIVITY_SPECTATOR();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ACTIVITY_PLAYER_MAX( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_ACTIVITY_PLAYER_MAX(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ACTIVITY_SPECTATOR_MAX( int maxSpectators) { invoke<void )
	{
		NETWORK::NETWORK_SET_ACTIVITY_SPECTATOR_MAX(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_ACTIVITY_PLAYER_NUM( bool p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_ACTIVITY_PLAYER_NUM(invoke<int);
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_ACTIVITY_SPECTATOR_FROM_HANDLE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_ACTIVITY_SPECTATOR_FROM_HANDLE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HOST_TRANSITION( int p0, int p1, int p2, int p3, Any p4, bool p5, bool p6, int p7, Any p8, int p9) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HOST_TRANSITION(p0, p1, p2, p3, p4, p5, p6, p7, p8, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_QUICKMATCH( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DO_TRANSITION_QUICKMATCH(p0, p1, p2, p3, p4, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_QUICKMATCH_ASYNC( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DO_TRANSITION_QUICKMATCH_ASYNC(p0, p1, p2, p3, p4, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_QUICKMATCH_WITH_GROUP( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_DO_TRANSITION_QUICKMATCH_WITH_GROUP(p0, p1, p2, p3, &p4, p5, p6, invoke<BOOL);
		std::get<1>(return_values) = p4;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_JOIN_GROUP_ACTIVITY(  )
	{
		auto retval = (bool)NETWORK::NETWORK_JOIN_GROUP_ACTIVITY();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_GROUP_ACTIVITY(  )
	{
		NETWORK::NETWORK_CLEAR_GROUP_ACTIVITY();
	}

	void LUA_NATIVE_NETWORK_NETWORK_RETAIN_ACTIVITY_GROUP(  )
	{
		NETWORK::NETWORK_RETAIN_ACTIVITY_GROUP();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_CLOSED_FRIENDS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_CLOSED_FRIENDS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_CLOSED_CREW(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_CLOSED_CREW();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_SOLO(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_SOLO();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_PRIVATE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_PRIVATE();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_TRANSITION_NON_ASYNC_GAMERS(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_TRANSITION_NON_ASYNC_GAMERS();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_MARK_AS_PREFERRED_ACTIVITY( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_MARK_AS_PREFERRED_ACTIVITY(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_MARK_AS_WAITING_ASYNC( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_MARK_AS_WAITING_ASYNC(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IN_PROGRESS_FINISH_TIME( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_IN_PROGRESS_FINISH_TIME(invoke<void);
	}

	Any p0) { LUA_NATIVE_NETWORK_NETWORK_SET_TRANSITION_CREATOR_HANDLE( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_TRANSITION_CREATOR_HANDLE(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_TRANSITION_CREATOR_HANDLE(  )
	{
		NETWORK::NETWORK_CLEAR_TRANSITION_CREATOR_HANDLE();
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_INVITE_GAMERS_TO_TRANSITION( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_INVITE_GAMERS_TO_TRANSITION(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	Any gamerHandle) { LUA_NATIVE_NETWORK_NETWORK_SET_GAMER_INVITED_TO_TRANSITION( Any gamerHandle) { invoke<void )
	{
		NETWORK::NETWORK_SET_GAMER_INVITED_TO_TRANSITION(&invoke<void);
		return invoke<void;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_LEAVE_TRANSITION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_LEAVE_TRANSITION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_LAUNCH_TRANSITION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_LAUNCH_TRANSITION();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_DO_NOT_LAUNCH_FROM_JOIN_AS_MIGRATED_HOST( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_DO_NOT_LAUNCH_FROM_JOIN_AS_MIGRATED_HOST(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CANCEL_TRANSITION_MATCHMAKING(  )
	{
		NETWORK::NETWORK_CANCEL_TRANSITION_MATCHMAKING();
	}

	void LUA_NATIVE_NETWORK_NETWORK_BAIL_TRANSITION( int p0, int p1, int p2) { invoke<void )
	{
		NETWORK::NETWORK_BAIL_TRANSITION(p0, p1, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_TO_GAME( bool p0, int maxPlayers) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DO_TRANSITION_TO_GAME(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_TO_NEW_GAME( bool p0, int maxPlayers, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DO_TRANSITION_TO_NEW_GAME(p0, maxPlayers, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_TO_FREEMODE( Any p0, Any p1, bool p2, int players, bool p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_DO_TRANSITION_TO_FREEMODE(&p0, p1, p2, players, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_DO_TRANSITION_TO_NEW_FREEMODE( Any p0, Any p1, int players, bool p3, bool p4, bool p5) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_DO_TRANSITION_TO_NEW_FREEMODE(&p0, p1, players, p3, p4, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_TO_GAME(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_TO_GAME();
		return retval;
	}

	std::tuple<int, Any> LUA_NATIVE_NETWORK_NETWORK_GET_TRANSITION_MEMBERS( Any data, int dataCount) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_TRANSITION_MEMBERS(&data, invoke<int);
		std::get<1>(return_values) = data;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_APPLY_TRANSITION_PARAMETER( int p0, int p1) { invoke<void )
	{
		NETWORK::NETWORK_APPLY_TRANSITION_PARAMETER(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_APPLY_TRANSITION_PARAMETER_STRING( int p0, const char* string, bool p2) { invoke<void )
	{
		NETWORK::NETWORK_APPLY_TRANSITION_PARAMETER_STRING(p0, string, invoke<void);
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_SEND_TRANSITION_GAMER_INSTRUCTION( Any gamerHandle, const char* p1, int p2, int p3, bool p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SEND_TRANSITION_GAMER_INSTRUCTION(&gamerHandle, p1, p2, p3, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_MARK_TRANSITION_GAMER_AS_FULLY_JOINED( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_MARK_TRANSITION_GAMER_AS_FULLY_JOINED(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_HOST(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_HOST();
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_HOST_FROM_HANDLE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_TRANSITION_HOST_FROM_HANDLE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_GET_TRANSITION_HOST( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_TRANSITION_HOST(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_TRANSITION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_TRANSITION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_STARTED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_STARTED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_BUSY(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_BUSY();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_MATCHMAKING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_MATCHMAKING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_LEAVE_POSTPONED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_LEAVE_POSTPONED();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRANSITION_SET_IN_PROGRESS( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_TRANSITION_SET_IN_PROGRESS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRANSITION_SET_CONTENT_CREATOR( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_TRANSITION_SET_CONTENT_CREATOR(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRANSITION_SET_ACTIVITY_ISLAND( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_TRANSITION_SET_ACTIVITY_ISLAND(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OPEN_TRANSITION_MATCHMAKING(  )
	{
		NETWORK::NETWORK_OPEN_TRANSITION_MATCHMAKING();
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLOSE_TRANSITION_MATCHMAKING(  )
	{
		NETWORK::NETWORK_CLOSE_TRANSITION_MATCHMAKING();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_OPEN_TO_MATCHMAKING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_OPEN_TO_MATCHMAKING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_TRANSITION_VISIBILITY_LOCK( bool p0, bool p1) { invoke<void )
	{
		NETWORK::NETWORK_SET_TRANSITION_VISIBILITY_LOCK(p0, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TRANSITION_VISIBILITY_LOCKED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TRANSITION_VISIBILITY_LOCKED();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_TRANSITION_ACTIVITY_ID( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_TRANSITION_ACTIVITY_ID(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CHANGE_TRANSITION_SLOTS( Any p0, bool p1) { invoke<void )
	{
		NETWORK::NETWORK_CHANGE_TRANSITION_SLOTS(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRANSITION_BLOCK_JOIN_REQUESTS( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_TRANSITION_BLOCK_JOIN_REQUESTS(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_PLAYER_STARTED_TRANSITION( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_PLAYER_STARTED_TRANSITION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ARE_TRANSITION_DETAILS_VALID( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ARE_TRANSITION_DETAILS_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_JOIN_TRANSITION( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_JOIN_TRANSITION(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_INVITED_GAMER_TO_TRANSITION( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_INVITED_GAMER_TO_TRANSITION(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_TRANSITION_INVITE_BEEN_ACKED( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_TRANSITION_INVITE_BEEN_ACKED(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ACTIVITY_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ACTIVITY_SESSION();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_DISABLE_REALTIME_MULTIPLAYER(  )
	{
		NETWORK::NETWORK_DISABLE_REALTIME_MULTIPLAYER();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PRESENCE_SESSION_INVITES_BLOCKED( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_PRESENCE_SESSION_INVITES_BLOCKED(invoke<void);
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_SEND_INVITE_VIA_PRESENCE( Any gamerHandle, const char* p1, int dataCount, int p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SEND_INVITE_VIA_PRESENCE(&gamerHandle, p1, dataCount, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_SEND_TRANSITION_INVITE_VIA_PRESENCE( Any gamerHandle, const char* p1, int dataCount, int p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SEND_TRANSITION_INVITE_VIA_PRESENCE(&gamerHandle, p1, dataCount, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_SEND_IMPORTANT_TRANSITION_INVITE_VIA_PRESENCE( Any gamerHandle, const char* p1, int dataCount, int p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SEND_IMPORTANT_TRANSITION_INVITE_VIA_PRESENCE(&gamerHandle, p1, dataCount, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_INDEX_BY_ID( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_INDEX_BY_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_PRESENCE_INVITES(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_PRESENCE_INVITES();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ACCEPT_PRESENCE_INVITE( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ACCEPT_PRESENCE_INVITE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REMOVE_PRESENCE_INVITE( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_REMOVE_PRESENCE_INVITE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_ID( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_ID(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_INVITER( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_INVITER(char*);
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_HANDLE( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_PRESENCE_INVITE_HANDLE(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_SESSION_ID( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_SESSION_ID(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_CONTENT_ID( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_CONTENT_ID(char*);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_PLAYLIST_LENGTH( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_PLAYLIST_LENGTH(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_PLAYLIST_CURRENT( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PRESENCE_INVITE_PLAYLIST_CURRENT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_FROM_ADMIN( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PRESENCE_INVITE_FROM_ADMIN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PRESENCE_INVITE_IS_TOURNAMENT( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PRESENCE_INVITE_IS_TOURNAMENT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_FOLLOW_INVITE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_FOLLOW_INVITE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ACTION_FOLLOW_INVITE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_ACTION_FOLLOW_INVITE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLEAR_FOLLOW_INVITE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CLEAR_FOLLOW_INVITE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMOVE_AND_CANCEL_ALL_INVITES(  )
	{
		NETWORK::NETWORK_REMOVE_AND_CANCEL_ALL_INVITES();
	}

	Any p0) { LUA_NATIVE_NETWORK_NETWORK_REMOVE_TRANSITION_INVITE( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_REMOVE_TRANSITION_INVITE(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMOVE_ALL_TRANSITION_INVITE(  )
	{
		NETWORK::NETWORK_REMOVE_ALL_TRANSITION_INVITE();
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMOVE_AND_CANCEL_ALL_TRANSITION_INVITES(  )
	{
		NETWORK::NETWORK_REMOVE_AND_CANCEL_ALL_TRANSITION_INVITES();
	}

	std::tuple<bool, Any, Any> LUA_NATIVE_NETWORK_NETWORK_INVITE_GAMERS( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_INVITE_GAMERS(&p0, p1, &p2, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p2;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_INVITED_GAMER( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_INVITED_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_MADE_INVITE_DECISION( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_MADE_INVITE_DECISION(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_INVITE_REPLY_STATUS( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_INVITE_REPLY_STATUS(invoke<int);
		return retval;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_GET_CURRENTLY_SELECTED_GAMER_HANDLE_FROM_INVITE_MENU( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_CURRENTLY_SELECTED_GAMER_HANDLE_FROM_INVITE_MENU(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_SET_CURRENTLY_SELECTED_GAMER_HANDLE_FROM_INVITE_MENU( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SET_CURRENTLY_SELECTED_GAMER_HANDLE_FROM_INVITE_MENU(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	Any p0) { LUA_NATIVE_NETWORK_NETWORK_SET_INVITE_ON_CALL_FOR_INVITE_MENU( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_INVITE_ON_CALL_FOR_INVITE_MENU(&invoke<void);
		return invoke<void;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CHECK_DATA_MANAGER_SUCCEEDED_FOR_HANDLE( int p0, Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CHECK_DATA_MANAGER_SUCCEEDED_FOR_HANDLE(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CHECK_DATA_MANAGER_FOR_HANDLE( Any p0, Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CHECK_DATA_MANAGER_FOR_HANDLE(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<Any, Any p1) {> LUA_NATIVE_NETWORK_NETWORK_SET_INVITE_FAILED_MESSAGE_FOR_INVITE_MENU( Any p0, Any p1) { invoke<void )
	{
		std::tuple<Any, Any p1) {> return_values;
		NETWORK::NETWORK_SET_INVITE_FAILED_MESSAGE_FOR_INVITE_MENU(&p0, &invoke<void);
		std::get<0>(return_values) = p0;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_FILLOUT_PM_PLAYER_LIST( Any gamerHandle, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::FILLOUT_PM_PLAYER_LIST(&gamerHandle, p1, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	std::tuple<bool, Any, Any> LUA_NATIVE_NETWORK_FILLOUT_PM_PLAYER_LIST_WITH_NAMES( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::FILLOUT_PM_PLAYER_LIST_WITH_NAMES(&p0, &p1, p2, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_REFRESH_PLAYER_LIST_STATS( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::REFRESH_PLAYER_LIST_STATS(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_SET_CURRENT_DATA_MANAGER_HANDLE( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_SET_CURRENT_DATA_MANAGER_HANDLE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_PLATFORM_PARTY(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_PLATFORM_PARTY();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PLATFORM_PARTY_MEMBER_COUNT(  )
	{
		auto retval = NETWORK::NETWORK_GET_PLATFORM_PARTY_MEMBER_COUNT();
		return retval;
	}

	std::tuple<int, Any> LUA_NATIVE_NETWORK_NETWORK_GET_PLATFORM_PARTY_MEMBERS( Any data, int dataSize) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_PLATFORM_PARTY_MEMBERS(&data, invoke<int);
		std::get<1>(return_values) = data;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_PLATFORM_PARTY_CHAT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_PLATFORM_PARTY_CHAT();
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_CHATTING_IN_PLATFORM_PARTY( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_CHATTING_IN_PLATFORM_PARTY(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CAN_QUEUE_FOR_PREVIOUS_SESSION_JOIN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CAN_QUEUE_FOR_PREVIOUS_SESSION_JOIN();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_QUEUING_FOR_SESSION_JOIN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_QUEUING_FOR_SESSION_JOIN();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_QUEUED_JOIN_REQUEST(  )
	{
		NETWORK::NETWORK_CLEAR_QUEUED_JOIN_REQUEST();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SEND_QUEUED_JOIN_REQUEST(  )
	{
		NETWORK::NETWORK_SEND_QUEUED_JOIN_REQUEST();
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMOVE_ALL_QUEUED_JOIN_REQUESTS(  )
	{
		NETWORK::NETWORK_REMOVE_ALL_QUEUED_JOIN_REQUESTS();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SEED_RANDOM_NUMBER_GENERATOR( int seed) { invoke<void )
	{
		NETWORK::NETWORK_SEED_RANDOM_NUMBER_GENERATOR(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_RANDOM_INT(  )
	{
		auto retval = NETWORK::NETWORK_GET_RANDOM_INT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_RANDOM_INT_RANGED( int rangeStart, int rangeEnd) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_RANDOM_INT_RANGED(rangeStart, invoke<int);
		return retval;
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_RANDOM_FLOAT_RANGED_( float rangeStart, float rangeEnd) { return invoke<float )
	{
		auto retval = NETWORK::NETWORK_GET_RANDOM_FLOAT_RANGED_(rangeStart, invoke<float);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_PLAYER_IS_CHEATER(  )
	{
		auto retval = (bool)NETWORK::NETWORK_PLAYER_IS_CHEATER();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_PLAYER_GET_CHEATER_REASON(  )
	{
		auto retval = NETWORK::NETWORK_PLAYER_GET_CHEATER_REASON();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_PLAYER_IS_BADSPORT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_PLAYER_IS_BADSPORT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_REMOTE_CHEATER_PLAYER_DETECTED( int player, int a, int b) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::REMOTE_CHEATER_PLAYER_DETECTED(player, a, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_BAD_SPORT_PLAYER_LEFT_DETECTED( Any gamerHandle, int event, int amountReceived) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::BAD_SPORT_PLAYER_LEFT_DETECTED(&gamerHandle, event, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_INVALID_OBJECT_MODEL( unsigned modelHash) { invoke<void )
	{
		NETWORK::NETWORK_ADD_INVALID_OBJECT_MODEL(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMOVE_INVALID_OBJECT_MODEL( unsigned modelHash) { invoke<void )
	{
		NETWORK::NETWORK_REMOVE_INVALID_OBJECT_MODEL(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_INVALID_OBJECT_MODELS(  )
	{
		NETWORK::NETWORK_CLEAR_INVALID_OBJECT_MODELS();
	}

	void LUA_NATIVE_NETWORK_NETWORK_APPLY_PED_SCAR_DATA( int ped, int p1) { invoke<void )
	{
		NETWORK::NETWORK_APPLY_PED_SCAR_DATA(ped, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_THIS_SCRIPT_IS_NETWORK_SCRIPT( int maxNumMissionParticipants, bool p1, int instanceId) { invoke<void )
	{
		NETWORK::NETWORK_SET_THIS_SCRIPT_IS_NETWORK_SCRIPT(maxNumMissionParticipants, p1, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TRY_TO_SET_THIS_SCRIPT_IS_NETWORK_SCRIPT( Any p0, bool p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_TRY_TO_SET_THIS_SCRIPT_IS_NETWORK_SCRIPT(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_THIS_SCRIPT_IS_NETWORK_SCRIPT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_THIS_SCRIPT_IS_NETWORK_SCRIPT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_MAX_NUM_PARTICIPANTS(  )
	{
		auto retval = NETWORK::NETWORK_GET_MAX_NUM_PARTICIPANTS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_PARTICIPANTS(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_PARTICIPANTS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_SCRIPT_STATUS(  )
	{
		auto retval = NETWORK::NETWORK_GET_SCRIPT_STATUS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_REGISTER_HOST_BROADCAST_VARIABLES( int vars, int numVars, const char* debugName) { invoke<void )
	{
		NETWORK::NETWORK_REGISTER_HOST_BROADCAST_VARIABLES(&vars, numVars, invoke<void);
		return vars;
	}

	int LUA_NATIVE_NETWORK_NETWORK_REGISTER_PLAYER_BROADCAST_VARIABLES( int vars, int numVars, const char* debugName) { invoke<void )
	{
		NETWORK::NETWORK_REGISTER_PLAYER_BROADCAST_VARIABLES(&vars, numVars, invoke<void);
		return vars;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REGISTER_HIGH_FREQUENCY_HOST_BROADCAST_VARIABLES( Any p0, Any p1, Any p2) { invoke<void )
	{
		NETWORK::NETWORK_REGISTER_HIGH_FREQUENCY_HOST_BROADCAST_VARIABLES(p0, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_REGISTER_HIGH_FREQUENCY_PLAYER_BROADCAST_VARIABLES( Any p0, Any p1, Any p2) { invoke<void )
	{
		NETWORK::NETWORK_REGISTER_HIGH_FREQUENCY_PLAYER_BROADCAST_VARIABLES(p0, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_FINISH_BROADCASTING_DATA(  )
	{
		NETWORK::NETWORK_FINISH_BROADCASTING_DATA();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_RECEIVED_HOST_BROADCAST_DATA(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_RECEIVED_HOST_BROADCAST_DATA();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_INDEX( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PLAYER_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PARTICIPANT_INDEX( int index) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PARTICIPANT_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_INDEX_FROM_PED( int ped) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PLAYER_INDEX_FROM_PED(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_CONNECTED_PLAYERS(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_CONNECTED_PLAYERS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_CONNECTED( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_CONNECTED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_TOTAL_NUM_PLAYERS(  )
	{
		auto retval = NETWORK::NETWORK_GET_TOTAL_NUM_PLAYERS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PARTICIPANT_ACTIVE( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PARTICIPANT_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_ACTIVE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_A_PARTICIPANT( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_A_PARTICIPANT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_HOST_OF_THIS_SCRIPT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_HOST_OF_THIS_SCRIPT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_HOST_OF_THIS_SCRIPT(  )
	{
		auto retval = NETWORK::NETWORK_GET_HOST_OF_THIS_SCRIPT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_HOST_OF_SCRIPT( const char* scriptName, int instance_id, int position_hash) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_HOST_OF_SCRIPT(scriptName, instance_id, invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_MISSION_FINISHED(  )
	{
		NETWORK::NETWORK_SET_MISSION_FINISHED();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SCRIPT_ACTIVE( const char* scriptName, int instance_id, bool p2, int position_hash) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SCRIPT_ACTIVE(scriptName, instance_id, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_SCRIPT_ACTIVE_BY_HASH( unsigned scriptHash, int p1, bool p2, int p3) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_SCRIPT_ACTIVE_BY_HASH(scriptHash, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_THREAD_A_NETWORK_SCRIPT( int threadId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_THREAD_A_NETWORK_SCRIPT(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_SCRIPT_PARTICIPANTS( const char* scriptName, int instance_id, int position_hash) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_SCRIPT_PARTICIPANTS(scriptName, instance_id, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_INSTANCE_ID_OF_THIS_SCRIPT(  )
	{
		auto retval = NETWORK::NETWORK_GET_INSTANCE_ID_OF_THIS_SCRIPT();
		return retval;
	}

	unsigned LUA_NATIVE_NETWORK_NETWORK_GET_POSITION_HASH_OF_THIS_SCRIPT(  )
	{
		auto retval = NETWORK::NETWORK_GET_POSITION_HASH_OF_THIS_SCRIPT();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_A_PARTICIPANT_ON_SCRIPT( int player, const char* script, int instance_id) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_A_PARTICIPANT_ON_SCRIPT(player, script, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_PREVENT_SCRIPT_HOST_MIGRATION(  )
	{
		NETWORK::NETWORK_PREVENT_SCRIPT_HOST_MIGRATION();
	}

	void LUA_NATIVE_NETWORK_NETWORK_REQUEST_TO_BE_HOST_OF_THIS_SCRIPT(  )
	{
		NETWORK::NETWORK_REQUEST_TO_BE_HOST_OF_THIS_SCRIPT();
	}

	int LUA_NATIVE_NETWORK_PARTICIPANT_ID(  )
	{
		auto retval = NETWORK::PARTICIPANT_ID();
		return retval;
	}

	int LUA_NATIVE_NETWORK_PARTICIPANT_ID_TO_INT(  )
	{
		auto retval = NETWORK::PARTICIPANT_ID_TO_INT();
		return retval;
	}

	std::tuple<int, unsigned weaponHash) { return> LUA_NATIVE_NETWORK_NETWORK_GET_KILLER_OF_PLAYER( int player, unsigned weaponHash) { return invoke<int )
	{
		std::tuple<int, unsigned weaponHash) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_KILLER_OF_PLAYER(player, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, unsigned weaponHash) { return> LUA_NATIVE_NETWORK_NETWORK_GET_DESTROYER_OF_NETWORK_ID( int netId, unsigned weaponHash) { return invoke<int )
	{
		std::tuple<int, unsigned weaponHash) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_DESTROYER_OF_NETWORK_ID(netId, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, unsigned weaponHash) { return> LUA_NATIVE_NETWORK_NETWORK_GET_DESTROYER_OF_ENTITY( int entity, unsigned weaponHash) { return invoke<int )
	{
		std::tuple<int, unsigned weaponHash) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_DESTROYER_OF_ENTITY(entity, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<bool, int p2) { return> LUA_NATIVE_NETWORK_NETWORK_GET_ASSISTED_KILL_OF_ENTITY( int player, int entity, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int p2) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_ASSISTED_KILL_OF_ENTITY(player, entity, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int p2) { return> LUA_NATIVE_NETWORK_NETWORK_GET_ASSISTED_DAMAGE_OF_ENTITY( int player, int entity, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int p2) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_ASSISTED_DAMAGE_OF_ENTITY(player, entity, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<int, unsigned weaponHash) { return> LUA_NATIVE_NETWORK_NETWORK_GET_ENTITY_KILLER_OF_PLAYER( int player, unsigned weaponHash) { return invoke<int )
	{
		std::tuple<int, unsigned weaponHash) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_ENTITY_KILLER_OF_PLAYER(player, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_CURRENT_PUBLIC_CONTENT_ID( const char* missionId) { invoke<void )
	{
		NETWORK::NETWORK_SET_CURRENT_PUBLIC_CONTENT_ID(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_CURRENT_CHAT_OPTION( int newChatOption) { invoke<void )
	{
		NETWORK::NETWORK_SET_CURRENT_CHAT_OPTION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_CURRENT_SPAWN_LOCATION_OPTION( unsigned mpSettingSpawn) { invoke<void )
	{
		NETWORK::NETWORK_SET_CURRENT_SPAWN_LOCATION_OPTION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_VEHICLE_DRIVEN_IN_TEST_DRIVE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_VEHICLE_DRIVEN_IN_TEST_DRIVE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_VEHICLE_DRIVEN_LOCATION( unsigned location) { invoke<void )
	{
		NETWORK::NETWORK_SET_VEHICLE_DRIVEN_LOCATION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_RESURRECT_LOCAL_PLAYER( float x, float y, float z, float heading, bool p4, bool changetime, bool p6, int p7, int p8) { invoke<void )
	{
		NETWORK::NETWORK_RESURRECT_LOCAL_PLAYER(x, y, z, heading, p4, changetime, p6, p7, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_LOCAL_PLAYER_INVINCIBLE_TIME( int time) { invoke<void )
	{
		NETWORK::NETWORK_SET_LOCAL_PLAYER_INVINCIBLE_TIME(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_LOCAL_PLAYER_INVINCIBLE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_LOCAL_PLAYER_INVINCIBLE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_DISABLE_INVINCIBLE_FLASHING( int player, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_DISABLE_INVINCIBLE_FLASHING(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_PATCH_POST_CUTSCENE_HS4F_TUN_ENT( int ped) { invoke<void )
	{
		NETWORK::NETWORK_PATCH_POST_CUTSCENE_HS4F_TUN_ENT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_LOCAL_PLAYER_SYNC_LOOK_AT( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_LOCAL_PLAYER_SYNC_LOOK_AT(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_ENTITY_BEEN_REGISTERED_WITH_THIS_THREAD( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_ENTITY_BEEN_REGISTERED_WITH_THIS_THREAD(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NETWORK_ID_FROM_ENTITY( int entity) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_NETWORK_ID_FROM_ENTITY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_ENTITY_FROM_NETWORK_ID( int netId) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_ENTITY_FROM_NETWORK_ID(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_ENTITY_IS_NETWORKED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_ENTITY_IS_NETWORKED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_ENTITY_IS_LOCAL( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_ENTITY_IS_LOCAL(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REGISTER_ENTITY_AS_NETWORKED( int entity) { invoke<void )
	{
		NETWORK::NETWORK_REGISTER_ENTITY_AS_NETWORKED(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_UNREGISTER_NETWORKED_ENTITY( int entity) { invoke<void )
	{
		NETWORK::NETWORK_UNREGISTER_NETWORKED_ENTITY(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DOES_NETWORK_ID_EXIST( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DOES_NETWORK_ID_EXIST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DOES_ENTITY_EXIST_WITH_NETWORK_ID( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DOES_ENTITY_EXIST_WITH_NETWORK_ID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REQUEST_CONTROL_OF_NETWORK_ID( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_REQUEST_CONTROL_OF_NETWORK_ID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CONTROL_OF_NETWORK_ID( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CONTROL_OF_NETWORK_ID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_NETWORK_ID_REMOTELY_CONTROLLED( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_NETWORK_ID_REMOTELY_CONTROLLED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REQUEST_CONTROL_OF_ENTITY( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_REQUEST_CONTROL_OF_ENTITY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REQUEST_CONTROL_OF_DOOR( int doorID) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_REQUEST_CONTROL_OF_DOOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CONTROL_OF_ENTITY( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CONTROL_OF_ENTITY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CONTROL_OF_PICKUP( int pickup) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CONTROL_OF_PICKUP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CONTROL_OF_DOOR( unsigned doorHash) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CONTROL_OF_DOOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_DOOR_NETWORKED( unsigned doorHash) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_DOOR_NETWORKED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_VEH_TO_NET( int vehicle) { return invoke<int )
	{
		auto retval = NETWORK::VEH_TO_NET(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_PED_TO_NET( int ped) { return invoke<int )
	{
		auto retval = NETWORK::PED_TO_NET(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_OBJ_TO_NET( Object object) { return invoke<int )
	{
		auto retval = NETWORK::OBJ_TO_NET(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NET_TO_VEH( int netHandle) { return invoke<int )
	{
		auto retval = NETWORK::NET_TO_VEH(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NET_TO_PED( int netHandle) { return invoke<int )
	{
		auto retval = NETWORK::NET_TO_PED(invoke<int);
		return retval;
	}

	Object LUA_NATIVE_NETWORK_NET_TO_OBJ( int netHandle) { return invoke<Object )
	{
		auto retval = NETWORK::NET_TO_OBJ(invoke<Object);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NET_TO_ENT( int netHandle) { return invoke<int )
	{
		auto retval = NETWORK::NET_TO_ENT(invoke<int);
		return retval;
	}

	Any LUA_NATIVE_NETWORK_NETWORK_GET_LOCAL_HANDLE( Any gamerHandle, int gamerHandleSize) { invoke<void )
	{
		NETWORK::NETWORK_GET_LOCAL_HANDLE(&gamerHandle, invoke<void);
		return gamerHandle;
	}

	Any LUA_NATIVE_NETWORK_NETWORK_HANDLE_FROM_USER_ID( const char* userId, Any gamerHandle, int gamerHandleSize) { invoke<void )
	{
		NETWORK::NETWORK_HANDLE_FROM_USER_ID(userId, &gamerHandle, invoke<void);
		return gamerHandle;
	}

	Any LUA_NATIVE_NETWORK_NETWORK_HANDLE_FROM_MEMBER_ID( const char* memberId, Any gamerHandle, int gamerHandleSize) { invoke<void )
	{
		NETWORK::NETWORK_HANDLE_FROM_MEMBER_ID(memberId, &gamerHandle, invoke<void);
		return gamerHandle;
	}

	Any LUA_NATIVE_NETWORK_NETWORK_HANDLE_FROM_PLAYER( int player, Any gamerHandle, int gamerHandleSize) { invoke<void )
	{
		NETWORK::NETWORK_HANDLE_FROM_PLAYER(player, &gamerHandle, invoke<void);
		return gamerHandle;
	}

	unsigned LUA_NATIVE_NETWORK_NETWORK_HASH_FROM_PLAYER_HANDLE( int player) { return invoke<unsigned )
	{
		auto retval = NETWORK::NETWORK_HASH_FROM_PLAYER_HANDLE(invoke<unsigned);
		return retval;
	}

	std::tuple<unsigned, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_HASH_FROM_GAMER_HANDLE( Any gamerHandle) { return invoke<unsigned )
	{
		std::tuple<unsigned, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_HASH_FROM_GAMER_HANDLE(&invoke<unsigned);
		std::get<1>(return_values) = invoke<unsigned;

		return return_values;
	}

	Any LUA_NATIVE_NETWORK_NETWORK_HANDLE_FROM_FRIEND( int friendIndex, Any gamerHandle, int gamerHandleSize) { invoke<void )
	{
		NETWORK::NETWORK_HANDLE_FROM_FRIEND(friendIndex, &gamerHandle, invoke<void);
		return gamerHandle;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_GAMERTAG_FROM_HANDLE_START( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GAMERTAG_FROM_HANDLE_START(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GAMERTAG_FROM_HANDLE_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GAMERTAG_FROM_HANDLE_PENDING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GAMERTAG_FROM_HANDLE_SUCCEEDED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GAMERTAG_FROM_HANDLE_SUCCEEDED();
		return retval;
	}

	std::tuple<const char*, Any gamerHandle) { return invoke<const> LUA_NATIVE_NETWORK_NETWORK_GET_GAMERTAG_FROM_HANDLE( Any gamerHandle) { return invoke<const char* )
	{
		std::tuple<const char*, Any gamerHandle) { return invoke<const> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_GAMERTAG_FROM_HANDLE(&char*);
		std::get<1>(return_values) = char*;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_NETWORK_NETWORK_DISPLAYNAMES_FROM_HANDLES_START( Any p0, Any p1) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_DISPLAYNAMES_FROM_HANDLES_START(&p0, invoke<int);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_DISPLAYNAMES_FROM_HANDLES( Any p0, Any p1, Any p2) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_DISPLAYNAMES_FROM_HANDLES(p0, p1, invoke<int);
		return retval;
	}

	std::tuple<bool, Any, Any gamerHandle2) { return> LUA_NATIVE_NETWORK_NETWORK_ARE_HANDLES_THE_SAME( Any gamerHandle1, Any gamerHandle2) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any gamerHandle2) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ARE_HANDLES_THE_SAME(&gamerHandle1, &invoke<BOOL);
		std::get<1>(return_values) = gamerHandle1;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_IS_HANDLE_VALID( Any gamerHandle, int gamerHandleSize) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_HANDLE_VALID(&gamerHandle, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	std::tuple<int, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_FROM_GAMER_HANDLE( Any gamerHandle) { return invoke<int )
	{
		std::tuple<int, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_GET_PLAYER_FROM_GAMER_HANDLE(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<const char*, Any gamerHandle) { return invoke<const> LUA_NATIVE_NETWORK_NETWORK_MEMBER_ID_FROM_GAMER_HANDLE( Any gamerHandle) { return invoke<const char* )
	{
		std::tuple<const char*, Any gamerHandle) { return invoke<const> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_MEMBER_ID_FROM_GAMER_HANDLE(&char*);
		std::get<1>(return_values) = char*;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_GAMER_IN_MY_SESSION( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_GAMER_IN_MY_SESSION(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	Any gamerHandle) { LUA_NATIVE_NETWORK_NETWORK_SHOW_PROFILE_UI( Any gamerHandle) { invoke<void )
	{
		NETWORK::NETWORK_SHOW_PROFILE_UI(&invoke<void);
		return invoke<void;
	}

	const char* LUA_NATIVE_NETWORK_NETWORK_PLAYER_GET_NAME( int player) { return invoke<const char* )
	{
		auto retval = NETWORK::NETWORK_PLAYER_GET_NAME(char*);
		return retval;
	}

	std::tuple<const char*, int userID) { return invoke<const> LUA_NATIVE_NETWORK_NETWORK_PLAYER_GET_USERID( int player, int userID) { return invoke<const char* )
	{
		std::tuple<const char*, int userID) { return invoke<const> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_PLAYER_GET_USERID(player, &char*);
		std::get<1>(return_values) = char*;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_PLAYER_IS_ROCKSTAR_DEV( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_PLAYER_IS_ROCKSTAR_DEV(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_PLAYER_INDEX_IS_CHEATER( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_PLAYER_INDEX_IS_CHEATER(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_ENTITY_GET_OBJECT_ID( int entity) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_ENTITY_GET_OBJECT_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_ENTITY_FROM_OBJECT_ID( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_ENTITY_FROM_OBJECT_ID(invoke<int);
		return retval;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_IS_INACTIVE_PROFILE( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_INACTIVE_PROFILE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_MAX_FRIENDS(  )
	{
		auto retval = NETWORK::NETWORK_GET_MAX_FRIENDS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_FRIEND_COUNT(  )
	{
		auto retval = NETWORK::NETWORK_GET_FRIEND_COUNT();
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_NETWORK_GET_FRIEND_NAME( int friendIndex) { return invoke<const char* )
	{
		auto retval = NETWORK::NETWORK_GET_FRIEND_NAME(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_NETWORK_GET_FRIEND_DISPLAY_NAME( int friendIndex) { return invoke<const char* )
	{
		auto retval = NETWORK::NETWORK_GET_FRIEND_DISPLAY_NAME(char*);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND_ONLINE( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_FRIEND_ONLINE(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND_HANDLE_ONLINE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_FRIEND_HANDLE_ONLINE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND_IN_SAME_TITLE( const char* friendName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_FRIEND_IN_SAME_TITLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND_IN_MULTIPLAYER( const char* friendName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_FRIEND_IN_MULTIPLAYER(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_FRIEND(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PENDING_FRIEND( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PENDING_FRIEND(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ADDING_FRIEND(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ADDING_FRIEND();
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_ADD_FRIEND( Any gamerHandle, const char* message) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ADD_FRIEND(&gamerHandle, invoke<BOOL);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_FRIEND_INDEX_ONLINE( int friendIndex) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_FRIEND_INDEX_ONLINE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PLAYER_IS_PASSIVE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_PLAYER_IS_PASSIVE(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_OWNS_WAYPOINT( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PLAYER_OWNS_WAYPOINT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CAN_SET_WAYPOINT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CAN_SET_WAYPOINT();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_IGNORE_REMOTE_WAYPOINTS(  )
	{
		NETWORK::NETWORK_IGNORE_REMOTE_WAYPOINTS();
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_ON_BLOCKLIST( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_PLAYER_ON_BLOCKLIST(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SET_SCRIPT_AUTOMUTED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SET_SCRIPT_AUTOMUTED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_AUTOMUTE_OVERRIDE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_AUTOMUTE_OVERRIDE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_HEADSET(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_HEADSET();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_LOOK_AT_TALKERS( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_LOOK_AT_TALKERS(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PUSH_TO_TALK_ACTIVE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PUSH_TO_TALK_ACTIVE();
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_GAMER_HAS_HEADSET( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GAMER_HAS_HEADSET(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_GAMER_TALKING( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_GAMER_TALKING(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_PERMISSIONS_HAS_GAMER_RECORD( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_PERMISSIONS_HAS_GAMER_RECORD(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_COMMUNICATE_WITH_GAMER( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_COMMUNICATE_WITH_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_TEXT_CHAT_WITH_GAMER( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_TEXT_CHAT_WITH_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_GAMER_MUTED_BY_ME( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_GAMER_MUTED_BY_ME(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_AM_I_MUTED_BY_GAMER( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_AM_I_MUTED_BY_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_IS_GAMER_BLOCKED_BY_ME( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_IS_GAMER_BLOCKED_BY_ME(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_AM_I_BLOCKED_BY_GAMER( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_AM_I_BLOCKED_BY_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_VIEW_GAMER_USER_CONTENT( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_VIEW_GAMER_USER_CONTENT(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_VIEW_GAMER_USER_CONTENT_RESULT( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_VIEW_GAMER_USER_CONTENT_RESULT(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_PLAY_MULTIPLAYER_WITH_GAMER( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_PLAY_MULTIPLAYER_WITH_GAMER(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_GAMER_PLAY_MULTIPLAYER_WITH_ME( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_GAMER_PLAY_MULTIPLAYER_WITH_ME(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_SEND_LOCAL_INVITE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_SEND_LOCAL_INVITE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CAN_RECEIVE_LOCAL_INVITE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CAN_RECEIVE_LOCAL_INVITE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_TALKING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_TALKING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_PLAYER_HAS_HEADSET( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_PLAYER_HAS_HEADSET(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_MUTED_BY_ME( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_MUTED_BY_ME(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_AM_I_MUTED_BY_PLAYER( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_AM_I_MUTED_BY_PLAYER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_BLOCKED_BY_ME( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_BLOCKED_BY_ME(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_AM_I_BLOCKED_BY_PLAYER( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_AM_I_BLOCKED_BY_PLAYER(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_LOUDNESS( int player) { return invoke<float )
	{
		auto retval = NETWORK::NETWORK_GET_PLAYER_LOUDNESS(invoke<float);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_TALKER_PROXIMITY( float value) { invoke<void )
	{
		NETWORK::NETWORK_SET_TALKER_PROXIMITY(invoke<void);
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_TALKER_PROXIMITY(  )
	{
		auto retval = NETWORK::NETWORK_GET_TALKER_PROXIMITY();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_VOICE_ACTIVE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_VOICE_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_REMAIN_IN_GAME_CHAT( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_REMAIN_IN_GAME_CHAT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_TRANSITION_CHAT( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_TRANSITION_CHAT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_TEAM_ONLY_CHAT( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_TEAM_ONLY_CHAT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_SCRIPT_CONTROLLING_TEAMS( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_SCRIPT_CONTROLLING_TEAMS(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SET_SAME_TEAM_AS_LOCAL_PLAYER( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SET_SAME_TEAM_AS_LOCAL_PLAYER(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_TEAM_RESTRICTIONS( int team, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_TEAM_RESTRICTIONS(team, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_OVERRIDE_SPECTATOR_MODE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_OVERRIDE_SPECTATOR_MODE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_OVERRIDE_TUTORIAL_SESSION_CHAT( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_OVERRIDE_TUTORIAL_SESSION_CHAT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PROXIMITY_AFFECTS_TEAM( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_PROXIMITY_AFFECTS_TEAM(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_NO_SPECTATOR_CHAT( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_NO_SPECTATOR_CHAT(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IGNORE_SPECTATOR_CHAT_LIMITS_SAME_TEAM( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_IGNORE_SPECTATOR_CHAT_LIMITS_SAME_TEAM(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_CHAT_RESTRICTIONS( int player, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_CHAT_RESTRICTIONS(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_SEND_RESTRICTIONS( int player, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_SEND_RESTRICTIONS(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_SEND_RESTRICTIONS_ALL( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_SEND_RESTRICTIONS_ALL(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS( int player, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS_ALL( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS_ALL(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_VOICE_CHANNEL( int channel) { invoke<void )
	{
		NETWORK::NETWORK_SET_VOICE_CHANNEL(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_VOICE_CHANNEL(  )
	{
		NETWORK::NETWORK_CLEAR_VOICE_CHANNEL();
	}

	void LUA_NATIVE_NETWORK_NETWORK_APPLY_VOICE_PROXIMITY_OVERRIDE( float x, float y, float z) { invoke<void )
	{
		NETWORK::NETWORK_APPLY_VOICE_PROXIMITY_OVERRIDE(x, y, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_VOICE_PROXIMITY_OVERRIDE(  )
	{
		NETWORK::NETWORK_CLEAR_VOICE_PROXIMITY_OVERRIDE();
	}

	void LUA_NATIVE_NETWORK_NETWORK_ENABLE_VOICE_BANDWIDTH_RESTRICTION( int player) { invoke<void )
	{
		NETWORK::NETWORK_ENABLE_VOICE_BANDWIDTH_RESTRICTION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_DISABLE_VOICE_BANDWIDTH_RESTRICTION( int player) { invoke<void )
	{
		NETWORK::NETWORK_DISABLE_VOICE_BANDWIDTH_RESTRICTION(invoke<void);
	}

	std::tuple<float, float p2) {> LUA_NATIVE_NETWORK_NETWORK_GET_MUTE_COUNT_FOR_PLAYER( int p0, float p1, float p2) { invoke<void )
	{
		std::tuple<float, float p2) {> return_values;
		NETWORK::NETWORK_GET_MUTE_COUNT_FOR_PLAYER(p0, &p1, &invoke<void);
		std::get<0>(return_values) = p1;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_SPECTATOR_TO_NON_SPECTATOR_TEXT_CHAT( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_SPECTATOR_TO_NON_SPECTATOR_TEXT_CHAT(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TEXT_CHAT_IS_TYPING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_TEXT_CHAT_IS_TYPING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_SHUTDOWN_AND_LAUNCH_SINGLE_PLAYER_GAME(  )
	{
		NETWORK::SHUTDOWN_AND_LAUNCH_SINGLE_PLAYER_GAME();
	}

	bool LUA_NATIVE_NETWORK_SHUTDOWN_AND_LOAD_MOST_RECENT_SAVE(  )
	{
		auto retval = (bool)NETWORK::SHUTDOWN_AND_LOAD_MOST_RECENT_SAVE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_FRIENDLY_FIRE_OPTION( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_FRIENDLY_FIRE_OPTION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_RICH_PRESENCE( int p0, int p1, Any p2, Any p3) { invoke<void )
	{
		NETWORK::NETWORK_SET_RICH_PRESENCE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_RICH_PRESENCE_STRING( int p0, const char* textLabel) { invoke<void )
	{
		NETWORK::NETWORK_SET_RICH_PRESENCE_STRING(p0, invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_TIMEOUT_TIME(  )
	{
		auto retval = NETWORK::NETWORK_GET_TIMEOUT_TIME();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_LEAVE_PED_BEHIND_BEFORE_WARP( int player, float x, float y, float z, bool p4, bool p5) { invoke<void )
	{
		NETWORK::NETWORK_LEAVE_PED_BEHIND_BEFORE_WARP(player, x, y, z, p4, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_LEAVE_PED_BEHIND_BEFORE_CUTSCENE( int player, bool p1) { invoke<void )
	{
		NETWORK::NETWORK_LEAVE_PED_BEHIND_BEFORE_CUTSCENE(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_REMOVE_ALL_STICKY_BOMBS_FROM_ENTITY( int entity, int ped) { invoke<void )
	{
		NETWORK::REMOVE_ALL_STICKY_BOMBS_FROM_ENTITY(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_KEEP_ENTITY_COLLISION_DISABLED_AFTER_ANIM_SCENE( Any p0, Any p1) { invoke<void )
	{
		NETWORK::NETWORK_KEEP_ENTITY_COLLISION_DISABLED_AFTER_ANIM_SCENE(p0, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ANY_PLAYER_NEAR( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ANY_PLAYER_NEAR(p0, p1, p2, p3, p4, p5, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_SERVICE_IS_VALID(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_SERVICE_IS_VALID();
		return retval;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_PLAYER_IS_ACTIVE( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_PLAYER_IS_ACTIVE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_PLAYER_GET_DESC( Any clanDesc, int bufferSize, Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_PLAYER_GET_DESC(&clanDesc, bufferSize, &invoke<BOOL);
		std::get<1>(return_values) = clanDesc;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_CLAN_IS_ROCKSTAR_CLAN( Any clanDesc, int bufferSize) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_IS_ROCKSTAR_CLAN(&clanDesc, invoke<BOOL);
		std::get<1>(return_values) = clanDesc;

		return return_values;
	}

	std::tuple<Any, char formattedTag) {> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_UI_FORMATTED_TAG( Any clanDesc, int bufferSize, char formattedTag) { invoke<void )
	{
		std::tuple<Any, char formattedTag) {> return_values;
		NETWORK::NETWORK_CLAN_GET_UI_FORMATTED_TAG(&clanDesc, bufferSize, &invoke<void);
		std::get<0>(return_values) = clanDesc;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_LOCAL_MEMBERSHIPS_COUNT(  )
	{
		auto retval = NETWORK::NETWORK_CLAN_GET_LOCAL_MEMBERSHIPS_COUNT();
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_MEMBERSHIP_DESC( Any memberDesc, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_GET_MEMBERSHIP_DESC(&memberDesc, invoke<BOOL);
		std::get<1>(return_values) = memberDesc;

		return return_values;
	}

	std::tuple<bool, Any gamerHandle) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_DOWNLOAD_MEMBERSHIP( Any gamerHandle) { return invoke<BOOL )
	{
		std::tuple<bool, Any gamerHandle) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_DOWNLOAD_MEMBERSHIP(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_DOWNLOAD_MEMBERSHIP_PENDING( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_DOWNLOAD_MEMBERSHIP_PENDING(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_ANY_DOWNLOAD_MEMBERSHIP_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_ANY_DOWNLOAD_MEMBERSHIP_PENDING();
		return retval;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_REMOTE_MEMBERSHIPS_ARE_IN_CACHE( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_REMOTE_MEMBERSHIPS_ARE_IN_CACHE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<int, int p0) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_MEMBERSHIP_COUNT( int p0) { return invoke<int )
	{
		std::tuple<int, int p0) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_CLAN_GET_MEMBERSHIP_COUNT(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<bool, int> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_MEMBERSHIP_VALID( int p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_GET_MEMBERSHIP_VALID(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, int, Any> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_MEMBERSHIP( int p0, Any clanMembership, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_GET_MEMBERSHIP(&p0, &clanMembership, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = clanMembership;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_JOIN( int clanDesc) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_JOIN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_CREWINFO_GET_STRING_VALUE( const char* animDict, const char* animName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_CREWINFO_GET_STRING_VALUE(animDict, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_CREWINFO_GET_CREWRANKTITLE( int p0, const char* p1) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_CREWINFO_GET_CREWRANKTITLE(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_HAS_CREWINFO_METADATA_BEEN_RECEIVED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_HAS_CREWINFO_METADATA_BEEN_RECEIVED();
		return retval;
	}

	std::tuple<bool, Any, char txdName) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_GET_EMBLEM_TXD_NAME( Any netHandle, char txdName) { return invoke<BOOL )
	{
		std::tuple<bool, Any, char txdName) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_GET_EMBLEM_TXD_NAME(&netHandle, &invoke<BOOL);
		std::get<1>(return_values) = netHandle;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CLAN_REQUEST_EMBLEM( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_CLAN_REQUEST_EMBLEM(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_NETWORK_NETWORK_CLAN_IS_EMBLEM_READY( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_CLAN_IS_EMBLEM_READY(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLAN_RELEASE_EMBLEM( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_CLAN_RELEASE_EMBLEM(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_CLEAR(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_CLEAR();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_CANCEL(  )
	{
		NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_CANCEL();
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_START( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_START(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_PENDING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_SUCCESS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_SUCCESS();
		return retval;
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_NETWORK_NETWORK_GET_PRIMARY_CLAN_DATA_NEW( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_GET_PRIMARY_CLAN_DATA_NEW(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_CAN_MIGRATE( int netId, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_CAN_MIGRATE(netId, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_EXISTS_ON_ALL_MACHINES( int netId, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_EXISTS_ON_ALL_MACHINES(netId, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER( int netId, int player, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER(netId, player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_CAN_BE_REASSIGNED( int netId, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_CAN_BE_REASSIGNED(netId, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ENTITY_CAN_BLEND( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_ENTITY_CAN_BLEND(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_OBJECT_CAN_BLEND_WHEN_FIXED( Object object, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_OBJECT_CAN_BLEND_WHEN_FIXED(object, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ENTITY_ONLY_EXISTS_FOR_PARTICIPANTS( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_ENTITY_ONLY_EXISTS_FOR_PARTICIPANTS(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_VISIBLE_IN_CUTSCENE( int netId, bool p1, bool p2) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_VISIBLE_IN_CUTSCENE(netId, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_VISIBLE_IN_CUTSCENE_HACK( int netId, bool p1, bool p2) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_VISIBLE_IN_CUTSCENE_HACK(netId, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_VISIBLE_IN_CUTSCENE_REMAIN_HACK( Any p0, Any p1) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_VISIBLE_IN_CUTSCENE_REMAIN_HACK(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_CUTSCENE_ENTITIES( bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_CUTSCENE_ENTITIES(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_ARE_CUTSCENE_ENTITIES_NETWORKED(  )
	{
		auto retval = (bool)NETWORK::ARE_CUTSCENE_ENTITIES_NETWORKED();
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ID_PASS_CONTROL_IN_TUTORIAL( int netId, bool state) { invoke<void )
	{
		NETWORK::SET_NETWORK_ID_PASS_CONTROL_IN_TUTORIAL(netId, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_NETWORK_ID_OWNED_BY_PARTICIPANT( int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_NETWORK_ID_OWNED_BY_PARTICIPANT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_REMOTE_PLAYER_VISIBLE_IN_CUTSCENE( int player, bool locallyVisible) { invoke<void )
	{
		NETWORK::SET_REMOTE_PLAYER_VISIBLE_IN_CUTSCENE(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_LOCAL_PLAYER_VISIBLE_IN_CUTSCENE( bool p0, bool p1) { invoke<void )
	{
		NETWORK::SET_LOCAL_PLAYER_VISIBLE_IN_CUTSCENE(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_LOCAL_PLAYER_INVISIBLE_LOCALLY( bool bIncludePlayersVehicle) { invoke<void )
	{
		NETWORK::SET_LOCAL_PLAYER_INVISIBLE_LOCALLY(invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_LOCAL_PLAYER_VISIBLE_LOCALLY( bool bIncludePlayersVehicle) { invoke<void )
	{
		NETWORK::SET_LOCAL_PLAYER_VISIBLE_LOCALLY(invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_PLAYER_INVISIBLE_LOCALLY( int player, bool bIncludePlayersVehicle) { invoke<void )
	{
		NETWORK::SET_PLAYER_INVISIBLE_LOCALLY(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_PLAYER_VISIBLE_LOCALLY( int player, bool bIncludePlayersVehicle) { invoke<void )
	{
		NETWORK::SET_PLAYER_VISIBLE_LOCALLY(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_FADE_OUT_LOCAL_PLAYER( bool p0) { invoke<void )
	{
		NETWORK::FADE_OUT_LOCAL_PLAYER(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_FADE_OUT_ENTITY( int entity, bool normal, bool slow) { invoke<void )
	{
		NETWORK::NETWORK_FADE_OUT_ENTITY(entity, normal, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_FADE_IN_ENTITY( int entity, bool state, Any p2) { invoke<void )
	{
		NETWORK::NETWORK_FADE_IN_ENTITY(entity, state, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_FADING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_FADING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ENTITY_FADING( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ENTITY_FADING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_PLAYER_IN_CUTSCENE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_PLAYER_IN_CUTSCENE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_ENTITY_VISIBLE_IN_CUTSCENE( Any p0, bool p1, bool p2) { invoke<void )
	{
		NETWORK::SET_ENTITY_VISIBLE_IN_CUTSCENE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_ENTITY_LOCALLY_INVISIBLE( int entity) { invoke<void )
	{
		NETWORK::SET_ENTITY_LOCALLY_INVISIBLE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_ENTITY_LOCALLY_VISIBLE( int entity) { invoke<void )
	{
		NETWORK::SET_ENTITY_LOCALLY_VISIBLE(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_DAMAGE_TRACKER_ACTIVE_ON_NETWORK_ID( int netID) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_DAMAGE_TRACKER_ACTIVE_ON_NETWORK_ID(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_ACTIVATE_DAMAGE_TRACKER_ON_NETWORK_ID( int netID, bool toggle) { invoke<void )
	{
		NETWORK::ACTIVATE_DAMAGE_TRACKER_ON_NETWORK_ID(netID, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_DAMAGE_TRACKER_ACTIVE_ON_PLAYER( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_DAMAGE_TRACKER_ACTIVE_ON_PLAYER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_ACTIVATE_DAMAGE_TRACKER_ON_PLAYER( int player, bool toggle) { invoke<void )
	{
		NETWORK::ACTIVATE_DAMAGE_TRACKER_ON_PLAYER(player, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_SPHERE_VISIBLE_TO_ANOTHER_MACHINE( float p0, float p1, float p2, float p3) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_SPHERE_VISIBLE_TO_ANOTHER_MACHINE(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_SPHERE_VISIBLE_TO_PLAYER( Any p0, float p1, float p2, float p3, float p4) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_SPHERE_VISIBLE_TO_PLAYER(p0, p1, p2, p3, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_RESERVE_NETWORK_MISSION_OBJECTS( int amount) { invoke<void )
	{
		NETWORK::RESERVE_NETWORK_MISSION_OBJECTS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESERVE_NETWORK_MISSION_PEDS( int amount) { invoke<void )
	{
		NETWORK::RESERVE_NETWORK_MISSION_PEDS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESERVE_NETWORK_MISSION_VEHICLES( int amount) { invoke<void )
	{
		NETWORK::RESERVE_NETWORK_MISSION_VEHICLES(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESERVE_LOCAL_NETWORK_MISSION_OBJECTS( int amount) { invoke<void )
	{
		NETWORK::RESERVE_LOCAL_NETWORK_MISSION_OBJECTS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESERVE_LOCAL_NETWORK_MISSION_PEDS( int amount) { invoke<void )
	{
		NETWORK::RESERVE_LOCAL_NETWORK_MISSION_PEDS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESERVE_LOCAL_NETWORK_MISSION_VEHICLES( int amount) { invoke<void )
	{
		NETWORK::RESERVE_LOCAL_NETWORK_MISSION_VEHICLES(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_OBJECTS( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_OBJECTS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_PEDS( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_PEDS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_VEHICLES( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_VEHICLES(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_PICKUPS( int amount) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_PICKUPS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_DOORS( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_DOORS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CAN_REGISTER_MISSION_ENTITIES( int ped_amt, int vehicle_amt, int object_amt, int pickup_amt) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CAN_REGISTER_MISSION_ENTITIES(ped_amt, vehicle_amt, object_amt, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_RESERVED_MISSION_OBJECTS( bool p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_RESERVED_MISSION_OBJECTS(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_RESERVED_MISSION_PEDS( bool p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_RESERVED_MISSION_PEDS(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_RESERVED_MISSION_VEHICLES( bool p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_RESERVED_MISSION_VEHICLES(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_CREATED_MISSION_OBJECTS( bool p0) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_CREATED_MISSION_OBJECTS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_CREATED_MISSION_PEDS( bool p0) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_CREATED_MISSION_PEDS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_CREATED_MISSION_VEHICLES( bool p0) { return invoke<int )
	{
		auto retval = NETWORK::GET_NUM_CREATED_MISSION_VEHICLES(invoke<int);
		return retval;
	}

	std::tuple<Any, Any, Any out3) {> LUA_NATIVE_NETWORK_GET_RESERVED_MISSION_ENTITIES_IN_AREA( float x, float y, float z, Any p3, Any out1, Any out2, Any out3) { invoke<void )
	{
		std::tuple<Any, Any, Any out3) {> return_values;
		NETWORK::GET_RESERVED_MISSION_ENTITIES_IN_AREA(x, y, z, p3, &out1, &out2, &invoke<void);
		std::get<0>(return_values) = out1;
		std::get<1>(return_values) = out2;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_GET_MAX_NUM_NETWORK_OBJECTS(  )
	{
		auto retval = NETWORK::GET_MAX_NUM_NETWORK_OBJECTS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_MAX_NUM_NETWORK_PEDS(  )
	{
		auto retval = NETWORK::GET_MAX_NUM_NETWORK_PEDS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_MAX_NUM_NETWORK_VEHICLES(  )
	{
		auto retval = NETWORK::GET_MAX_NUM_NETWORK_VEHICLES();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_MAX_NUM_NETWORK_PICKUPS(  )
	{
		auto retval = NETWORK::GET_MAX_NUM_NETWORK_PICKUPS();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_OBJECT_SCOPE_DISTANCE( Object object, float range) { invoke<void )
	{
		NETWORK::NETWORK_SET_OBJECT_SCOPE_DISTANCE(object, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ALLOW_CLONING_WHILE_IN_TUTORIAL( Any p0, Any p1) { invoke<void )
	{
		NETWORK::NETWORK_ALLOW_CLONING_WHILE_IN_TUTORIAL(p0, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_TASK_CUTSCENE_INSCOPE_MULTIPLER( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_TASK_CUTSCENE_INSCOPE_MULTIPLER(invoke<void);
	}

	int LUA_NATIVE_NETWORK_GET_NETWORK_TIME(  )
	{
		auto retval = NETWORK::GET_NETWORK_TIME();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NETWORK_TIME_ACCURATE(  )
	{
		auto retval = NETWORK::GET_NETWORK_TIME_ACCURATE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_HAS_NETWORK_TIME_STARTED(  )
	{
		auto retval = (bool)NETWORK::HAS_NETWORK_TIME_STARTED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_TIME_OFFSET( int timeA, int timeB) { return invoke<int )
	{
		auto retval = NETWORK::GET_TIME_OFFSET(timeA, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_TIME_LESS_THAN( int timeA, int timeB) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_TIME_LESS_THAN(timeA, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_TIME_MORE_THAN( int timeA, int timeB) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_TIME_MORE_THAN(timeA, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_TIME_EQUAL_TO( int timeA, int timeB) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_TIME_EQUAL_TO(timeA, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_TIME_DIFFERENCE( int timeA, int timeB) { return invoke<int )
	{
		auto retval = NETWORK::GET_TIME_DIFFERENCE(timeA, invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_TIME_AS_STRING( int time) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_TIME_AS_STRING(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_CLOUD_TIME_AS_STRING(  )
	{
		auto retval = NETWORK::GET_CLOUD_TIME_AS_STRING();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_CLOUD_TIME_AS_INT(  )
	{
		auto retval = NETWORK::GET_CLOUD_TIME_AS_INT();
		return retval;
	}

	Any timeStructure) { LUA_NATIVE_NETWORK_CONVERT_POSIX_TIME( int posixTime, Any timeStructure) { invoke<void )
	{
		NETWORK::CONVERT_POSIX_TIME(posixTime, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IN_SPECTATOR_MODE( bool toggle, int playerPed) { invoke<void )
	{
		NETWORK::NETWORK_SET_IN_SPECTATOR_MODE(toggle, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IN_SPECTATOR_MODE_EXTENDED( bool toggle, int playerPed, bool p2) { invoke<void )
	{
		NETWORK::NETWORK_SET_IN_SPECTATOR_MODE_EXTENDED(toggle, playerPed, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IN_FREE_CAM_MODE( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_IN_FREE_CAM_MODE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_ANTAGONISTIC_TO_PLAYER( bool toggle, int player) { invoke<void )
	{
		NETWORK::NETWORK_SET_ANTAGONISTIC_TO_PLAYER(toggle, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_SPECTATOR_MODE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_SPECTATOR_MODE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_IN_MP_CUTSCENE( bool p0, bool p1) { invoke<void )
	{
		NETWORK::NETWORK_SET_IN_MP_CUTSCENE(p0, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_MP_CUTSCENE(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_MP_CUTSCENE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_IN_MP_CUTSCENE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_IN_MP_CUTSCENE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_HIDE_PROJECTILE_IN_CUTSCENE(  )
	{
		NETWORK::NETWORK_HIDE_PROJECTILE_IN_CUTSCENE();
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_VEHICLE_RESPOT_TIMER( int netId, int time, Any p2, Any p3) { invoke<void )
	{
		NETWORK::SET_NETWORK_VEHICLE_RESPOT_TIMER(netId, time, p2, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_NETWORK_VEHICLE_RUNNING_RESPOT_TIMER( int networkID) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_NETWORK_VEHICLE_RUNNING_RESPOT_TIMER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_VEHICLE_AS_GHOST( int vehicle, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_VEHICLE_AS_GHOST(vehicle, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_VEHICLE_MAX_POSITION_DELTA_MULTIPLIER( int vehicle, float multiplier) { invoke<void )
	{
		NETWORK::SET_NETWORK_VEHICLE_MAX_POSITION_DELTA_MULTIPLIER(vehicle, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_NETWORK_ENABLE_HIGH_SPEED_EDGE_FALL_DETECTION( int vehicle, bool toggle) { invoke<void )
	{
		NETWORK::SET_NETWORK_ENABLE_HIGH_SPEED_EDGE_FALL_DETECTION(vehicle, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_LOCAL_PLAYER_AS_GHOST( bool toggle, bool p1) { invoke<void )
	{
		NETWORK::SET_LOCAL_PLAYER_AS_GHOST(toggle, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_ENTITY_A_GHOST( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_ENTITY_A_GHOST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_NON_PARTICIPANTS_OF_THIS_SCRIPT_AS_GHOSTS( bool p0) { invoke<void )
	{
		NETWORK::SET_NON_PARTICIPANTS_OF_THIS_SCRIPT_AS_GHOSTS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_REMOTE_PLAYER_AS_GHOST( int player, bool p1) { invoke<void )
	{
		NETWORK::SET_REMOTE_PLAYER_AS_GHOST(player, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_GHOST_ALPHA( int alpha) { invoke<void )
	{
		NETWORK::SET_GHOST_ALPHA(invoke<void);
	}

	void LUA_NATIVE_NETWORK_RESET_GHOST_ALPHA(  )
	{
		NETWORK::RESET_GHOST_ALPHA();
	}

	void LUA_NATIVE_NETWORK_SET_ENTITY_GHOSTED_FOR_GHOST_PLAYERS( int entity, bool toggle) { invoke<void )
	{
		NETWORK::SET_ENTITY_GHOSTED_FOR_GHOST_PLAYERS(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_SET_INVERT_GHOSTING( bool p0) { invoke<void )
	{
		NETWORK::SET_INVERT_GHOSTING(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_ENTITY_IN_GHOST_COLLISION( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::IS_ENTITY_IN_GHOST_COLLISION(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_USE_PLAYER_COLOUR_INSTEAD_OF_TEAM_COLOUR( bool toggle) { invoke<void )
	{
		NETWORK::USE_PLAYER_COLOUR_INSTEAD_OF_TEAM_COLOUR(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_CREATE_SYNCHRONISED_SCENE( float x, float y, float z, float xRot, float yRot, float zRot, int rotationOrder, bool useOcclusionPortal, bool looped, float p9, float animTime, float p11) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_CREATE_SYNCHRONISED_SCENE(x, y, z, xRot, yRot, zRot, rotationOrder, useOcclusionPortal, looped, p9, animTime, invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_PED_TO_SYNCHRONISED_SCENE( int ped, int netScene, const char* animDict, const char* animnName, float speed, float speedMultiplier, int duration, int flag, float playbackRate, Any p9) { invoke<void )
	{
		NETWORK::NETWORK_ADD_PED_TO_SYNCHRONISED_SCENE(ped, netScene, animDict, animnName, speed, speedMultiplier, duration, flag, playbackRate, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_PED_TO_SYNCHRONISED_SCENE_WITH_IK( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<void )
	{
		NETWORK::NETWORK_ADD_PED_TO_SYNCHRONISED_SCENE_WITH_IK(p0, p1, p2, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_ENTITY_TO_SYNCHRONISED_SCENE( int entity, int netScene, const char* animDict, const char* animName, float speed, float speedMulitiplier, int flag) { invoke<void )
	{
		NETWORK::NETWORK_ADD_ENTITY_TO_SYNCHRONISED_SCENE(entity, netScene, animDict, animName, speed, speedMulitiplier, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_MAP_ENTITY_TO_SYNCHRONISED_SCENE( int netScene, unsigned modelHash, float x, float y, float z, float p5, const char* p6, float p7, float p8, int flags) { invoke<void )
	{
		NETWORK::NETWORK_ADD_MAP_ENTITY_TO_SYNCHRONISED_SCENE(netScene, modelHash, x, y, z, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ADD_SYNCHRONISED_SCENE_CAMERA( int netScene, const char* animDict, const char* animName) { invoke<void )
	{
		NETWORK::NETWORK_ADD_SYNCHRONISED_SCENE_CAMERA(netScene, animDict, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ATTACH_SYNCHRONISED_SCENE_TO_ENTITY( int netScene, int entity, int bone) { invoke<void )
	{
		NETWORK::NETWORK_ATTACH_SYNCHRONISED_SCENE_TO_ENTITY(netScene, entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_START_SYNCHRONISED_SCENE( int netScene) { invoke<void )
	{
		NETWORK::NETWORK_START_SYNCHRONISED_SCENE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_STOP_SYNCHRONISED_SCENE( int netScene) { invoke<void )
	{
		NETWORK::NETWORK_STOP_SYNCHRONISED_SCENE(invoke<void);
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_LOCAL_SCENE_FROM_NETWORK_ID( int netId) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_LOCAL_SCENE_FROM_NETWORK_ID(invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_FORCE_LOCAL_USE_OF_SYNCED_SCENE_CAMERA( int netScene) { invoke<void )
	{
		NETWORK::NETWORK_FORCE_LOCAL_USE_OF_SYNCED_SCENE_CAMERA(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ALLOW_REMOTE_SYNCED_SCENE_LOCAL_PLAYER_REQUESTS( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_ALLOW_REMOTE_SYNCED_SCENE_LOCAL_PLAYER_REQUESTS(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_FIND_LARGEST_BUNCH_OF_PLAYERS( int p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_FIND_LARGEST_BUNCH_OF_PLAYERS(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_START_RESPAWN_SEARCH_FOR_PLAYER( int player, float x, float y, float z, float radius, float p5, float p6, float p7, int flags) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_START_RESPAWN_SEARCH_FOR_PLAYER(player, x, y, z, radius, p5, p6, p7, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_START_RESPAWN_SEARCH_IN_ANGLED_AREA_FOR_PLAYER( int player, float x1, float y1, float z1, float x2, float y2, float z2, float width, float p8, float p9, float p10, int flags) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_START_RESPAWN_SEARCH_IN_ANGLED_AREA_FOR_PLAYER(player, x1, y1, z1, x2, y2, z2, width, p8, p9, p10, invoke<BOOL);
		return retval;
	}

	std::tuple<int, Any p0) { return> LUA_NATIVE_NETWORK_NETWORK_QUERY_RESPAWN_RESULTS( Any p0) { return invoke<int )
	{
		std::tuple<int, Any p0) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_QUERY_RESPAWN_RESULTS(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CANCEL_RESPAWN_SEARCH(  )
	{
		NETWORK::NETWORK_CANCEL_RESPAWN_SEARCH();
	}

	std::tuple<Vector3, float heading) {> LUA_NATIVE_NETWORK_NETWORK_GET_RESPAWN_RESULT( int randomInt, Vector3 coordinates, float heading) { invoke<void )
	{
		std::tuple<Vector3, float heading) {> return_values;
		NETWORK::NETWORK_GET_RESPAWN_RESULT(randomInt, &coordinates, &invoke<void);
		std::get<0>(return_values) = coordinates;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_RESPAWN_RESULT_FLAGS( int p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_RESPAWN_RESULT_FLAGS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_START_SOLO_TUTORIAL_SESSION(  )
	{
		NETWORK::NETWORK_START_SOLO_TUTORIAL_SESSION();
	}

	void LUA_NATIVE_NETWORK_NETWORK_ALLOW_GANG_TO_JOIN_TUTORIAL_SESSION( int teamId, int instanceId) { invoke<void )
	{
		NETWORK::NETWORK_ALLOW_GANG_TO_JOIN_TUTORIAL_SESSION(teamId, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_END_TUTORIAL_SESSION(  )
	{
		NETWORK::NETWORK_END_TUTORIAL_SESSION();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_IN_TUTORIAL_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_IN_TUTORIAL_SESSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_WAITING_POP_CLEAR_TUTORIAL_SESSION(  )
	{
		auto retval = (bool)NETWORK::NETWORK_WAITING_POP_CLEAR_TUTORIAL_SESSION();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TUTORIAL_SESSION_CHANGE_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TUTORIAL_SESSION_CHANGE_PENDING();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_TUTORIAL_SESSION_INSTANCE( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PLAYER_TUTORIAL_SESSION_INSTANCE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ARE_PLAYERS_IN_SAME_TUTORIAL_SESSION( int player, int index) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ARE_PLAYERS_IN_SAME_TUTORIAL_SESSION(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_BLOCK_PROXY_MIGRATION_BETWEEN_TUTORIAL_SESSIONS( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_BLOCK_PROXY_MIGRATION_BETWEEN_TUTORIAL_SESSIONS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CONCEAL_PLAYER( int player, bool toggle, bool p2) { invoke<void )
	{
		NETWORK::NETWORK_CONCEAL_PLAYER(player, toggle, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_PLAYER_CONCEALED( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_PLAYER_CONCEALED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_CONCEAL_ENTITY( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_CONCEAL_ENTITY(entity, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_ENTITY_CONCEALED( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_ENTITY_CONCEALED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_CLOCK_TIME( int hours, int minutes, int seconds) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_CLOCK_TIME(hours, minutes, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_CLOCK_RATE( int ms) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_CLOCK_RATE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_CLOCK_TIME_OVERRIDE(  )
	{
		NETWORK::NETWORK_CLEAR_CLOCK_TIME_OVERRIDE();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CLOCK_TIME_OVERRIDDEN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CLOCK_TIME_OVERRIDDEN();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_ADD_ENTITY_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_ADD_ENTITY_AREA(x1, y1, z1, x2, y2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_ADD_ENTITY_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_ADD_ENTITY_ANGLED_AREA(x1, y1, z1, x2, y2, z2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_ADD_CLIENT_ENTITY_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_ADD_CLIENT_ENTITY_AREA(x1, y1, z1, x2, y2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_ADD_CLIENT_ENTITY_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float radius) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_ADD_CLIENT_ENTITY_ANGLED_AREA(x1, y1, z1, x2, y2, z2, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REMOVE_ENTITY_AREA( int areaHandle) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_REMOVE_ENTITY_AREA(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ENTITY_AREA_DOES_EXIST( int areaHandle) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ENTITY_AREA_DOES_EXIST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ENTITY_AREA_HAVE_ALL_REPLIED( int areaHandle) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ENTITY_AREA_HAVE_ALL_REPLIED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ENTITY_AREA_IS_OCCUPIED( int areaHandle) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ENTITY_AREA_IS_OCCUPIED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_USE_HIGH_PRECISION_BLENDING( int netID, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_USE_HIGH_PRECISION_BLENDING(netID, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_CUSTOM_ARENA_BALL_PARAMS( int netId) { invoke<void )
	{
		NETWORK::NETWORK_SET_CUSTOM_ARENA_BALL_PARAMS(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ENTITY_USE_HIGH_PRECISION_ROTATION( int netId, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_ENTITY_USE_HIGH_PRECISION_ROTATION(netId, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_REQUEST_CLOUD_BACKGROUND_SCRIPTS(  )
	{
		auto retval = (bool)NETWORK::NETWORK_REQUEST_CLOUD_BACKGROUND_SCRIPTS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CLOUD_BACKGROUND_SCRIPT_REQUEST_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CLOUD_BACKGROUND_SCRIPT_REQUEST_PENDING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REQUEST_CLOUD_TUNABLES(  )
	{
		NETWORK::NETWORK_REQUEST_CLOUD_TUNABLES();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TUNABLE_CLOUD_REQUEST_PENDING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TUNABLE_CLOUD_REQUEST_PENDING();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_TUNABLE_CLOUD_CRC(  )
	{
		auto retval = NETWORK::NETWORK_GET_TUNABLE_CLOUD_CRC();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DOES_TUNABLE_EXIST( const char* tunableContext, const char* tunableName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DOES_TUNABLE_EXIST(tunableContext, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_INT( const char* tunableContext, const char* tunableName, int value) { return invoke<BOOL )
	{
		std::tuple<bool, int value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_INT(tunableContext, tunableName, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_FLOAT( const char* tunableContext, const char* tunableName, float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_FLOAT(tunableContext, tunableName, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_BOOL( const char* tunableContext, const char* tunableName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_BOOL(tunableContext, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_DOES_TUNABLE_EXIST_HASH( unsigned tunableContext, unsigned tunableName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_DOES_TUNABLE_EXIST_HASH(tunableContext, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_MODIFICATION_DETECTION_CLEAR(  )
	{
		auto retval = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_MODIFICATION_DETECTION_CLEAR();
		return retval;
	}

	std::tuple<bool, int value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_INT_HASH( unsigned tunableContext, unsigned tunableName, int value) { return invoke<BOOL )
	{
		std::tuple<bool, int value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_INT_HASH(tunableContext, tunableName, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_INT_MODIFICATION_DETECTION_REGISTRATION_HASH( unsigned contextHash, unsigned nameHash, int value) { return invoke<BOOL )
	{
		std::tuple<bool, int value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_INT_MODIFICATION_DETECTION_REGISTRATION_HASH(contextHash, nameHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_FLOAT_HASH( unsigned tunableContext, unsigned tunableName, float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_FLOAT_HASH(tunableContext, tunableName, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_FLOAT_MODIFICATION_DETECTION_REGISTRATION_HASH( unsigned contextHash, unsigned nameHash, float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_FLOAT_MODIFICATION_DETECTION_REGISTRATION_HASH(contextHash, nameHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_BOOL_HASH( unsigned tunableContext, unsigned tunableName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_BOOL_HASH(tunableContext, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, bool value) { return> LUA_NATIVE_NETWORK_NETWORK_ACCESS_TUNABLE_BOOL_MODIFICATION_DETECTION_REGISTRATION_HASH( unsigned contextHash, unsigned nameHash, bool value) { return invoke<BOOL )
	{
		std::tuple<bool, bool value) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_ACCESS_TUNABLE_BOOL_MODIFICATION_DETECTION_REGISTRATION_HASH(contextHash, nameHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_TRY_ACCESS_TUNABLE_BOOL_HASH( unsigned tunableContext, unsigned tunableName, bool defaultValue) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_TRY_ACCESS_TUNABLE_BOOL_HASH(tunableContext, tunableName, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_CONTENT_MODIFIER_LIST_ID( unsigned contentHash) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_CONTENT_MODIFIER_LIST_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_BONE_ID_OF_FATAL_HIT(  )
	{
		auto retval = NETWORK::NETWORK_GET_BONE_ID_OF_FATAL_HIT();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_RESET_BODY_TRACKER(  )
	{
		NETWORK::NETWORK_RESET_BODY_TRACKER();
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUMBER_BODY_TRACKER_HITS(  )
	{
		auto retval = NETWORK::NETWORK_GET_NUMBER_BODY_TRACKER_HITS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_BONE_BEEN_HIT_BY_KILLER( int boneIndex) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_BONE_BEEN_HIT_BY_KILLER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SET_ATTRIBUTE_DAMAGE_TO_PLAYER( int ped, int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_SET_ATTRIBUTE_DAMAGE_TO_PLAYER(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRIGGER_DAMAGE_EVENT_FOR_ZERO_DAMAGE( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_TRIGGER_DAMAGE_EVENT_FOR_ZERO_DAMAGE(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_TRIGGER_DAMAGE_EVENT_FOR_ZERO_WEAPON_HASH( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_TRIGGER_DAMAGE_EVENT_FOR_ZERO_WEAPON_HASH(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_NO_LONGER_NEEDED( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_SET_NO_LONGER_NEEDED(entity, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_NETWORK_EXPLODE_VEHICLE( int vehicle, bool isAudible, bool isInvisible, int netId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_EXPLODE_VEHICLE(vehicle, isAudible, isInvisible, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_EXPLODE_HELI( int vehicle, bool isAudible, bool isInvisible, int netId) { invoke<void )
	{
		NETWORK::NETWORK_EXPLODE_HELI(vehicle, isAudible, isInvisible, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_USE_LOGARITHMIC_BLENDING_THIS_FRAME( int entity) { invoke<void )
	{
		NETWORK::NETWORK_USE_LOGARITHMIC_BLENDING_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_OVERRIDE_COORDS_AND_HEADING( int entity, float x, float y, float z, float heading) { invoke<void )
	{
		NETWORK::NETWORK_OVERRIDE_COORDS_AND_HEADING(entity, x, y, z, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ENABLE_EXTRA_VEHICLE_ORIENTATION_BLEND_CHECKS( int netId, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_ENABLE_EXTRA_VEHICLE_ORIENTATION_BLEND_CHECKS(netId, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_DISABLE_PROXIMITY_MIGRATION( int netID) { invoke<void )
	{
		NETWORK::NETWORK_DISABLE_PROXIMITY_MIGRATION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PROPERTY_ID( int id) { invoke<void )
	{
		NETWORK::NETWORK_SET_PROPERTY_ID(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CLEAR_PROPERTY_ID(  )
	{
		NETWORK::NETWORK_CLEAR_PROPERTY_ID();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_PLAYER_MENTAL_STATE( int p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_PLAYER_MENTAL_STATE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SET_MINIMUM_RANK_FOR_MISSION( bool p0) { invoke<void )
	{
		NETWORK::NETWORK_SET_MINIMUM_RANK_FOR_MISSION(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_CACHE_LOCAL_PLAYER_HEAD_BLEND_DATA(  )
	{
		NETWORK::NETWORK_CACHE_LOCAL_PLAYER_HEAD_BLEND_DATA();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_CACHED_PLAYER_HEAD_BLEND_DATA( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_CACHED_PLAYER_HEAD_BLEND_DATA(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_APPLY_CACHED_PLAYER_HEAD_BLEND_DATA( int ped, int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_APPLY_CACHED_PLAYER_HEAD_BLEND_DATA(ped, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_NUM_COMMERCE_ITEMS(  )
	{
		auto retval = NETWORK::GET_NUM_COMMERCE_ITEMS();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_COMMERCE_DATA_VALID(  )
	{
		auto retval = (bool)NETWORK::IS_COMMERCE_DATA_VALID();
		return retval;
	}

	void LUA_NATIVE_NETWORK_TRIGGER_COMMERCE_DATA_FETCH( Any p0) { invoke<void )
	{
		NETWORK::TRIGGER_COMMERCE_DATA_FETCH(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_COMMERCE_DATA_FETCH_IN_PROGRESS(  )
	{
		auto retval = (bool)NETWORK::IS_COMMERCE_DATA_FETCH_IN_PROGRESS();
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_COMMERCE_ITEM_ID( int index) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_COMMERCE_ITEM_ID(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_COMMERCE_ITEM_NAME( int index) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_COMMERCE_ITEM_NAME(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_COMMERCE_PRODUCT_PRICE( int index) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_COMMERCE_PRODUCT_PRICE(char*);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_COMMERCE_ITEM_NUM_CATS( int index) { return invoke<int )
	{
		auto retval = NETWORK::GET_COMMERCE_ITEM_NUM_CATS(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_GET_COMMERCE_ITEM_CAT( int index, int index2) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_COMMERCE_ITEM_CAT(index, char*);
		return retval;
	}

	void LUA_NATIVE_NETWORK_OPEN_COMMERCE_STORE( const char* p0, const char* p1, int p2) { invoke<void )
	{
		NETWORK::OPEN_COMMERCE_STORE(p0, p1, invoke<void);
	}

	bool LUA_NATIVE_NETWORK_IS_COMMERCE_STORE_OPEN(  )
	{
		auto retval = (bool)NETWORK::IS_COMMERCE_STORE_OPEN();
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_STORE_ENABLED( bool toggle) { invoke<void )
	{
		NETWORK::SET_STORE_ENABLED(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_REQUEST_COMMERCE_ITEM_IMAGE( int index) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::REQUEST_COMMERCE_ITEM_IMAGE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_RELEASE_ALL_COMMERCE_ITEM_IMAGES(  )
	{
		NETWORK::RELEASE_ALL_COMMERCE_ITEM_IMAGES();
	}

	const char* LUA_NATIVE_NETWORK_GET_COMMERCE_ITEM_TEXTURENAME( int index) { return invoke<const char* )
	{
		auto retval = NETWORK::GET_COMMERCE_ITEM_TEXTURENAME(char*);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_IS_STORE_AVAILABLE_TO_USER(  )
	{
		auto retval = (bool)NETWORK::IS_STORE_AVAILABLE_TO_USER();
		return retval;
	}

	void LUA_NATIVE_NETWORK_DELAY_MP_STORE_OPEN(  )
	{
		NETWORK::DELAY_MP_STORE_OPEN();
	}

	void LUA_NATIVE_NETWORK_RESET_STORE_NETWORK_GAME_TRACKING(  )
	{
		NETWORK::RESET_STORE_NETWORK_GAME_TRACKING();
	}

	bool LUA_NATIVE_NETWORK_IS_USER_OLD_ENOUGH_TO_ACCESS_STORE(  )
	{
		auto retval = (bool)NETWORK::IS_USER_OLD_ENOUGH_TO_ACCESS_STORE();
		return retval;
	}

	void LUA_NATIVE_NETWORK_SET_LAST_VIEWED_SHOP_ITEM( unsigned p0, int p1, unsigned p2) { invoke<void )
	{
		NETWORK::SET_LAST_VIEWED_SHOP_ITEM(p0, p1, invoke<void);
	}

	int LUA_NATIVE_NETWORK_GET_USER_PREMIUM_ACCESS(  )
	{
		auto retval = NETWORK::GET_USER_PREMIUM_ACCESS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_USER_STARTER_ACCESS(  )
	{
		auto retval = NETWORK::GET_USER_STARTER_ACCESS();
		return retval;
	}

	int LUA_NATIVE_NETWORK_CLOUD_DELETE_MEMBER_FILE( const char* p0) { return invoke<int )
	{
		auto retval = NETWORK::CLOUD_DELETE_MEMBER_FILE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CLOUD_HAS_REQUEST_COMPLETED( int requestId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CLOUD_HAS_REQUEST_COMPLETED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CLOUD_DID_REQUEST_SUCCEED( int requestId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::CLOUD_DID_REQUEST_SUCCEED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_CLOUD_CHECK_AVAILABILITY(  )
	{
		NETWORK::CLOUD_CHECK_AVAILABILITY();
	}

	bool LUA_NATIVE_NETWORK_CLOUD_IS_CHECKING_AVAILABILITY(  )
	{
		auto retval = (bool)NETWORK::CLOUD_IS_CHECKING_AVAILABILITY();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_CLOUD_GET_AVAILABILITY_CHECK_RESULT(  )
	{
		auto retval = (bool)NETWORK::CLOUD_GET_AVAILABILITY_CHECK_RESULT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_CONTENT_TO_LOAD_TYPE(  )
	{
		auto retval = NETWORK::GET_CONTENT_TO_LOAD_TYPE();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_GET_IS_LAUNCH_FROM_LIVE_AREA(  )
	{
		auto retval = (bool)NETWORK::GET_IS_LAUNCH_FROM_LIVE_AREA();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_GET_IS_LIVE_AREA_LAUNCH_WITH_CONTENT(  )
	{
		auto retval = (bool)NETWORK::GET_IS_LIVE_AREA_LAUNCH_WITH_CONTENT();
		return retval;
	}

	void LUA_NATIVE_NETWORK_CLEAR_SERVICE_EVENT_ARGUMENTS(  )
	{
		NETWORK::CLEAR_SERVICE_EVENT_ARGUMENTS();
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_NETWORK_UGC_COPY_CONTENT( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_COPY_CONTENT(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_IS_CREATING(  )
	{
		auto retval = (bool)NETWORK::UGC_IS_CREATING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_HAS_CREATE_FINISHED(  )
	{
		auto retval = (bool)NETWORK::UGC_HAS_CREATE_FINISHED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_DID_CREATE_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::UGC_DID_CREATE_SUCCEED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CREATE_RESULT(  )
	{
		auto retval = NETWORK::UGC_GET_CREATE_RESULT();
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CREATE_CONTENT_ID(  )
	{
		auto retval = NETWORK::UGC_GET_CREATE_CONTENT_ID();
		return retval;
	}

	void LUA_NATIVE_NETWORK_UGC_CLEAR_CREATE_RESULT(  )
	{
		NETWORK::UGC_CLEAR_CREATE_RESULT();
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_UGC_QUERY_MY_CONTENT( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_QUERY_MY_CONTENT(p0, p1, &p2, p3, p4, invoke<BOOL);
		std::get<1>(return_values) = p2;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_QUERY_BY_CATEGORY( Any p0, Any p1, Any p2, const char* p3, Any p4, bool p5) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_QUERY_BY_CATEGORY(p0, p1, p2, p3, p4, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_QUERY_BY_CONTENT_ID( const char* contentId, bool latestVersion, const char* contentTypeName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_QUERY_BY_CONTENT_ID(contentId, latestVersion, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_UGC_QUERY_BY_CONTENT_IDS( Any data, int count, bool latestVersion, const char* contentTypeName) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_QUERY_BY_CONTENT_IDS(&data, count, latestVersion, invoke<BOOL);
		std::get<1>(return_values) = data;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_QUERY_MOST_RECENTLY_CREATED_CONTENT( int offset, int count, const char* contentTypeName, int p3) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_QUERY_MOST_RECENTLY_CREATED_CONTENT(offset, count, contentTypeName, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_BOOKMARKED_CONTENT( Any p0, Any p1, const char* p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_BOOKMARKED_CONTENT(p0, p1, p2, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_MY_CONTENT( Any p0, Any p1, const char* p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_MY_CONTENT(p0, p1, p2, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_FRIEND_CONTENT( Any p0, Any p1, const char* p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_FRIEND_CONTENT(p0, p1, p2, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p4) { return> LUA_NATIVE_NETWORK_UGC_GET_CREW_CONTENT( Any p0, Any p1, Any p2, const char* p3, Any p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any p4) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_CREW_CONTENT(p0, p1, p2, p3, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any p4) { return> LUA_NATIVE_NETWORK_UGC_GET_GET_BY_CATEGORY( Any p0, Any p1, Any p2, const char* p3, Any p4) { return invoke<BOOL )
	{
		std::tuple<bool, Any p4) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_GET_BY_CATEGORY(p0, p1, p2, p3, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_GET_BY_CONTENT_ID( const char* contentId, const char* contentTypeName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_GET_BY_CONTENT_ID(contentId, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_UGC_GET_GET_BY_CONTENT_IDS( Any data, int dataCount, const char* contentTypeName) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_GET_BY_CONTENT_IDS(&data, dataCount, invoke<BOOL);
		std::get<1>(return_values) = data;

		return return_values;
	}

	std::tuple<bool, Any, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_MOST_RECENTLY_CREATED_CONTENT( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_MOST_RECENTLY_CREATED_CONTENT(p0, p1, &p2, &invoke<BOOL);
		std::get<1>(return_values) = p2;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_MOST_RECENTLY_PLAYED_CONTENT( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_MOST_RECENTLY_PLAYED_CONTENT(p0, p1, &p2, &invoke<BOOL);
		std::get<1>(return_values) = p2;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any, Any p3) { return> LUA_NATIVE_NETWORK_UGC_GET_TOP_RATED_CONTENT( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p3) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_TOP_RATED_CONTENT(p0, p1, &p2, &invoke<BOOL);
		std::get<1>(return_values) = p2;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_UGC_CANCEL_QUERY(  )
	{
		NETWORK::UGC_CANCEL_QUERY();
	}

	bool LUA_NATIVE_NETWORK_UGC_IS_GETTING(  )
	{
		auto retval = (bool)NETWORK::UGC_IS_GETTING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_HAS_GET_FINISHED(  )
	{
		auto retval = (bool)NETWORK::UGC_HAS_GET_FINISHED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_DID_GET_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::UGC_DID_GET_SUCCEED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_WAS_QUERY_FORCE_CANCELLED(  )
	{
		auto retval = (bool)NETWORK::UGC_WAS_QUERY_FORCE_CANCELLED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_QUERY_RESULT(  )
	{
		auto retval = NETWORK::UGC_GET_QUERY_RESULT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_NUM(  )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_NUM();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_TOTAL(  )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_TOTAL();
		return retval;
	}

	unsigned LUA_NATIVE_NETWORK_UGC_GET_CONTENT_HASH(  )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_HASH();
		return retval;
	}

	void LUA_NATIVE_NETWORK_UGC_CLEAR_QUERY_RESULTS(  )
	{
		NETWORK::UGC_CLEAR_QUERY_RESULTS();
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CONTENT_USER_ID( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_USER_ID(char*);
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_NETWORK_UGC_GET_CONTENT_CREATOR_GAMER_HANDLE( int p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_CONTENT_CREATOR_GAMER_HANDLE(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_CREATED_BY_LOCAL_PLAYER( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_CREATED_BY_LOCAL_PLAYER(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CONTENT_USER_NAME( Any p0) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_USER_NAME(char*);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_IS_USING_SC_NICKNAME( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_IS_USING_SC_NICKNAME(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_CATEGORY( int p0) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_CATEGORY(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CONTENT_ID( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_ID(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_ROOT_CONTENT_ID( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_ROOT_CONTENT_ID(char*);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CONTENT_NAME( Any p0) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_NAME(char*);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_DESCRIPTION_HASH( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_DESCRIPTION_HASH(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CONTENT_PATH( int p0, int p1) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_PATH(p0, char*);
		return retval;
	}

	Any p1) { LUA_NATIVE_NETWORK_UGC_GET_CONTENT_UPDATED_DATE( Any p0, Any p1) { invoke<void )
	{
		NETWORK::UGC_GET_CONTENT_UPDATED_DATE(p0, &invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_FILE_VERSION( Any p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_FILE_VERSION(p0, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_HAS_LO_RES_PHOTO( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_HAS_LO_RES_PHOTO(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_HAS_HI_RES_PHOTO( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_HAS_HI_RES_PHOTO(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_LANGUAGE( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_LANGUAGE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_IS_PUBLISHED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_IS_PUBLISHED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_IS_VERIFIED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_IS_VERIFIED(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_NETWORK_UGC_GET_CONTENT_RATING( Any p0, Any p1) { return invoke<float )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_RATING(p0, invoke<float);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_RATING_COUNT( Any p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_RATING_COUNT(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_RATING_POSITIVE_COUNT( Any p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_RATING_POSITIVE_COUNT(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CONTENT_RATING_NEGATIVE_COUNT( Any p0, Any p1) { return invoke<int )
	{
		auto retval = NETWORK::UGC_GET_CONTENT_RATING_NEGATIVE_COUNT(p0, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_HAS_PLAYER_RECORD( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_HAS_PLAYER_RECORD(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_GET_CONTENT_HAS_PLAYER_BOOKMARKED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_GET_CONTENT_HAS_PLAYER_BOOKMARKED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_REQUEST_CONTENT_DATA_FROM_INDEX( int p0, int p1) { return invoke<int )
	{
		auto retval = NETWORK::UGC_REQUEST_CONTENT_DATA_FROM_INDEX(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_REQUEST_CONTENT_DATA_FROM_PARAMS( const char* contentTypeName, const char* contentId, int p2, int p3, int p4) { return invoke<int )
	{
		auto retval = NETWORK::UGC_REQUEST_CONTENT_DATA_FROM_PARAMS(contentTypeName, contentId, p2, p3, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_REQUEST_CACHED_DESCRIPTION( int p0) { return invoke<int )
	{
		auto retval = NETWORK::UGC_REQUEST_CACHED_DESCRIPTION(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_IS_DESCRIPTION_REQUEST_IN_PROGRESS( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_IS_DESCRIPTION_REQUEST_IN_PROGRESS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_HAS_DESCRIPTION_REQUEST_FINISHED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_HAS_DESCRIPTION_REQUEST_FINISHED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_DID_DESCRIPTION_REQUEST_SUCCEED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_DID_DESCRIPTION_REQUEST_SUCCEED(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_UGC_GET_CACHED_DESCRIPTION( Any p0, Any p1) { return invoke<const char* )
	{
		auto retval = NETWORK::UGC_GET_CACHED_DESCRIPTION(p0, char*);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_RELEASE_CACHED_DESCRIPTION( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_RELEASE_CACHED_DESCRIPTION(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_UGC_RELEASE_ALL_CACHED_DESCRIPTIONS(  )
	{
		NETWORK::UGC_RELEASE_ALL_CACHED_DESCRIPTIONS();
	}

	bool LUA_NATIVE_NETWORK_UGC_PUBLISH( const char* contentId, const char* baseContentId, const char* contentTypeName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_PUBLISH(contentId, baseContentId, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_SET_BOOKMARKED( const char* contentId, bool bookmarked, const char* contentTypeName) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_SET_BOOKMARKED(contentId, bookmarked, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_NETWORK_UGC_SET_DELETED( Any p0, bool p1, const char* p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_SET_DELETED(&p0, p1, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_IS_MODIFYING(  )
	{
		auto retval = (bool)NETWORK::UGC_IS_MODIFYING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_HAS_MODIFY_FINISHED(  )
	{
		auto retval = (bool)NETWORK::UGC_HAS_MODIFY_FINISHED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_DID_MODIFY_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::UGC_DID_MODIFY_SUCCEED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_MODIFY_RESULT(  )
	{
		auto retval = NETWORK::UGC_GET_MODIFY_RESULT();
		return retval;
	}

	void LUA_NATIVE_NETWORK_UGC_CLEAR_MODIFY_RESULT(  )
	{
		NETWORK::UGC_CLEAR_MODIFY_RESULT();
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_NETWORK_UGC_GET_CREATORS_BY_USER_ID( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::UGC_GET_CREATORS_BY_USER_ID(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_UGC_HAS_QUERY_CREATORS_FINISHED(  )
	{
		auto retval = (bool)NETWORK::UGC_HAS_QUERY_CREATORS_FINISHED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_DID_QUERY_CREATORS_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::UGC_DID_QUERY_CREATORS_SUCCEED();
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_GET_CREATOR_NUM(  )
	{
		auto retval = NETWORK::UGC_GET_CREATOR_NUM();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_UGC_LOAD_OFFLINE_QUERY( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_LOAD_OFFLINE_QUERY(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_NETWORK_UGC_CLEAR_OFFLINE_QUERY(  )
	{
		NETWORK::UGC_CLEAR_OFFLINE_QUERY();
	}

	void LUA_NATIVE_NETWORK_UGC_SET_QUERY_DATA_FROM_OFFLINE( bool p0) { invoke<void )
	{
		NETWORK::UGC_SET_QUERY_DATA_FROM_OFFLINE(invoke<void);
	}

	void LUA_NATIVE_NETWORK_UGC_SET_USING_OFFLINE_CONTENT( bool p0) { invoke<void )
	{
		NETWORK::UGC_SET_USING_OFFLINE_CONTENT(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_UGC_IS_LANGUAGE_SUPPORTED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::UGC_IS_LANGUAGE_SUPPORTED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_POST_COMPLETED_HEIST( const char* heistName, int cashEarned, int xpEarned) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::FACEBOOK_POST_COMPLETED_HEIST(heistName, cashEarned, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_POST_CREATE_CHARACTER(  )
	{
		auto retval = (bool)NETWORK::FACEBOOK_POST_CREATE_CHARACTER();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_POST_COMPLETED_MILESTONE( int milestoneId) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::FACEBOOK_POST_COMPLETED_MILESTONE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_HAS_POST_COMPLETED(  )
	{
		auto retval = (bool)NETWORK::FACEBOOK_HAS_POST_COMPLETED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_DID_POST_SUCCEED(  )
	{
		auto retval = (bool)NETWORK::FACEBOOK_DID_POST_SUCCEED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_FACEBOOK_CAN_POST_TO_FACEBOOK(  )
	{
		auto retval = (bool)NETWORK::FACEBOOK_CAN_POST_TO_FACEBOOK();
		return retval;
	}

	std::tuple<int, Any> LUA_NATIVE_NETWORK_TEXTURE_DOWNLOAD_REQUEST( Any gamerHandle, const char* filePath, const char* name, bool p3) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = NETWORK::TEXTURE_DOWNLOAD_REQUEST(&gamerHandle, filePath, name, invoke<int);
		std::get<1>(return_values) = gamerHandle;

		return return_values;
	}

	int LUA_NATIVE_NETWORK_TITLE_TEXTURE_DOWNLOAD_REQUEST( const char* filePath, const char* name, bool p2) { return invoke<int )
	{
		auto retval = NETWORK::TITLE_TEXTURE_DOWNLOAD_REQUEST(filePath, name, invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_UGC_TEXTURE_DOWNLOAD_REQUEST( const char* p0, int p1, int p2, int p3, const char* p4, bool p5) { return invoke<int )
	{
		auto retval = NETWORK::UGC_TEXTURE_DOWNLOAD_REQUEST(p0, p1, p2, p3, p4, invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_TEXTURE_DOWNLOAD_RELEASE( int p0) { invoke<void )
	{
		NETWORK::TEXTURE_DOWNLOAD_RELEASE(invoke<void);
	}

	bool LUA_NATIVE_NETWORK_TEXTURE_DOWNLOAD_HAS_FAILED( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::TEXTURE_DOWNLOAD_HAS_FAILED(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_NETWORK_TEXTURE_DOWNLOAD_GET_NAME( int p0) { return invoke<const char* )
	{
		auto retval = NETWORK::TEXTURE_DOWNLOAD_GET_NAME(char*);
		return retval;
	}

	int LUA_NATIVE_NETWORK_GET_STATUS_OF_TEXTURE_DOWNLOAD( int p0) { return invoke<int )
	{
		auto retval = NETWORK::GET_STATUS_OF_TEXTURE_DOWNLOAD(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_CHECK_ROS_LINK_WENTDOWN_NOT_NET(  )
	{
		auto retval = (bool)NETWORK::NETWORK_CHECK_ROS_LINK_WENTDOWN_NOT_NET();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SHOULD_SHOW_STRICT_NAT_WARNING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SHOULD_SHOW_STRICT_NAT_WARNING();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CABLE_CONNECTED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CABLE_CONNECTED();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_SCS_PRIVATE_MSG_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_SCS_PRIVATE_MSG_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ROS_SOCIAL_CLUB_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ROS_SOCIAL_CLUB_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ROS_BANNED_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ROS_BANNED_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ROS_CREATE_TICKET_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ROS_CREATE_TICKET_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ROS_MULTIPLAYER_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ROS_MULTIPLAYER_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAVE_ROS_LEADERBOARD_WRITE_PRIV(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAVE_ROS_LEADERBOARD_WRITE_PRIV();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_ROS_PRIVILEGE( int index) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_ROS_PRIVILEGE(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int, Any timeData) { return> LUA_NATIVE_NETWORK_NETWORK_HAS_ROS_PRIVILEGE_END_DATE( int privilege, int banType, Any timeData) { return invoke<BOOL )
	{
		std::tuple<bool, int, Any timeData) { return> return_values;
		std::get<0>(return_values) = (bool)NETWORK::NETWORK_HAS_ROS_PRIVILEGE_END_DATE(privilege, &banType, &invoke<BOOL);
		std::get<1>(return_values) = banType;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_ROS_PRIVILEGE_PLAYED_LAST_GEN(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_ROS_PRIVILEGE_PLAYED_LAST_GEN();
		return retval;
	}

	bool LUA_NATIVE_NETWORK_NETWORK_HAS_ROS_PRIVILEGE_SPECIAL_EDITION_CONTENT(  )
	{
		auto retval = (bool)NETWORK::NETWORK_HAS_ROS_PRIVILEGE_SPECIAL_EDITION_CONTENT();
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_START_COMMUNICATION_PERMISSIONS_CHECK( Any p0) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_START_COMMUNICATION_PERMISSIONS_CHECK(invoke<int);
		return retval;
	}

	std::tuple<int, Any netHandle) { return> LUA_NATIVE_NETWORK_NETWORK_START_USER_CONTENT_PERMISSIONS_CHECK( Any netHandle) { return invoke<int )
	{
		std::tuple<int, Any netHandle) { return> return_values;
		std::get<0>(return_values) = NETWORK::NETWORK_START_USER_CONTENT_PERMISSIONS_CHECK(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_NETWORK_NETWORK_SKIP_RADIO_RESET_NEXT_CLOSE(  )
	{
		NETWORK::NETWORK_SKIP_RADIO_RESET_NEXT_CLOSE();
	}

	void LUA_NATIVE_NETWORK_NETWORK_SKIP_RADIO_RESET_NEXT_OPEN(  )
	{
		NETWORK::NETWORK_SKIP_RADIO_RESET_NEXT_OPEN();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_SKIP_RADIO_WARNING(  )
	{
		auto retval = (bool)NETWORK::NETWORK_SKIP_RADIO_WARNING();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_FORCE_LOCAL_PLAYER_SCAR_SYNC(  )
	{
		NETWORK::NETWORK_FORCE_LOCAL_PLAYER_SCAR_SYNC();
	}

	void LUA_NATIVE_NETWORK_NETWORK_DISABLE_LEAVE_REMOTE_PED_BEHIND( bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_DISABLE_LEAVE_REMOTE_PED_BEHIND(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_ALLOW_REMOTE_ATTACHMENT_MODIFICATION( int entity, bool toggle) { invoke<void )
	{
		NETWORK::NETWORK_ALLOW_REMOTE_ATTACHMENT_MODIFICATION(entity, invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SHOW_CHAT_RESTRICTION_MSC( int player) { invoke<void )
	{
		NETWORK::NETWORK_SHOW_CHAT_RESTRICTION_MSC(invoke<void);
	}

	void LUA_NATIVE_NETWORK_NETWORK_SHOW_PSN_UGC_RESTRICTION(  )
	{
		NETWORK::NETWORK_SHOW_PSN_UGC_RESTRICTION();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_TITLE_UPDATE_REQUIRED(  )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_TITLE_UPDATE_REQUIRED();
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_QUIT_MP_TO_DESKTOP(  )
	{
		NETWORK::NETWORK_QUIT_MP_TO_DESKTOP();
	}

	bool LUA_NATIVE_NETWORK_NETWORK_IS_CONNECTED_VIA_RELAY( int player) { return invoke<BOOL )
	{
		auto retval = (bool)NETWORK::NETWORK_IS_CONNECTED_VIA_RELAY(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_AVERAGE_LATENCY( int player) { return invoke<float )
	{
		auto retval = NETWORK::NETWORK_GET_AVERAGE_LATENCY(invoke<float);
		return retval;
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_AVERAGE_PING( int player) { return invoke<float )
	{
		auto retval = NETWORK::NETWORK_GET_AVERAGE_PING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_NETWORK_NETWORK_GET_AVERAGE_PACKET_LOSS( int player) { return invoke<float )
	{
		auto retval = NETWORK::NETWORK_GET_AVERAGE_PACKET_LOSS(invoke<float);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_NUM_UNACKED_RELIABLES( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_NUM_UNACKED_RELIABLES(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_UNRELIABLE_RESEND_COUNT( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_UNRELIABLE_RESEND_COUNT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_HIGHEST_RELIABLE_RESEND_COUNT( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_HIGHEST_RELIABLE_RESEND_COUNT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_REPORT_CODE_TAMPER(  )
	{
		NETWORK::NETWORK_REPORT_CODE_TAMPER();
	}

	Vector3 LUA_NATIVE_NETWORK_NETWORK_GET_LAST_ENTITY_POS_RECEIVED_OVER_NETWORK( int entity) { return invoke<Vector3 )
	{
		auto retval = NETWORK::NETWORK_GET_LAST_ENTITY_POS_RECEIVED_OVER_NETWORK(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_NETWORK_NETWORK_GET_LAST_PLAYER_POS_RECEIVED_OVER_NETWORK( int player) { return invoke<Vector3 )
	{
		auto retval = NETWORK::NETWORK_GET_LAST_PLAYER_POS_RECEIVED_OVER_NETWORK(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_NETWORK_NETWORK_GET_LAST_VEL_RECEIVED_OVER_NETWORK( int entity) { return invoke<Vector3 )
	{
		auto retval = NETWORK::NETWORK_GET_LAST_VEL_RECEIVED_OVER_NETWORK(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_NETWORK_NETWORK_GET_PREDICTED_VELOCITY( int entity) { return invoke<Vector3 )
	{
		auto retval = NETWORK::NETWORK_GET_PREDICTED_VELOCITY(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_DUMP_NET_IF_CONFIG(  )
	{
		NETWORK::NETWORK_DUMP_NET_IF_CONFIG();
	}

	Any p0) { LUA_NATIVE_NETWORK_NETWORK_GET_SIGNALLING_INFO( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_GET_SIGNALLING_INFO(&invoke<void);
		return invoke<void;
	}

	Any p0) { LUA_NATIVE_NETWORK_NETWORK_GET_NET_STATISTICS_INFO( Any p0) { invoke<void )
	{
		NETWORK::NETWORK_GET_NET_STATISTICS_INFO(&invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_NETWORK_NETWORK_GET_PLAYER_ACCOUNT_ID( int player) { return invoke<int )
	{
		auto retval = NETWORK::NETWORK_GET_PLAYER_ACCOUNT_ID(invoke<int);
		return retval;
	}

	void LUA_NATIVE_NETWORK_NETWORK_UGC_NAV( Any p0, Any p1) { invoke<void )
	{
		NETWORK::NETWORK_UGC_NAV(p0, invoke<void);
	}

	Object LUA_NATIVE_OBJECT_CREATE_OBJECT( unsigned modelHash, float x, float y, float z, bool isNetwork, bool bScriptHostObj, bool dynamic) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_OBJECT(modelHash, x, y, z, isNetwork, bScriptHostObj, invoke<Object);
		return retval;
	}

	Object LUA_NATIVE_OBJECT_CREATE_OBJECT_NO_OFFSET( unsigned modelHash, float x, float y, float z, bool isNetwork, bool bScriptHostObj, bool dynamic) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_OBJECT_NO_OFFSET(modelHash, x, y, z, isNetwork, bScriptHostObj, invoke<Object);
		return retval;
	}

	Object object) { LUA_NATIVE_OBJECT_DELETE_OBJECT( Object object) { invoke<void )
	{
		OBJECT::DELETE_OBJECT(&invoke<void);
		return invoke<void;
	}

	bool LUA_NATIVE_OBJECT_PLACE_OBJECT_ON_GROUND_PROPERLY( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::PLACE_OBJECT_ON_GROUND_PROPERLY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_PLACE_OBJECT_ON_GROUND_OR_OBJECT_PROPERLY( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::PLACE_OBJECT_ON_GROUND_OR_OBJECT_PROPERLY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_ROTATE_OBJECT( Object object, float p1, float p2, bool p3) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::ROTATE_OBJECT(object, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_SLIDE_OBJECT( Object object, float toX, float toY, float toZ, float speedX, float speedY, float speedZ, bool collision) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::SLIDE_OBJECT(object, toX, toY, toZ, speedX, speedY, speedZ, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_TARGETTABLE( Object object, bool targettable) { invoke<void )
	{
		OBJECT::SET_OBJECT_TARGETTABLE(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_FORCE_VEHICLES_TO_AVOID( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_OBJECT_FORCE_VEHICLES_TO_AVOID(object, invoke<void);
	}

	Object LUA_NATIVE_OBJECT_GET_CLOSEST_OBJECT_OF_TYPE( float x, float y, float z, float radius, unsigned modelHash, bool isMission, bool p6, bool p7) { return invoke<Object )
	{
		auto retval = OBJECT::GET_CLOSEST_OBJECT_OF_TYPE(x, y, z, radius, modelHash, isMission, p6, invoke<Object);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_HAS_OBJECT_BEEN_BROKEN( Object object, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::HAS_OBJECT_BEEN_BROKEN(object, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_HAS_CLOSEST_OBJECT_OF_TYPE_BEEN_BROKEN( float p0, float p1, float p2, float p3, unsigned modelHash, Any p5) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::HAS_CLOSEST_OBJECT_OF_TYPE_BEEN_BROKEN(p0, p1, p2, p3, modelHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_HAS_CLOSEST_OBJECT_OF_TYPE_BEEN_COMPLETELY_DESTROYED( float x, float y, float z, float radius, unsigned modelHash, bool p5) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::HAS_CLOSEST_OBJECT_OF_TYPE_BEEN_COMPLETELY_DESTROYED(x, y, z, radius, modelHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_GET_HAS_OBJECT_BEEN_COMPLETELY_DESTROYED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::GET_HAS_OBJECT_BEEN_COMPLETELY_DESTROYED(invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_OBJECT_GET_OFFSET_FROM_COORD_AND_HEADING_IN_WORLD_COORDS( float xPos, float yPos, float zPos, float heading, float xOffset, float yOffset, float zOffset) { return invoke<Vector3 )
	{
		auto retval = OBJECT::GET_OFFSET_FROM_COORD_AND_HEADING_IN_WORLD_COORDS(xPos, yPos, zPos, heading, xOffset, yOffset, invoke<Vector3);
		return retval;
	}

	std::tuple<bool, Vector3, Vector3> LUA_NATIVE_OBJECT_GET_COORDS_AND_ROTATION_OF_CLOSEST_OBJECT_OF_TYPE( float x, float y, float z, float radius, unsigned modelHash, Vector3 outPosition, Vector3 outRotation, int rotationOrder) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, Vector3> return_values;
		std::get<0>(return_values) = (bool)OBJECT::GET_COORDS_AND_ROTATION_OF_CLOSEST_OBJECT_OF_TYPE(x, y, z, radius, modelHash, &outPosition, &outRotation, invoke<BOOL);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = outRotation;

		return return_values;
	}

	void LUA_NATIVE_OBJECT_SET_STATE_OF_CLOSEST_DOOR_OF_TYPE( unsigned type, float x, float y, float z, bool locked, float heading, bool p6) { invoke<void )
	{
		OBJECT::SET_STATE_OF_CLOSEST_DOOR_OF_TYPE(type, x, y, z, locked, heading, invoke<void);
	}

	std::tuple<bool, float heading) {> LUA_NATIVE_OBJECT_GET_STATE_OF_CLOSEST_DOOR_OF_TYPE( unsigned type, float x, float y, float z, bool locked, float heading) { invoke<void )
	{
		std::tuple<bool, float heading) {> return_values;
		OBJECT::GET_STATE_OF_CLOSEST_DOOR_OF_TYPE(type, x, y, z, (BOOL*)&locked, &invoke<void);
		std::get<0>(return_values) = locked;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_OBJECT_SET_LOCKED_UNSTREAMED_IN_DOOR_OF_TYPE( unsigned modelHash, float x, float y, float z, bool locked, float xRotMult, float yRotMult, float zRotMult) { invoke<void )
	{
		OBJECT::SET_LOCKED_UNSTREAMED_IN_DOOR_OF_TYPE(modelHash, x, y, z, locked, xRotMult, yRotMult, invoke<void);
	}

	void LUA_NATIVE_OBJECT_PLAY_OBJECT_AUTO_START_ANIM( Any p0) { invoke<void )
	{
		OBJECT::PLAY_OBJECT_AUTO_START_ANIM(invoke<void);
	}

	void LUA_NATIVE_OBJECT_ADD_DOOR_TO_SYSTEM( unsigned doorHash, unsigned modelHash, float x, float y, float z, bool p5, bool scriptDoor, bool isLocal) { invoke<void )
	{
		OBJECT::ADD_DOOR_TO_SYSTEM(doorHash, modelHash, x, y, z, p5, scriptDoor, invoke<void);
	}

	void LUA_NATIVE_OBJECT_REMOVE_DOOR_FROM_SYSTEM( unsigned doorHash, Any p1) { invoke<void )
	{
		OBJECT::REMOVE_DOOR_FROM_SYSTEM(doorHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_DOOR_STATE( unsigned doorHash, int state, bool requestDoor, bool forceUpdate) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_DOOR_STATE(doorHash, state, requestDoor, invoke<void);
	}

	int LUA_NATIVE_OBJECT_DOOR_SYSTEM_GET_DOOR_STATE( unsigned doorHash) { return invoke<int )
	{
		auto retval = OBJECT::DOOR_SYSTEM_GET_DOOR_STATE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_OBJECT_DOOR_SYSTEM_GET_DOOR_PENDING_STATE( unsigned doorHash) { return invoke<int )
	{
		auto retval = OBJECT::DOOR_SYSTEM_GET_DOOR_PENDING_STATE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_AUTOMATIC_RATE( unsigned doorHash, float rate, bool requestDoor, bool forceUpdate) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_AUTOMATIC_RATE(doorHash, rate, requestDoor, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_AUTOMATIC_DISTANCE( unsigned doorHash, float distance, bool requestDoor, bool forceUpdate) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_AUTOMATIC_DISTANCE(doorHash, distance, requestDoor, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_OPEN_RATIO( unsigned doorHash, float ajar, bool requestDoor, bool forceUpdate) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_OPEN_RATIO(doorHash, ajar, requestDoor, invoke<void);
	}

	float LUA_NATIVE_OBJECT_DOOR_SYSTEM_GET_AUTOMATIC_DISTANCE( unsigned doorHash) { return invoke<float )
	{
		auto retval = OBJECT::DOOR_SYSTEM_GET_AUTOMATIC_DISTANCE(invoke<float);
		return retval;
	}

	float LUA_NATIVE_OBJECT_DOOR_SYSTEM_GET_OPEN_RATIO( unsigned doorHash) { return invoke<float )
	{
		auto retval = OBJECT::DOOR_SYSTEM_GET_OPEN_RATIO(invoke<float);
		return retval;
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_SPRING_REMOVED( unsigned doorHash, bool removed, bool requestDoor, bool forceUpdate) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_SPRING_REMOVED(doorHash, removed, requestDoor, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_HOLD_OPEN( unsigned doorHash, bool toggle) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_HOLD_OPEN(doorHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DOOR_SYSTEM_SET_DOOR_OPEN_FOR_RACES( unsigned doorHash, bool p1) { invoke<void )
	{
		OBJECT::DOOR_SYSTEM_SET_DOOR_OPEN_FOR_RACES(doorHash, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_IS_DOOR_REGISTERED_WITH_SYSTEM( unsigned doorHash) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_DOOR_REGISTERED_WITH_SYSTEM(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_DOOR_CLOSED( unsigned doorHash) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_DOOR_CLOSED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_OPEN_ALL_BARRIERS_FOR_RACE( bool p0) { invoke<void )
	{
		OBJECT::OPEN_ALL_BARRIERS_FOR_RACE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_CLOSE_ALL_BARRIERS_FOR_RACE(  )
	{
		OBJECT::CLOSE_ALL_BARRIERS_FOR_RACE();
	}

	bool LUA_NATIVE_OBJECT_DOOR_SYSTEM_GET_IS_PHYSICS_LOADED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOOR_SYSTEM_GET_IS_PHYSICS_LOADED(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, unsigned outDoorHash) { return> LUA_NATIVE_OBJECT_DOOR_SYSTEM_FIND_EXISTING_DOOR( float x, float y, float z, unsigned modelHash, unsigned outDoorHash) { return invoke<BOOL )
	{
		std::tuple<bool, unsigned outDoorHash) { return> return_values;
		std::get<0>(return_values) = (bool)OBJECT::DOOR_SYSTEM_FIND_EXISTING_DOOR(x, y, z, modelHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_OBJECT_IS_GARAGE_EMPTY( unsigned garageHash, bool p1, int p2) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_GARAGE_EMPTY(garageHash, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_PLAYER_ENTIRELY_INSIDE_GARAGE( unsigned garageHash, int player, float p2, int p3) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_PLAYER_ENTIRELY_INSIDE_GARAGE(garageHash, player, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_PLAYER_PARTIALLY_INSIDE_GARAGE( unsigned garageHash, int player, int p2) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_PLAYER_PARTIALLY_INSIDE_GARAGE(garageHash, player, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_ARE_ENTITIES_ENTIRELY_INSIDE_GARAGE( unsigned garageHash, bool p1, bool p2, bool p3, Any p4) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::ARE_ENTITIES_ENTIRELY_INSIDE_GARAGE(garageHash, p1, p2, p3, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_ANY_ENTITY_ENTIRELY_INSIDE_GARAGE( unsigned garageHash, bool p1, bool p2, bool p3, Any p4) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_ANY_ENTITY_ENTIRELY_INSIDE_GARAGE(garageHash, p1, p2, p3, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_ENTIRELY_INSIDE_GARAGE( unsigned garageHash, int entity, float p2, int p3) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_ENTIRELY_INSIDE_GARAGE(garageHash, entity, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_PARTIALLY_INSIDE_GARAGE( unsigned garageHash, int entity, int p2) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_PARTIALLY_INSIDE_GARAGE(garageHash, entity, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_CLEAR_GARAGE( unsigned garageHash, bool isNetwork) { invoke<void )
	{
		OBJECT::CLEAR_GARAGE(garageHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_CLEAR_OBJECTS_INSIDE_GARAGE( unsigned garageHash, bool vehicles, bool peds, bool objects, bool isNetwork) { invoke<void )
	{
		OBJECT::CLEAR_OBJECTS_INSIDE_GARAGE(garageHash, vehicles, peds, objects, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DISABLE_TIDYING_UP_IN_GARAGE( int id, bool toggle) { invoke<void )
	{
		OBJECT::DISABLE_TIDYING_UP_IN_GARAGE(id, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ENABLE_SAVING_IN_GARAGE( unsigned garageHash, bool toggle) { invoke<void )
	{
		OBJECT::ENABLE_SAVING_IN_GARAGE(garageHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_CLOSE_SAFEHOUSE_GARAGES(  )
	{
		OBJECT::CLOSE_SAFEHOUSE_GARAGES();
	}

	bool LUA_NATIVE_OBJECT_DOES_OBJECT_OF_TYPE_EXIST_AT_COORDS( float x, float y, float z, float radius, unsigned hash, bool p5) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOES_OBJECT_OF_TYPE_EXIST_AT_COORDS(x, y, z, radius, hash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_POINT_IN_ANGLED_AREA( float xPos, float yPos, float zPos, float x1, float y1, float z1, float x2, float y2, float z2, float width, bool debug, bool includeZ) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_POINT_IN_ANGLED_AREA(xPos, yPos, zPos, x1, y1, z1, x2, y2, z2, width, debug, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_ALLOW_LOW_LOD_BUOYANCY( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_OBJECT_ALLOW_LOW_LOD_BUOYANCY(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_PHYSICS_PARAMS( Object object, float weight, float p2, float p3, float p4, float p5, float gravity, float p7, float p8, float p9, float p10, float buoyancy) { invoke<void )
	{
		OBJECT::SET_OBJECT_PHYSICS_PARAMS(object, weight, p2, p3, p4, p5, gravity, p7, p8, p9, p10, invoke<void);
	}

	float LUA_NATIVE_OBJECT_GET_OBJECT_FRAGMENT_DAMAGE_HEALTH( Any p0, bool p1) { return invoke<float )
	{
		auto retval = OBJECT::GET_OBJECT_FRAGMENT_DAMAGE_HEALTH(p0, invoke<float);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_ACTIVATE_OBJECT_PHYSICS_AS_SOON_AS_IT_IS_UNFROZEN( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_ACTIVATE_OBJECT_PHYSICS_AS_SOON_AS_IT_IS_UNFROZEN(object, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_IS_ANY_OBJECT_NEAR_POINT( float x, float y, float z, float range, bool p4) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_ANY_OBJECT_NEAR_POINT(x, y, z, range, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_NEAR_POINT( unsigned objectHash, float x, float y, float z, float range) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_NEAR_POINT(objectHash, x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_REMOVE_OBJECT_HIGH_DETAIL_MODEL( Object object) { invoke<void )
	{
		OBJECT::REMOVE_OBJECT_HIGH_DETAIL_MODEL(invoke<void);
	}

	void LUA_NATIVE_OBJECT_BREAK_OBJECT_FRAGMENT_CHILD( Object p0, Any p1, bool p2) { invoke<void )
	{
		OBJECT::BREAK_OBJECT_FRAGMENT_CHILD(p0, p1, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DAMAGE_OBJECT_FRAGMENT_CHILD( Any p0, Any p1, Any p2) { invoke<void )
	{
		OBJECT::DAMAGE_OBJECT_FRAGMENT_CHILD(p0, p1, invoke<void);
	}

	void LUA_NATIVE_OBJECT_FIX_OBJECT_FRAGMENT( Object object) { invoke<void )
	{
		OBJECT::FIX_OBJECT_FRAGMENT(invoke<void);
	}

	void LUA_NATIVE_OBJECT_TRACK_OBJECT_VISIBILITY( Object object) { invoke<void )
	{
		OBJECT::TRACK_OBJECT_VISIBILITY(invoke<void);
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_VISIBLE( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_VISIBLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_IS_SPECIAL_GOLFBALL( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_OBJECT_IS_SPECIAL_GOLFBALL(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_TAKES_DAMAGE_FROM_COLLIDING_WITH_BUILDINGS( Any p0, bool p1) { invoke<void )
	{
		OBJECT::SET_OBJECT_TAKES_DAMAGE_FROM_COLLIDING_WITH_BUILDINGS(p0, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ALLOW_DAMAGE_EVENTS_FOR_NON_NETWORKED_OBJECTS( bool value) { invoke<void )
	{
		OBJECT::ALLOW_DAMAGE_EVENTS_FOR_NON_NETWORKED_OBJECTS(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_CUTSCENES_WEAPON_FLASHLIGHT_ON_THIS_FRAME( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_CUTSCENES_WEAPON_FLASHLIGHT_ON_THIS_FRAME(object, invoke<void);
	}

	Object LUA_NATIVE_OBJECT_GET_RAYFIRE_MAP_OBJECT( float x, float y, float z, float radius, const char* name) { return invoke<Object )
	{
		auto retval = OBJECT::GET_RAYFIRE_MAP_OBJECT(x, y, z, radius, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_STATE_OF_RAYFIRE_MAP_OBJECT( Object object, int state) { invoke<void )
	{
		OBJECT::SET_STATE_OF_RAYFIRE_MAP_OBJECT(object, invoke<void);
	}

	int LUA_NATIVE_OBJECT_GET_STATE_OF_RAYFIRE_MAP_OBJECT( Object object) { return invoke<int )
	{
		auto retval = OBJECT::GET_STATE_OF_RAYFIRE_MAP_OBJECT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_DOES_RAYFIRE_MAP_OBJECT_EXIST( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOES_RAYFIRE_MAP_OBJECT_EXIST(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_OBJECT_GET_RAYFIRE_MAP_OBJECT_ANIM_PHASE( Object object) { return invoke<float )
	{
		auto retval = OBJECT::GET_RAYFIRE_MAP_OBJECT_ANIM_PHASE(invoke<float);
		return retval;
	}

	int LUA_NATIVE_OBJECT_CREATE_PICKUP( unsigned pickupHash, float posX, float posY, float posZ, int p4, int value, bool p6, unsigned modelHash) { return invoke<int )
	{
		auto retval = OBJECT::CREATE_PICKUP(pickupHash, posX, posY, posZ, p4, value, p6, invoke<int);
		return retval;
	}

	int LUA_NATIVE_OBJECT_CREATE_PICKUP_ROTATE( unsigned pickupHash, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, int flag, int amount, Any p9, bool p10, unsigned modelHash) { return invoke<int )
	{
		auto retval = OBJECT::CREATE_PICKUP_ROTATE(pickupHash, posX, posY, posZ, rotX, rotY, rotZ, flag, amount, p9, p10, invoke<int);
		return retval;
	}

	void LUA_NATIVE_OBJECT_FORCE_PICKUP_ROTATE_FACE_UP(  )
	{
		OBJECT::FORCE_PICKUP_ROTATE_FACE_UP();
	}

	void LUA_NATIVE_OBJECT_SET_CUSTOM_PICKUP_WEAPON_HASH( unsigned pickupHash, int pickup) { invoke<void )
	{
		OBJECT::SET_CUSTOM_PICKUP_WEAPON_HASH(pickupHash, invoke<void);
	}

	Object LUA_NATIVE_OBJECT_CREATE_AMBIENT_PICKUP( unsigned pickupHash, float posX, float posY, float posZ, int flags, int value, unsigned modelHash, bool p7, bool p8) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_AMBIENT_PICKUP(pickupHash, posX, posY, posZ, flags, value, modelHash, p7, invoke<Object);
		return retval;
	}

	Object LUA_NATIVE_OBJECT_CREATE_NON_NETWORKED_AMBIENT_PICKUP( unsigned pickupHash, float posX, float posY, float posZ, int flags, int value, unsigned modelHash, bool p7, bool p8) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_NON_NETWORKED_AMBIENT_PICKUP(pickupHash, posX, posY, posZ, flags, value, modelHash, p7, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_OBJECT_BLOCK_PLAYERS_FOR_AMBIENT_PICKUP( Any p0, Any p1) { invoke<void )
	{
		OBJECT::BLOCK_PLAYERS_FOR_AMBIENT_PICKUP(p0, invoke<void);
	}

	Object LUA_NATIVE_OBJECT_CREATE_PORTABLE_PICKUP( unsigned pickupHash, float x, float y, float z, bool placeOnGround, unsigned modelHash) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_PORTABLE_PICKUP(pickupHash, x, y, z, placeOnGround, invoke<Object);
		return retval;
	}

	Object LUA_NATIVE_OBJECT_CREATE_NON_NETWORKED_PORTABLE_PICKUP( unsigned pickupHash, float x, float y, float z, bool placeOnGround, unsigned modelHash) { return invoke<Object )
	{
		auto retval = OBJECT::CREATE_NON_NETWORKED_PORTABLE_PICKUP(pickupHash, x, y, z, placeOnGround, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_OBJECT_ATTACH_PORTABLE_PICKUP_TO_PED( Object pickupObject, int ped) { invoke<void )
	{
		OBJECT::ATTACH_PORTABLE_PICKUP_TO_PED(pickupObject, invoke<void);
	}

	void LUA_NATIVE_OBJECT_DETACH_PORTABLE_PICKUP_FROM_PED( Object pickupObject) { invoke<void )
	{
		OBJECT::DETACH_PORTABLE_PICKUP_FROM_PED(invoke<void);
	}

	void LUA_NATIVE_OBJECT_FORCE_PORTABLE_PICKUP_LAST_ACCESSIBLE_POSITION_SETTING( Object object) { invoke<void )
	{
		OBJECT::FORCE_PORTABLE_PICKUP_LAST_ACCESSIBLE_POSITION_SETTING(invoke<void);
	}

	void LUA_NATIVE_OBJECT_HIDE_PORTABLE_PICKUP_WHEN_DETACHED( Object pickupObject, bool toggle) { invoke<void )
	{
		OBJECT::HIDE_PORTABLE_PICKUP_WHEN_DETACHED(pickupObject, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_MAX_NUM_PORTABLE_PICKUPS_CARRIED_BY_PLAYER( unsigned modelHash, int number) { invoke<void )
	{
		OBJECT::SET_MAX_NUM_PORTABLE_PICKUPS_CARRIED_BY_PLAYER(modelHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_LOCAL_PLAYER_CAN_COLLECT_PORTABLE_PICKUPS( bool toggle) { invoke<void )
	{
		OBJECT::SET_LOCAL_PLAYER_CAN_COLLECT_PORTABLE_PICKUPS(invoke<void);
	}

	Vector3 LUA_NATIVE_OBJECT_GET_SAFE_PICKUP_COORDS( float x, float y, float z, float p3, float p4) { return invoke<Vector3 )
	{
		auto retval = OBJECT::GET_SAFE_PICKUP_COORDS(x, y, z, p3, invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_OBJECT_ADD_EXTENDED_PICKUP_PROBE_AREA( float x, float y, float z, float radius) { invoke<void )
	{
		OBJECT::ADD_EXTENDED_PICKUP_PROBE_AREA(x, y, z, invoke<void);
	}

	void LUA_NATIVE_OBJECT_CLEAR_EXTENDED_PICKUP_PROBE_AREAS(  )
	{
		OBJECT::CLEAR_EXTENDED_PICKUP_PROBE_AREAS();
	}

	Vector3 LUA_NATIVE_OBJECT_GET_PICKUP_COORDS( int pickup) { return invoke<Vector3 )
	{
		auto retval = OBJECT::GET_PICKUP_COORDS(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SUPPRESS_PICKUP_SOUND_FOR_PICKUP( Any p0, Any p1) { invoke<void )
	{
		OBJECT::SUPPRESS_PICKUP_SOUND_FOR_PICKUP(p0, invoke<void);
	}

	void LUA_NATIVE_OBJECT_REMOVE_ALL_PICKUPS_OF_TYPE( unsigned pickupHash) { invoke<void )
	{
		OBJECT::REMOVE_ALL_PICKUPS_OF_TYPE(invoke<void);
	}

	bool LUA_NATIVE_OBJECT_HAS_PICKUP_BEEN_COLLECTED( int pickup) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::HAS_PICKUP_BEEN_COLLECTED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_REMOVE_PICKUP( int pickup) { invoke<void )
	{
		OBJECT::REMOVE_PICKUP(invoke<void);
	}

	void LUA_NATIVE_OBJECT_CREATE_MONEY_PICKUPS( float x, float y, float z, int value, int amount, unsigned model) { invoke<void )
	{
		OBJECT::CREATE_MONEY_PICKUPS(x, y, z, value, amount, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_DOES_PICKUP_EXIST( int pickup) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOES_PICKUP_EXIST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_DOES_PICKUP_OBJECT_EXIST( Object pickupObject) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOES_PICKUP_OBJECT_EXIST(invoke<BOOL);
		return retval;
	}

	Object LUA_NATIVE_OBJECT_GET_PICKUP_OBJECT( int pickup) { return invoke<Object )
	{
		auto retval = OBJECT::GET_PICKUP_OBJECT(invoke<Object);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_A_PICKUP( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_A_PICKUP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_OBJECT_A_PORTABLE_PICKUP( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_OBJECT_A_PORTABLE_PICKUP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_DOES_PICKUP_OF_TYPE_EXIST_IN_AREA( unsigned pickupHash, float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::DOES_PICKUP_OF_TYPE_EXIST_IN_AREA(pickupHash, x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_REGENERATION_TIME( int pickup, int duration) { invoke<void )
	{
		OBJECT::SET_PICKUP_REGENERATION_TIME(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_FORCE_PICKUP_REGENERATE( Any p0) { invoke<void )
	{
		OBJECT::FORCE_PICKUP_REGENERATE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE( int player, unsigned pickupHash, bool toggle) { invoke<void )
	{
		OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(player, pickupHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_LOCAL_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_WITH_MODEL( unsigned modelHash, bool toggle) { invoke<void )
	{
		OBJECT::SET_LOCAL_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_WITH_MODEL(modelHash, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ALLOW_ALL_PLAYERS_TO_COLLECT_PICKUPS_OF_TYPE( unsigned pickupHash) { invoke<void )
	{
		OBJECT::ALLOW_ALL_PLAYERS_TO_COLLECT_PICKUPS_OF_TYPE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_TEAM_PICKUP_OBJECT( Object object, Any p1, bool p2) { invoke<void )
	{
		OBJECT::SET_TEAM_PICKUP_OBJECT(object, p1, invoke<void);
	}

	void LUA_NATIVE_OBJECT_PREVENT_COLLECTION_OF_PORTABLE_PICKUP( Object object, bool p1, bool p2) { invoke<void )
	{
		OBJECT::PREVENT_COLLECTION_OF_PORTABLE_PICKUP(object, p1, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_GLOW_WHEN_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_GLOW_WHEN_UNCOLLECTABLE(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_GLOW_OFFSET( int pickup, float p1) { invoke<void )
	{
		OBJECT::SET_PICKUP_GLOW_OFFSET(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_GLOW_OFFSET( int pickup, float p1, bool p2) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_GLOW_OFFSET(pickup, p1, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_GLOW_IN_SAME_TEAM( int pickup) { invoke<void )
	{
		OBJECT::SET_OBJECT_GLOW_IN_SAME_TEAM(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_ARROW_MARKER( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_ARROW_MARKER(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ALLOW_PICKUP_ARROW_MARKER_WHEN_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::ALLOW_PICKUP_ARROW_MARKER_WHEN_UNCOLLECTABLE(pickup, invoke<void);
	}

	int LUA_NATIVE_OBJECT_GET_DEFAULT_AMMO_FOR_WEAPON_PICKUP( unsigned pickupHash) { return invoke<int )
	{
		auto retval = OBJECT::GET_DEFAULT_AMMO_FOR_WEAPON_PICKUP(invoke<int);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_GENERATION_RANGE_MULTIPLIER( float multiplier) { invoke<void )
	{
		OBJECT::SET_PICKUP_GENERATION_RANGE_MULTIPLIER(invoke<void);
	}

	float LUA_NATIVE_OBJECT_GET_PICKUP_GENERATION_RANGE_MULTIPLIER(  )
	{
		auto retval = OBJECT::GET_PICKUP_GENERATION_RANGE_MULTIPLIER();
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_ONLY_ALLOW_AMMO_COLLECTION_WHEN_LOW( bool p0) { invoke<void )
	{
		OBJECT::SET_ONLY_ALLOW_AMMO_COLLECTION_WHEN_LOW(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_UNCOLLECTABLE(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_TRANSPARENT_WHEN_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_TRANSPARENT_WHEN_UNCOLLECTABLE(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_HIDDEN_WHEN_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_HIDDEN_WHEN_UNCOLLECTABLE(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_TRANSPARENT_WHEN_UNCOLLECTABLE( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_TRANSPARENT_WHEN_UNCOLLECTABLE(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_ALPHA_WHEN_TRANSPARENT( int p0) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_ALPHA_WHEN_TRANSPARENT(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PORTABLE_PICKUP_PERSIST( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PORTABLE_PICKUP_PERSIST(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ALLOW_PORTABLE_PICKUP_TO_MIGRATE_TO_NON_PARTICIPANTS( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::ALLOW_PORTABLE_PICKUP_TO_MIGRATE_TO_NON_PARTICIPANTS(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_FORCE_ACTIVATE_PHYSICS_ON_UNFIXED_PICKUP( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::FORCE_ACTIVATE_PHYSICS_ON_UNFIXED_PICKUP(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ALLOW_PICKUP_BY_NONE_PARTICIPANT( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::ALLOW_PICKUP_BY_NONE_PARTICIPANT(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SUPPRESS_PICKUP_REWARD_TYPE( int rewardType, bool suppress) { invoke<void )
	{
		OBJECT::SUPPRESS_PICKUP_REWARD_TYPE(rewardType, invoke<void);
	}

	void LUA_NATIVE_OBJECT_CLEAR_ALL_PICKUP_REWARD_TYPE_SUPPRESSION(  )
	{
		OBJECT::CLEAR_ALL_PICKUP_REWARD_TYPE_SUPPRESSION();
	}

	void LUA_NATIVE_OBJECT_CLEAR_PICKUP_REWARD_TYPE_SUPPRESSION( int rewardType) { invoke<void )
	{
		OBJECT::CLEAR_PICKUP_REWARD_TYPE_SUPPRESSION(invoke<void);
	}

	void LUA_NATIVE_OBJECT_RENDER_FAKE_PICKUP_GLOW( float x, float y, float z, int colorIndex) { invoke<void )
	{
		OBJECT::RENDER_FAKE_PICKUP_GLOW(x, y, z, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_OBJECT_COLLECTABLE_IN_VEHICLE( int pickup) { invoke<void )
	{
		OBJECT::SET_PICKUP_OBJECT_COLLECTABLE_IN_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PICKUP_TRACK_DAMAGE_EVENTS( int pickup, bool toggle) { invoke<void )
	{
		OBJECT::SET_PICKUP_TRACK_DAMAGE_EVENTS(pickup, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_ENTITY_FLAG_SUPPRESS_SHADOW( int entity, bool toggle) { invoke<void )
	{
		OBJECT::SET_ENTITY_FLAG_SUPPRESS_SHADOW(entity, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_ENTITY_FLAG_RENDER_SMALL_SHADOW( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_ENTITY_FLAG_RENDER_SMALL_SHADOW(object, invoke<void);
	}

	unsigned LUA_NATIVE_OBJECT_GET_WEAPON_TYPE_FROM_PICKUP_TYPE( unsigned pickupHash) { return invoke<unsigned )
	{
		auto retval = OBJECT::GET_WEAPON_TYPE_FROM_PICKUP_TYPE(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_OBJECT_GET_PICKUP_TYPE_FROM_WEAPON_HASH( unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = OBJECT::GET_PICKUP_TYPE_FROM_WEAPON_HASH(invoke<unsigned);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_PICKUP_WEAPON_OBJECT_VALID( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_PICKUP_WEAPON_OBJECT_VALID(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_OBJECT_GET_OBJECT_TINT_INDEX( Object object) { return invoke<int )
	{
		auto retval = OBJECT::GET_OBJECT_TINT_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_TINT_INDEX( Object object, int textureVariation) { invoke<void )
	{
		OBJECT::SET_OBJECT_TINT_INDEX(object, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_SET_TINT_INDEX_CLOSEST_BUILDING_OF_TYPE( float x, float y, float z, float radius, unsigned modelHash, int textureVariation) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::SET_TINT_INDEX_CLOSEST_BUILDING_OF_TYPE(x, y, z, radius, modelHash, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_PROP_TINT_INDEX( Any p0, Any p1) { invoke<void )
	{
		OBJECT::SET_PROP_TINT_INDEX(p0, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_SET_PROP_LIGHT_COLOR( Object object, bool p1, int r, int g, int b) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::SET_PROP_LIGHT_COLOR(object, p1, r, g, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_IS_PROP_LIGHT_OVERRIDEN( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::IS_PROP_LIGHT_OVERRIDEN(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_IS_VISIBLE_IN_MIRRORS( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_OBJECT_IS_VISIBLE_IN_MIRRORS(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_SPEED_BOOST_AMOUNT( Object object, Any p1) { invoke<void )
	{
		OBJECT::SET_OBJECT_SPEED_BOOST_AMOUNT(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_SPEED_BOOST_DURATION( Object object, float duration) { invoke<void )
	{
		OBJECT::SET_OBJECT_SPEED_BOOST_DURATION(object, invoke<void);
	}

	unsigned LUA_NATIVE_OBJECT_CONVERT_OLD_PICKUP_TYPE_TO_NEW( unsigned pickupHash) { return invoke<unsigned )
	{
		auto retval = OBJECT::CONVERT_OLD_PICKUP_TYPE_TO_NEW(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_FORCE_OBJECT_THIS_FRAME( float x, float y, float z, float p3) { invoke<void )
	{
		OBJECT::SET_FORCE_OBJECT_THIS_FRAME(x, y, z, invoke<void);
	}

	void LUA_NATIVE_OBJECT_ONLY_CLEAN_UP_OBJECT_WHEN_OUT_OF_RANGE( Object object) { invoke<void )
	{
		OBJECT::ONLY_CLEAN_UP_OBJECT_WHEN_OUT_OF_RANGE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_DISABLE_COLLISIONS_BETWEEN_CARS_AND_CAR_PARACHUTE( Any p0) { invoke<void )
	{
		OBJECT::SET_DISABLE_COLLISIONS_BETWEEN_CARS_AND_CAR_PARACHUTE(invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_PROJECTILES_SHOULD_EXPLODE_ON_CONTACT( int entity, Any p1) { invoke<void )
	{
		OBJECT::SET_PROJECTILES_SHOULD_EXPLODE_ON_CONTACT(entity, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_DRIVE_ARTICULATED_JOINT( Object object, bool toggle, int p2) { invoke<void )
	{
		OBJECT::SET_DRIVE_ARTICULATED_JOINT(object, toggle, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_DRIVE_ARTICULATED_JOINT_WITH_INFLICTOR( Object object, bool toggle, int p2, int ped) { invoke<void )
	{
		OBJECT::SET_DRIVE_ARTICULATED_JOINT_WITH_INFLICTOR(object, toggle, p2, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_OBJECT_IS_A_PRESSURE_PLATE( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_OBJECT_IS_A_PRESSURE_PLATE(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_WEAPON_IMPACTS_APPLY_GREATER_FORCE( Object object, bool p1) { invoke<void )
	{
		OBJECT::SET_WEAPON_IMPACTS_APPLY_GREATER_FORCE(object, invoke<void);
	}

	bool LUA_NATIVE_OBJECT_GET_IS_ARTICULATED_JOINT_AT_MIN_ANGLE( Object object, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::GET_IS_ARTICULATED_JOINT_AT_MIN_ANGLE(object, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_OBJECT_GET_IS_ARTICULATED_JOINT_AT_MAX_ANGLE( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)OBJECT::GET_IS_ARTICULATED_JOINT_AT_MAX_ANGLE(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_OBJECT_SET_IS_OBJECT_ARTICULATED( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_IS_OBJECT_ARTICULATED(object, invoke<void);
	}

	void LUA_NATIVE_OBJECT_SET_IS_OBJECT_BALL( Object object, bool toggle) { invoke<void )
	{
		OBJECT::SET_IS_OBJECT_BALL(object, invoke<void);
	}

	bool LUA_NATIVE_PAD_IS_CONTROL_ENABLED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_CONTROL_ENABLED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_CONTROL_PRESSED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_CONTROL_PRESSED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_CONTROL_RELEASED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_CONTROL_RELEASED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_CONTROL_JUST_PRESSED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_CONTROL_JUST_PRESSED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_CONTROL_JUST_RELEASED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_CONTROL_JUST_RELEASED(control, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PAD_GET_CONTROL_VALUE( int control, int action) { return invoke<int )
	{
		auto retval = PAD::GET_CONTROL_VALUE(control, invoke<int);
		return retval;
	}

	float LUA_NATIVE_PAD_GET_CONTROL_NORMAL( int control, int action) { return invoke<float )
	{
		auto retval = PAD::GET_CONTROL_NORMAL(control, invoke<float);
		return retval;
	}

	void LUA_NATIVE_PAD_SET_USE_ADJUSTED_MOUSE_COORDS( bool toggle) { invoke<void )
	{
		PAD::SET_USE_ADJUSTED_MOUSE_COORDS(invoke<void);
	}

	float LUA_NATIVE_PAD_GET_CONTROL_UNBOUND_NORMAL( int control, int action) { return invoke<float )
	{
		auto retval = PAD::GET_CONTROL_UNBOUND_NORMAL(control, invoke<float);
		return retval;
	}

	bool LUA_NATIVE_PAD_SET_CONTROL_VALUE_NEXT_FRAME( int control, int action, float value) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::SET_CONTROL_VALUE_NEXT_FRAME(control, action, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_DISABLED_CONTROL_PRESSED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_DISABLED_CONTROL_PRESSED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_DISABLED_CONTROL_RELEASED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_DISABLED_CONTROL_RELEASED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_DISABLED_CONTROL_JUST_PRESSED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_DISABLED_CONTROL_JUST_PRESSED(control, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_DISABLED_CONTROL_JUST_RELEASED( int control, int action) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_DISABLED_CONTROL_JUST_RELEASED(control, invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_PAD_GET_DISABLED_CONTROL_NORMAL( int control, int action) { return invoke<float )
	{
		auto retval = PAD::GET_DISABLED_CONTROL_NORMAL(control, invoke<float);
		return retval;
	}

	float LUA_NATIVE_PAD_GET_DISABLED_CONTROL_UNBOUND_NORMAL( int control, int action) { return invoke<float )
	{
		auto retval = PAD::GET_DISABLED_CONTROL_UNBOUND_NORMAL(control, invoke<float);
		return retval;
	}

	int LUA_NATIVE_PAD_GET_CONTROL_HOW_LONG_AGO( int control) { return invoke<int )
	{
		auto retval = PAD::GET_CONTROL_HOW_LONG_AGO(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_USING_KEYBOARD_AND_MOUSE( int control) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_USING_KEYBOARD_AND_MOUSE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_USING_CURSOR( int control) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_USING_CURSOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_SET_CURSOR_POSITION( float x, float y) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::SET_CURSOR_POSITION(x, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_USING_REMOTE_PLAY( int control) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::IS_USING_REMOTE_PLAY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_HAVE_CONTROLS_CHANGED( int control) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::HAVE_CONTROLS_CHANGED(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_PAD_GET_CONTROL_INSTRUCTIONAL_BUTTONS_STRING( int control, int action, bool allowXOSwap) { return invoke<const char* )
	{
		auto retval = PAD::GET_CONTROL_INSTRUCTIONAL_BUTTONS_STRING(control, action, char*);
		return retval;
	}

	const char* LUA_NATIVE_PAD_GET_CONTROL_GROUP_INSTRUCTIONAL_BUTTONS_STRING( int control, int controlGroup, bool allowXOSwap) { return invoke<const char* )
	{
		auto retval = PAD::GET_CONTROL_GROUP_INSTRUCTIONAL_BUTTONS_STRING(control, controlGroup, char*);
		return retval;
	}

	void LUA_NATIVE_PAD_SET_CONTROL_LIGHT_EFFECT_COLOR( int control, int red, int green, int blue) { invoke<void )
	{
		PAD::SET_CONTROL_LIGHT_EFFECT_COLOR(control, red, green, invoke<void);
	}

	void LUA_NATIVE_PAD_CLEAR_CONTROL_LIGHT_EFFECT( int control) { invoke<void )
	{
		PAD::CLEAR_CONTROL_LIGHT_EFFECT(invoke<void);
	}

	void LUA_NATIVE_PAD_SET_CONTROL_SHAKE( int control, int duration, int frequency) { invoke<void )
	{
		PAD::SET_CONTROL_SHAKE(control, duration, invoke<void);
	}

	void LUA_NATIVE_PAD_SET_CONTROL_TRIGGER_SHAKE( int control, int leftDuration, int leftFrequency, int rightDuration, int rightFrequency) { invoke<void )
	{
		PAD::SET_CONTROL_TRIGGER_SHAKE(control, leftDuration, leftFrequency, rightDuration, invoke<void);
	}

	void LUA_NATIVE_PAD_STOP_CONTROL_SHAKE( int control) { invoke<void )
	{
		PAD::STOP_CONTROL_SHAKE(invoke<void);
	}

	void LUA_NATIVE_PAD_SET_CONTROL_SHAKE_SUPPRESSED_ID( int control, int uniqueId) { invoke<void )
	{
		PAD::SET_CONTROL_SHAKE_SUPPRESSED_ID(control, invoke<void);
	}

	void LUA_NATIVE_PAD_CLEAR_CONTROL_SHAKE_SUPPRESSED_ID( int control) { invoke<void )
	{
		PAD::CLEAR_CONTROL_SHAKE_SUPPRESSED_ID(invoke<void);
	}

	bool LUA_NATIVE_PAD_IS_LOOK_INVERTED(  )
	{
		auto retval = (bool)PAD::IS_LOOK_INVERTED();
		return retval;
	}

	bool LUA_NATIVE_PAD_IS_MOUSE_LOOK_INVERTED(  )
	{
		auto retval = (bool)PAD::IS_MOUSE_LOOK_INVERTED();
		return retval;
	}

	int LUA_NATIVE_PAD_GET_LOCAL_PLAYER_AIM_STATE(  )
	{
		auto retval = PAD::GET_LOCAL_PLAYER_AIM_STATE();
		return retval;
	}

	int LUA_NATIVE_PAD_GET_LOCAL_PLAYER_GAMEPAD_AIM_STATE(  )
	{
		auto retval = PAD::GET_LOCAL_PLAYER_GAMEPAD_AIM_STATE();
		return retval;
	}

	bool LUA_NATIVE_PAD_GET_IS_USING_ALTERNATE_HANDBRAKE(  )
	{
		auto retval = (bool)PAD::GET_IS_USING_ALTERNATE_HANDBRAKE();
		return retval;
	}

	bool LUA_NATIVE_PAD_GET_IS_USING_ALTERNATE_DRIVEBY(  )
	{
		auto retval = (bool)PAD::GET_IS_USING_ALTERNATE_DRIVEBY();
		return retval;
	}

	bool LUA_NATIVE_PAD_GET_ALLOW_MOVEMENT_WHILE_ZOOMED(  )
	{
		auto retval = (bool)PAD::GET_ALLOW_MOVEMENT_WHILE_ZOOMED();
		return retval;
	}

	void LUA_NATIVE_PAD_SET_PLAYERPAD_SHAKES_WHEN_CONTROLLER_DISABLED( bool toggle) { invoke<void )
	{
		PAD::SET_PLAYERPAD_SHAKES_WHEN_CONTROLLER_DISABLED(invoke<void);
	}

	void LUA_NATIVE_PAD_SET_INPUT_EXCLUSIVE( int control, int action) { invoke<void )
	{
		PAD::SET_INPUT_EXCLUSIVE(control, invoke<void);
	}

	void LUA_NATIVE_PAD_DISABLE_CONTROL_ACTION( int control, int action, bool disableRelatedActions) { invoke<void )
	{
		PAD::DISABLE_CONTROL_ACTION(control, action, invoke<void);
	}

	void LUA_NATIVE_PAD_ENABLE_CONTROL_ACTION( int control, int action, bool enableRelatedActions) { invoke<void )
	{
		PAD::ENABLE_CONTROL_ACTION(control, action, invoke<void);
	}

	void LUA_NATIVE_PAD_DISABLE_ALL_CONTROL_ACTIONS( int control) { invoke<void )
	{
		PAD::DISABLE_ALL_CONTROL_ACTIONS(invoke<void);
	}

	void LUA_NATIVE_PAD_ENABLE_ALL_CONTROL_ACTIONS( int control) { invoke<void )
	{
		PAD::ENABLE_ALL_CONTROL_ACTIONS(invoke<void);
	}

	bool LUA_NATIVE_PAD_INIT_PC_SCRIPTED_CONTROLS( const char* schemeName) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::INIT_PC_SCRIPTED_CONTROLS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PAD_SWITCH_PC_SCRIPTED_CONTROLS( const char* schemeName) { return invoke<BOOL )
	{
		auto retval = (bool)PAD::SWITCH_PC_SCRIPTED_CONTROLS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PAD_SHUTDOWN_PC_SCRIPTED_CONTROLS(  )
	{
		PAD::SHUTDOWN_PC_SCRIPTED_CONTROLS();
	}

	void LUA_NATIVE_PAD_ALLOW_ALTERNATIVE_SCRIPT_CONTROLS_LAYOUT( int control) { invoke<void )
	{
		PAD::ALLOW_ALTERNATIVE_SCRIPT_CONTROLS_LAYOUT(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_ROADS_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool nodeEnabled, bool unknown2) { invoke<void )
	{
		PATHFIND::SET_ROADS_IN_AREA(x1, y1, z1, x2, y2, z2, nodeEnabled, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_ROADS_IN_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width, bool unknown1, bool unknown2, bool unknown3) { invoke<void )
	{
		PATHFIND::SET_ROADS_IN_ANGLED_AREA(x1, y1, z1, x2, y2, z2, width, unknown1, unknown2, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_PED_PATHS_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool p6, Any p7) { invoke<void )
	{
		PATHFIND::SET_PED_PATHS_IN_AREA(x1, y1, z1, x2, y2, z2, p6, invoke<void);
	}

	std::tuple<bool, Vector3> LUA_NATIVE_PATHFIND_GET_SAFE_COORD_FOR_PED( float x, float y, float z, bool onGround, Vector3 outPosition, int flags) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_SAFE_COORD_FOR_PED(x, y, z, onGround, &outPosition, invoke<BOOL);
		std::get<1>(return_values) = outPosition;

		return return_values;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_PATHFIND_GET_CLOSEST_VEHICLE_NODE( float x, float y, float z, Vector3 outPosition, int nodeFlags, float p5, float p6) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_CLOSEST_VEHICLE_NODE(x, y, z, &outPosition, nodeFlags, p5, invoke<BOOL);
		std::get<1>(return_values) = outPosition;

		return return_values;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_PATHFIND_GET_CLOSEST_MAJOR_VEHICLE_NODE( float x, float y, float z, Vector3 outPosition, float unknown1, float unknown2) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_CLOSEST_MAJOR_VEHICLE_NODE(x, y, z, &outPosition, unknown1, invoke<BOOL);
		std::get<1>(return_values) = outPosition;

		return return_values;
	}

	std::tuple<bool, Vector3, float> LUA_NATIVE_PATHFIND_GET_CLOSEST_VEHICLE_NODE_WITH_HEADING( float x, float y, float z, Vector3 outPosition, float outHeading, int nodeType, float p6, float p7) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, float> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_CLOSEST_VEHICLE_NODE_WITH_HEADING(x, y, z, &outPosition, &outHeading, nodeType, p6, invoke<BOOL);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = outHeading;

		return return_values;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_PATHFIND_GET_NTH_CLOSEST_VEHICLE_NODE( float x, float y, float z, int nthClosest, Vector3 outPosition, int nodeFlags, float unknown1, float unknown2) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_NTH_CLOSEST_VEHICLE_NODE(x, y, z, nthClosest, &outPosition, nodeFlags, unknown1, invoke<BOOL);
		std::get<1>(return_values) = outPosition;

		return return_values;
	}

	int LUA_NATIVE_PATHFIND_GET_NTH_CLOSEST_VEHICLE_NODE_ID( float x, float y, float z, int nth, int nodeFlags, float p5, float p6) { return invoke<int )
	{
		auto retval = PATHFIND::GET_NTH_CLOSEST_VEHICLE_NODE_ID(x, y, z, nth, nodeFlags, p5, invoke<int);
		return retval;
	}

	std::tuple<bool, Vector3, float, int> LUA_NATIVE_PATHFIND_GET_NTH_CLOSEST_VEHICLE_NODE_WITH_HEADING( float x, float y, float z, int nthClosest, Vector3 outPosition, float outHeading, int outNumLanes, int nodeFlags, float unknown3, float unknown4) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, float, int> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_NTH_CLOSEST_VEHICLE_NODE_WITH_HEADING(x, y, z, nthClosest, &outPosition, &outHeading, &outNumLanes, nodeFlags, unknown3, invoke<BOOL);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = outHeading;
		std::get<3>(return_values) = outNumLanes;

		return return_values;
	}

	std::tuple<int, Vector3, float> LUA_NATIVE_PATHFIND_GET_NTH_CLOSEST_VEHICLE_NODE_ID_WITH_HEADING( float x, float y, float z, int nthClosest, Vector3 outPosition, float outHeading, int nodeFlags, float p7, float p8) { return invoke<int )
	{
		std::tuple<int, Vector3, float> return_values;
		std::get<0>(return_values) = PATHFIND::GET_NTH_CLOSEST_VEHICLE_NODE_ID_WITH_HEADING(x, y, z, nthClosest, &outPosition, &outHeading, nodeFlags, p7, invoke<int);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = outHeading;

		return return_values;
	}

	std::tuple<bool, Vector3, float> LUA_NATIVE_PATHFIND_GET_NTH_CLOSEST_VEHICLE_NODE_FAVOUR_DIRECTION( float x, float y, float z, float desiredX, float desiredY, float desiredZ, int nthClosest, Vector3 outPosition, float outHeading, int nodeFlags, float p10, float p11) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, float> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_NTH_CLOSEST_VEHICLE_NODE_FAVOUR_DIRECTION(x, y, z, desiredX, desiredY, desiredZ, nthClosest, &outPosition, &outHeading, nodeFlags, p10, invoke<BOOL);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = outHeading;

		return return_values;
	}

	std::tuple<bool, int, int flags) { return> LUA_NATIVE_PATHFIND_GET_VEHICLE_NODE_PROPERTIES( float x, float y, float z, int density, int flags) { return invoke<BOOL )
	{
		std::tuple<bool, int, int flags) { return> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_VEHICLE_NODE_PROPERTIES(x, y, z, &density, &invoke<BOOL);
		std::get<1>(return_values) = density;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_PATHFIND_IS_VEHICLE_NODE_ID_VALID( int vehicleNodeId) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::IS_VEHICLE_NODE_ID_VALID(invoke<BOOL);
		return retval;
	}

	Vector3 outPosition) { LUA_NATIVE_PATHFIND_GET_VEHICLE_NODE_POSITION( int nodeId, Vector3 outPosition) { invoke<void )
	{
		PATHFIND::GET_VEHICLE_NODE_POSITION(nodeId, &invoke<void);
		return invoke<void;
	}

	bool LUA_NATIVE_PATHFIND_GET_VEHICLE_NODE_IS_GPS_ALLOWED( int nodeID) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::GET_VEHICLE_NODE_IS_GPS_ALLOWED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PATHFIND_GET_VEHICLE_NODE_IS_SWITCHED_OFF( int nodeID) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::GET_VEHICLE_NODE_IS_SWITCHED_OFF(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Vector3, Vector3, Any, Any, float> LUA_NATIVE_PATHFIND_GET_CLOSEST_ROAD( float x, float y, float z, float p3, int p4, Vector3 p5, Vector3 p6, Any p7, Any p8, float p9, bool p10) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, Vector3, Any, Any, float> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_CLOSEST_ROAD(x, y, z, p3, p4, &p5, &p6, &p7, &p8, &p9, invoke<BOOL);
		std::get<1>(return_values) = p5;
		std::get<2>(return_values) = p6;
		std::get<3>(return_values) = p7;
		std::get<4>(return_values) = p8;
		std::get<5>(return_values) = p9;

		return return_values;
	}

	bool LUA_NATIVE_PATHFIND_LOAD_ALL_PATH_NODES( bool set) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::LOAD_ALL_PATH_NODES(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PATHFIND_SET_ALLOW_STREAM_PROLOGUE_NODES( bool toggle) { invoke<void )
	{
		PATHFIND::SET_ALLOW_STREAM_PROLOGUE_NODES(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_ALLOW_STREAM_HEIST_ISLAND_NODES( int type) { invoke<void )
	{
		PATHFIND::SET_ALLOW_STREAM_HEIST_ISLAND_NODES(invoke<void);
	}

	bool LUA_NATIVE_PATHFIND_ARE_NODES_LOADED_FOR_AREA( float x1, float y1, float x2, float y2) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::ARE_NODES_LOADED_FOR_AREA(x1, y1, x2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PATHFIND_REQUEST_PATH_NODES_IN_AREA_THIS_FRAME( float x1, float y1, float x2, float y2) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::REQUEST_PATH_NODES_IN_AREA_THIS_FRAME(x1, y1, x2, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PATHFIND_SET_ROADS_BACK_TO_ORIGINAL( float p0, float p1, float p2, float p3, float p4, float p5, Any p6) { invoke<void )
	{
		PATHFIND::SET_ROADS_BACK_TO_ORIGINAL(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_ROADS_BACK_TO_ORIGINAL_IN_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width, Any p7) { invoke<void )
	{
		PATHFIND::SET_ROADS_BACK_TO_ORIGINAL_IN_ANGLED_AREA(x1, y1, z1, x2, y2, z2, width, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_AMBIENT_PED_RANGE_MULTIPLIER_THIS_FRAME( float multiplier) { invoke<void )
	{
		PATHFIND::SET_AMBIENT_PED_RANGE_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_ADJUST_AMBIENT_PED_SPAWN_DENSITIES_THIS_FRAME( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		PATHFIND::ADJUST_AMBIENT_PED_SPAWN_DENSITIES_THIS_FRAME(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_PED_PATHS_BACK_TO_ORIGINAL( float x1, float y1, float z1, float x2, float y2, float z2, Any p6) { invoke<void )
	{
		PATHFIND::SET_PED_PATHS_BACK_TO_ORIGINAL(x1, y1, z1, x2, y2, z2, invoke<void);
	}

	std::tuple<bool, Vector3, int nodeId) { return> LUA_NATIVE_PATHFIND_GET_RANDOM_VEHICLE_NODE( float x, float y, float z, float radius, bool p4, bool p5, bool p6, Vector3 outPosition, int nodeId) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, int nodeId) { return> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_RANDOM_VEHICLE_NODE(x, y, z, radius, p4, p5, p6, &outPosition, &invoke<BOOL);
		std::get<1>(return_values) = outPosition;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<Vector3, Vector3, float heading) { return> LUA_NATIVE_PATHFIND_GET_SPAWN_COORDS_FOR_VEHICLE_NODE( int nodeAddress, float towardsCoorsX, float towardsCoorsY, float towardsCoorsZ, Vector3 centrePoint, float heading) { return invoke<Vector3 )
	{
		std::tuple<Vector3, Vector3, float heading) { return> return_values;
		std::get<0>(return_values) = PATHFIND::GET_SPAWN_COORDS_FOR_VEHICLE_NODE(nodeAddress, towardsCoorsX, towardsCoorsY, towardsCoorsZ, &centrePoint, &invoke<Vector3);
		std::get<1>(return_values) = centrePoint;
		std::get<2>(return_values) = invoke<Vector3;

		return return_values;
	}

	std::tuple<unsigned, unsigned crossingRoad) {> LUA_NATIVE_PATHFIND_GET_STREET_NAME_AT_COORD( float x, float y, float z, unsigned streetName, unsigned crossingRoad) { invoke<void )
	{
		std::tuple<unsigned, unsigned crossingRoad) {> return_values;
		PATHFIND::GET_STREET_NAME_AT_COORD(x, y, z, &streetName, &invoke<void);
		std::get<0>(return_values) = streetName;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int, float, float distToNxJunction) { return> LUA_NATIVE_PATHFIND_GENERATE_DIRECTIONS_TO_COORD( float x, float y, float z, bool p3, int direction, float p5, float distToNxJunction) { return invoke<int )
	{
		std::tuple<int, int, float, float distToNxJunction) { return> return_values;
		std::get<0>(return_values) = PATHFIND::GENERATE_DIRECTIONS_TO_COORD(x, y, z, p3, &direction, &p5, &invoke<int);
		std::get<1>(return_values) = direction;
		std::get<2>(return_values) = p5;
		std::get<3>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_PATHFIND_SET_IGNORE_NO_GPS_FLAG( bool toggle) { invoke<void )
	{
		PATHFIND::SET_IGNORE_NO_GPS_FLAG(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_IGNORE_NO_GPS_FLAG_UNTIL_FIRST_NORMAL_NODE( bool toggle) { invoke<void )
	{
		PATHFIND::SET_IGNORE_NO_GPS_FLAG_UNTIL_FIRST_NORMAL_NODE(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_SET_GPS_DISABLED_ZONE( float x1, float y1, float z1, float x2, float y2, float z3) { invoke<void )
	{
		PATHFIND::SET_GPS_DISABLED_ZONE(x1, y1, z1, x2, y2, invoke<void);
	}

	int LUA_NATIVE_PATHFIND_GET_GPS_BLIP_ROUTE_LENGTH(  )
	{
		auto retval = PATHFIND::GET_GPS_BLIP_ROUTE_LENGTH();
		return retval;
	}

	std::tuple<bool, Vector3> LUA_NATIVE_PATHFIND_GET_POS_ALONG_GPS_TYPE_ROUTE( Vector3 result, bool p1, float p2, int p3) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_POS_ALONG_GPS_TYPE_ROUTE(&result, p1, p2, invoke<BOOL);
		std::get<1>(return_values) = result;

		return return_values;
	}

	bool LUA_NATIVE_PATHFIND_GET_GPS_BLIP_ROUTE_FOUND(  )
	{
		auto retval = (bool)PATHFIND::GET_GPS_BLIP_ROUTE_FOUND();
		return retval;
	}

	std::tuple<bool, Vector3 outPosition) { return> LUA_NATIVE_PATHFIND_GET_ROAD_BOUNDARY_USING_HEADING( float x, float y, float z, float heading, Vector3 outPosition) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 outPosition) { return> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_ROAD_BOUNDARY_USING_HEADING(x, y, z, heading, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Vector3 outPosition) { return> LUA_NATIVE_PATHFIND_GET_POSITION_BY_SIDE_OF_ROAD( float x, float y, float z, int p3, Vector3 outPosition) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 outPosition) { return> return_values;
		std::get<0>(return_values) = (bool)PATHFIND::GET_POSITION_BY_SIDE_OF_ROAD(x, y, z, p3, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_PATHFIND_IS_POINT_ON_ROAD( float x, float y, float z, int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::IS_POINT_ON_ROAD(x, y, z, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PATHFIND_GET_NEXT_GPS_DISABLED_ZONE_INDEX(  )
	{
		auto retval = PATHFIND::GET_NEXT_GPS_DISABLED_ZONE_INDEX();
		return retval;
	}

	void LUA_NATIVE_PATHFIND_SET_GPS_DISABLED_ZONE_AT_INDEX( float x1, float y1, float z1, float x2, float y2, float z2, int index) { invoke<void )
	{
		PATHFIND::SET_GPS_DISABLED_ZONE_AT_INDEX(x1, y1, z1, x2, y2, z2, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_CLEAR_GPS_DISABLED_ZONE_AT_INDEX( int index) { invoke<void )
	{
		PATHFIND::CLEAR_GPS_DISABLED_ZONE_AT_INDEX(invoke<void);
	}

	void LUA_NATIVE_PATHFIND_ADD_NAVMESH_REQUIRED_REGION( float x, float y, float radius) { invoke<void )
	{
		PATHFIND::ADD_NAVMESH_REQUIRED_REGION(x, y, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_REMOVE_NAVMESH_REQUIRED_REGIONS(  )
	{
		PATHFIND::REMOVE_NAVMESH_REQUIRED_REGIONS();
	}

	bool LUA_NATIVE_PATHFIND_IS_NAVMESH_REQUIRED_REGION_IN_USE(  )
	{
		auto retval = (bool)PATHFIND::IS_NAVMESH_REQUIRED_REGION_IN_USE();
		return retval;
	}

	void LUA_NATIVE_PATHFIND_DISABLE_NAVMESH_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool toggle) { invoke<void )
	{
		PATHFIND::DISABLE_NAVMESH_IN_AREA(x1, y1, z1, x2, y2, z2, invoke<void);
	}

	bool LUA_NATIVE_PATHFIND_ARE_ALL_NAVMESH_REGIONS_LOADED(  )
	{
		auto retval = (bool)PATHFIND::ARE_ALL_NAVMESH_REGIONS_LOADED();
		return retval;
	}

	bool LUA_NATIVE_PATHFIND_IS_NAVMESH_LOADED_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::IS_NAVMESH_LOADED_IN_AREA(x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PATHFIND_GET_NUM_NAVMESHES_EXISTING_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<int )
	{
		auto retval = PATHFIND::GET_NUM_NAVMESHES_EXISTING_IN_AREA(x1, y1, z1, x2, y2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PATHFIND_ADD_NAVMESH_BLOCKING_OBJECT( float p0, float p1, float p2, float p3, float p4, float p5, float p6, bool p7, Any p8) { return invoke<int )
	{
		auto retval = PATHFIND::ADD_NAVMESH_BLOCKING_OBJECT(p0, p1, p2, p3, p4, p5, p6, p7, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PATHFIND_UPDATE_NAVMESH_BLOCKING_OBJECT( Any p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, Any p8) { invoke<void )
	{
		PATHFIND::UPDATE_NAVMESH_BLOCKING_OBJECT(p0, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_PATHFIND_REMOVE_NAVMESH_BLOCKING_OBJECT( Any p0) { invoke<void )
	{
		PATHFIND::REMOVE_NAVMESH_BLOCKING_OBJECT(invoke<void);
	}

	bool LUA_NATIVE_PATHFIND_DOES_NAVMESH_BLOCKING_OBJECT_EXIST( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PATHFIND::DOES_NAVMESH_BLOCKING_OBJECT_EXIST(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_PATHFIND_GET_APPROX_HEIGHT_FOR_POINT( float x, float y) { return invoke<float )
	{
		auto retval = PATHFIND::GET_APPROX_HEIGHT_FOR_POINT(x, invoke<float);
		return retval;
	}

	float LUA_NATIVE_PATHFIND_GET_APPROX_HEIGHT_FOR_AREA( float x1, float y1, float x2, float y2) { return invoke<float )
	{
		auto retval = PATHFIND::GET_APPROX_HEIGHT_FOR_AREA(x1, y1, x2, invoke<float);
		return retval;
	}

	float LUA_NATIVE_PATHFIND_GET_APPROX_FLOOR_FOR_POINT( float x, float y) { return invoke<float )
	{
		auto retval = PATHFIND::GET_APPROX_FLOOR_FOR_POINT(x, invoke<float);
		return retval;
	}

	float LUA_NATIVE_PATHFIND_GET_APPROX_FLOOR_FOR_AREA( float x1, float y1, float x2, float y2) { return invoke<float )
	{
		auto retval = PATHFIND::GET_APPROX_FLOOR_FOR_AREA(x1, y1, x2, invoke<float);
		return retval;
	}

	float LUA_NATIVE_PATHFIND_CALCULATE_TRAVEL_DISTANCE_BETWEEN_POINTS( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<float )
	{
		auto retval = PATHFIND::CALCULATE_TRAVEL_DISTANCE_BETWEEN_POINTS(x1, y1, z1, x2, y2, invoke<float);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_PED( int pedType, unsigned modelHash, float x, float y, float z, float heading, bool isNetwork, bool bScriptHostPed) { return invoke<int )
	{
		auto retval = PED::CREATE_PED(pedType, modelHash, x, y, z, heading, isNetwork, invoke<int);
		return retval;
	}

	int ped) { LUA_NATIVE_PED_DELETE_PED( int ped) { invoke<void )
	{
		PED::DELETE_PED(&invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_PED_CLONE_PED( int ped, bool isNetwork, bool bScriptHostPed, bool copyHeadBlendFlag) { return invoke<int )
	{
		auto retval = PED::CLONE_PED(ped, isNetwork, bScriptHostPed, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_CLONE_PED_ALT( int ped, bool isNetwork, bool bScriptHostPed, bool copyHeadBlendFlag, bool p4) { return invoke<int )
	{
		auto retval = PED::CLONE_PED_ALT(ped, isNetwork, bScriptHostPed, copyHeadBlendFlag, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_CLONE_PED_TO_TARGET( int ped, int targetPed) { invoke<void )
	{
		PED::CLONE_PED_TO_TARGET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLONE_PED_TO_TARGET_ALT( int ped, int targetPed, bool p2) { invoke<void )
	{
		PED::CLONE_PED_TO_TARGET_ALT(ped, targetPed, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_IN_VEHICLE( int ped, int vehicle, bool atGetIn) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_VEHICLE(ped, vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_MODEL( int ped, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_MODEL(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_VEHICLE( int ped, bool atGetIn) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_VEHICLE(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_COP_PED_IN_AREA_3D( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_COP_PED_IN_AREA_3D(x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_INJURED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_INJURED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_HURT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HURT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_FATALLY_INJURED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_FATALLY_INJURED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_DEAD_OR_DYING( int ped, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DEAD_OR_DYING(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_CONVERSATION_PED_DEAD( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_CONVERSATION_PED_DEAD(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_AIMING_FROM_COVER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_AIMING_FROM_COVER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_RELOADING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RELOADING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_A_PLAYER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_A_PLAYER(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_PED_INSIDE_VEHICLE( int vehicle, int pedType, unsigned modelHash, int seat, bool isNetwork, bool bScriptHostPed) { return invoke<int )
	{
		auto retval = PED::CREATE_PED_INSIDE_VEHICLE(vehicle, pedType, modelHash, seat, isNetwork, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_DESIRED_HEADING( int ped, float heading) { invoke<void )
	{
		PED::SET_PED_DESIRED_HEADING(ped, invoke<void);
	}

	void LUA_NATIVE_PED_FORCE_ALL_HEADING_VALUES_TO_ALIGN( int ped) { invoke<void )
	{
		PED::FORCE_ALL_HEADING_VALUES_TO_ALIGN(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_FACING_PED( int ped, int otherPed, float angle) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_FACING_PED(ped, otherPed, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_MELEE_COMBAT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_MELEE_COMBAT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_STOPPED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_STOPPED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_SHOOTING_IN_AREA( int ped, float x1, float y1, float z1, float x2, float y2, float z2, bool p7, bool p8) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SHOOTING_IN_AREA(ped, x1, y1, z1, x2, y2, z2, p7, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_ANY_PED_SHOOTING_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool p6, bool p7) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_ANY_PED_SHOOTING_IN_AREA(x1, y1, z1, x2, y2, z2, p6, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_SHOOTING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SHOOTING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ACCURACY( int ped, int accuracy) { invoke<void )
	{
		PED::SET_PED_ACCURACY(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_ACCURACY( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_ACCURACY(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_AMBIENT_LAW_PED_ACCURACY_MODIFIER( float multiplier) { invoke<void )
	{
		PED::SET_AMBIENT_LAW_PED_ACCURACY_MODIFIER(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_MODEL( int ped, unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_MODEL(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_EXPLODE_PED_HEAD( int ped, unsigned weaponHash) { invoke<void )
	{
		PED::EXPLODE_PED_HEAD(ped, invoke<void);
	}

	int ped) { LUA_NATIVE_PED_REMOVE_PED_ELEGANTLY( int ped) { invoke<void )
	{
		PED::REMOVE_PED_ELEGANTLY(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PED_ADD_ARMOUR_TO_PED( int ped, int amount) { invoke<void )
	{
		PED::ADD_ARMOUR_TO_PED(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ARMOUR( int ped, int amount) { invoke<void )
	{
		PED::SET_PED_ARMOUR(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_INTO_VEHICLE( int ped, int vehicle, int seatIndex) { invoke<void )
	{
		PED::SET_PED_INTO_VEHICLE(ped, vehicle, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ALLOW_VEHICLES_OVERRIDE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_ALLOW_VEHICLES_OVERRIDE(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_CAN_CREATE_RANDOM_PED( bool p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::CAN_CREATE_RANDOM_PED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_RANDOM_PED( float posX, float posY, float posZ) { return invoke<int )
	{
		auto retval = PED::CREATE_RANDOM_PED(posX, posY, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_RANDOM_PED_AS_DRIVER( int vehicle, bool returnHandle) { return invoke<int )
	{
		auto retval = PED::CREATE_RANDOM_PED_AS_DRIVER(vehicle, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_CAN_CREATE_RANDOM_DRIVER(  )
	{
		auto retval = (bool)PED::CAN_CREATE_RANDOM_DRIVER();
		return retval;
	}

	bool LUA_NATIVE_PED_CAN_CREATE_RANDOM_BIKE_RIDER(  )
	{
		auto retval = (bool)PED::CAN_CREATE_RANDOM_BIKE_RIDER();
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_MOVE_ANIMS_BLEND_OUT( int ped) { invoke<void )
	{
		PED::SET_PED_MOVE_ANIMS_BLEND_OUT(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_DRAGGED_OUT( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_DRAGGED_OUT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ALLOW_HURT_COMBAT_FOR_ALL_MISSION_PEDS( bool toggle) { invoke<void )
	{
		PED::SET_PED_ALLOW_HURT_COMBAT_FOR_ALL_MISSION_PEDS(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_MALE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_MALE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_HUMAN( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HUMAN(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_VEHICLE_PED_IS_IN( int ped, bool includeEntering) { return invoke<int )
	{
		auto retval = PED::GET_VEHICLE_PED_IS_IN(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_RESET_PED_LAST_VEHICLE( int ped) { invoke<void )
	{
		PED::RESET_PED_LAST_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DENSITY_MULTIPLIER_THIS_FRAME( float multiplier) { invoke<void )
	{
		PED::SET_PED_DENSITY_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PED_SET_SCENARIO_PED_DENSITY_MULTIPLIER_THIS_FRAME( float p0, float p1) { invoke<void )
	{
		PED::SET_SCENARIO_PED_DENSITY_MULTIPLIER_THIS_FRAME(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SUPPRESS_AMBIENT_PED_AGGRESSIVE_CLEANUP_THIS_FRAME(  )
	{
		PED::SUPPRESS_AMBIENT_PED_AGGRESSIVE_CLEANUP_THIS_FRAME();
	}

	void LUA_NATIVE_PED_SET_SCRIPTED_CONVERSION_COORD_THIS_FRAME( float x, float y, float z) { invoke<void )
	{
		PED::SET_SCRIPTED_CONVERSION_COORD_THIS_FRAME(x, y, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_NON_CREATION_AREA( float x1, float y1, float z1, float x2, float y2, float z2) { invoke<void )
	{
		PED::SET_PED_NON_CREATION_AREA(x1, y1, z1, x2, y2, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_NON_CREATION_AREA(  )
	{
		PED::CLEAR_PED_NON_CREATION_AREA();
	}

	void LUA_NATIVE_PED_INSTANTLY_FILL_PED_POPULATION(  )
	{
		PED::INSTANTLY_FILL_PED_POPULATION();
	}

	bool LUA_NATIVE_PED_IS_PED_ON_MOUNT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_ON_MOUNT(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_MOUNT( int ped) { return invoke<int )
	{
		auto retval = PED::GET_MOUNT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_ON_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_ON_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_ON_SPECIFIC_VEHICLE( int ped, int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_ON_SPECIFIC_VEHICLE(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_MONEY( int ped, int amount) { invoke<void )
	{
		PED::SET_PED_MONEY(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_MONEY( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_MONEY(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_HEALTH_SNACKS_CARRIED_BY_ALL_NEW_PEDS( float p0, Any p1) { invoke<void )
	{
		PED::SET_HEALTH_SNACKS_CARRIED_BY_ALL_NEW_PEDS(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_AMBIENT_PEDS_DROP_MONEY( bool p0) { invoke<void )
	{
		PED::SET_AMBIENT_PEDS_DROP_MONEY(invoke<void);
	}

	void LUA_NATIVE_PED_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS_FOR_AMBIENT_PEDS_THIS_FRAME( bool p0) { invoke<void )
	{
		PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS_FOR_AMBIENT_PEDS_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SUFFERS_CRITICAL_HITS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_SUFFERS_CRITICAL_HITS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_UPPER_BODY_DAMAGE_ONLY( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_UPPER_BODY_DAMAGE_ONLY(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_SITTING_IN_VEHICLE( int ped, int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SITTING_IN_VEHICLE(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_SITTING_IN_ANY_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SITTING_IN_ANY_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_ON_FOOT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_ON_FOOT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_ON_ANY_BIKE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_ON_ANY_BIKE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_PLANTING_BOMB( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_PLANTING_BOMB(invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_PED_GET_DEAD_PED_PICKUP_COORDS( int ped, float p1, float p2) { return invoke<Vector3 )
	{
		auto retval = PED::GET_DEAD_PED_PICKUP_COORDS(ped, p1, invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_BOAT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_BOAT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_SUB( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_SUB(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_HELI( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_HELI(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_PLANE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_PLANE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_FLYING_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_FLYING_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_DIES_IN_WATER( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DIES_IN_WATER(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_GET_PED_DIES_IN_WATER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_PED_DIES_IN_WATER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_DIES_IN_SINKING_VEHICLE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DIES_IN_SINKING_VEHICLE(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_ARMOUR( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_ARMOUR(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_STAY_IN_VEHICLE_WHEN_JACKED( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_STAY_IN_VEHICLE_WHEN_JACKED(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_SHOT_IN_VEHICLE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_SHOT_IN_VEHICLE(ped, invoke<void);
	}

	std::tuple<bool, int outBone) { return> LUA_NATIVE_PED_GET_PED_LAST_DAMAGE_BONE( int ped, int outBone) { return invoke<BOOL )
	{
		std::tuple<bool, int outBone) { return> return_values;
		std::get<0>(return_values) = (bool)PED::GET_PED_LAST_DAMAGE_BONE(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_CLEAR_PED_LAST_DAMAGE_BONE( int ped) { invoke<void )
	{
		PED::CLEAR_PED_LAST_DAMAGE_BONE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_AI_WEAPON_DAMAGE_MODIFIER( float value) { invoke<void )
	{
		PED::SET_AI_WEAPON_DAMAGE_MODIFIER(invoke<void);
	}

	void LUA_NATIVE_PED_RESET_AI_WEAPON_DAMAGE_MODIFIER(  )
	{
		PED::RESET_AI_WEAPON_DAMAGE_MODIFIER();
	}

	void LUA_NATIVE_PED_SET_AI_MELEE_WEAPON_DAMAGE_MODIFIER( float modifier) { invoke<void )
	{
		PED::SET_AI_MELEE_WEAPON_DAMAGE_MODIFIER(invoke<void);
	}

	void LUA_NATIVE_PED_RESET_AI_MELEE_WEAPON_DAMAGE_MODIFIER(  )
	{
		PED::RESET_AI_MELEE_WEAPON_DAMAGE_MODIFIER();
	}

	void LUA_NATIVE_PED_SET_TREAT_AS_AMBIENT_PED_FOR_DRIVER_LOCKON( int ped, bool p1) { invoke<void )
	{
		PED::SET_TREAT_AS_AMBIENT_PED_FOR_DRIVER_LOCKON(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_TARGETTED( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_TARGETTED(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_TARGETTED_BY_TEAM( int ped, int team, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_TARGETTED_BY_TEAM(ped, team, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_TARGETTED_BY_PLAYER( int ped, int player, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_TARGETTED_BY_PLAYER(ped, player, invoke<void);
	}

	void LUA_NATIVE_PED_SET_ALLOW_LOCKON_TO_PED_IF_FRIENDLY( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ALLOW_LOCKON_TO_PED_IF_FRIENDLY(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_USE_CAMERA_HEADING_FOR_DESIRED_DIRECTION_LOCK_ON_TEST( int ped, bool toggle) { invoke<void )
	{
		PED::SET_USE_CAMERA_HEADING_FOR_DESIRED_DIRECTION_LOCK_ON_TEST(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_POLICE_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_POLICE_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_FORCE_PED_TO_OPEN_PARACHUTE( int ped) { invoke<void )
	{
		PED::FORCE_PED_TO_OPEN_PARACHUTE(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_IN_PARACHUTE_FREE_FALL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_PARACHUTE_FREE_FALL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_FALLING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_FALLING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_JUMPING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_JUMPING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_LANDING( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_LANDING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_DOING_A_BEAST_JUMP( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DOING_A_BEAST_JUMP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_CLIMBING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_CLIMBING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_VAULTING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_VAULTING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_DIVING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DIVING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_JUMPING_OUT_OF_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_JUMPING_OUT_OF_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_OPENING_DOOR( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_OPENING_DOOR(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_PARACHUTE_STATE( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_PARACHUTE_STATE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_PARACHUTE_LANDING_TYPE( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_PARACHUTE_LANDING_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_PARACHUTE_TINT_INDEX( int ped, int tintIndex) { invoke<void )
	{
		PED::SET_PED_PARACHUTE_TINT_INDEX(ped, invoke<void);
	}

	int outTintIndex) { LUA_NATIVE_PED_GET_PED_PARACHUTE_TINT_INDEX( int ped, int outTintIndex) { invoke<void )
	{
		PED::GET_PED_PARACHUTE_TINT_INDEX(ped, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PED_SET_PED_RESERVE_PARACHUTE_TINT_INDEX( int ped, Any p1) { invoke<void )
	{
		PED::SET_PED_RESERVE_PARACHUTE_TINT_INDEX(ped, invoke<void);
	}

	Object LUA_NATIVE_PED_CREATE_PARACHUTE_BAG_OBJECT( int ped, bool p1, bool p2) { return invoke<Object )
	{
		auto retval = PED::CREATE_PARACHUTE_BAG_OBJECT(ped, p1, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_DUCKING( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DUCKING(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_DUCKING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DUCKING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_TAXI( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_TAXI(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ID_RANGE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_ID_RANGE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HIGHLY_PERCEPTIVE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_HIGHLY_PERCEPTIVE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_COP_PERCEPTION_OVERRIDES( float seeingRange, float seeingRangePeripheral, float hearingRange, float visualFieldMinAzimuthAngle, float visualFieldMaxAzimuthAngle, float fieldOfGazeMaxAngle, float p6) { invoke<void )
	{
		PED::SET_COP_PERCEPTION_OVERRIDES(seeingRange, seeingRangePeripheral, hearingRange, visualFieldMinAzimuthAngle, visualFieldMaxAzimuthAngle, fieldOfGazeMaxAngle, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_INJURED_ON_GROUND_BEHAVIOUR( int ped, float p1) { invoke<void )
	{
		PED::SET_PED_INJURED_ON_GROUND_BEHAVIOUR(ped, invoke<void);
	}

	void LUA_NATIVE_PED_DISABLE_PED_INJURED_ON_GROUND_BEHAVIOUR( int ped) { invoke<void )
	{
		PED::DISABLE_PED_INJURED_ON_GROUND_BEHAVIOUR(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SEEING_RANGE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_SEEING_RANGE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HEARING_RANGE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_HEARING_RANGE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_MIN_ANGLE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_MIN_ANGLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_MAX_ANGLE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_MAX_ANGLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_MIN_ELEVATION_ANGLE( int ped, float angle) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_MIN_ELEVATION_ANGLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_MAX_ELEVATION_ANGLE( int ped, float angle) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_MAX_ELEVATION_ANGLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_PERIPHERAL_RANGE( int ped, float range) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_PERIPHERAL_RANGE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VISUAL_FIELD_CENTER_ANGLE( int ped, float angle) { invoke<void )
	{
		PED::SET_PED_VISUAL_FIELD_CENTER_ANGLE(ped, invoke<void);
	}

	float LUA_NATIVE_PED_GET_PED_VISUAL_FIELD_CENTER_ANGLE( int ped) { return invoke<float )
	{
		auto retval = PED::GET_PED_VISUAL_FIELD_CENTER_ANGLE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_STEALTH_MOVEMENT( int ped, bool p1, const char* action) { invoke<void )
	{
		PED::SET_PED_STEALTH_MOVEMENT(ped, p1, invoke<void);
	}

	bool LUA_NATIVE_PED_GET_PED_STEALTH_MOVEMENT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_PED_STEALTH_MOVEMENT(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_GROUP( int unused) { return invoke<int )
	{
		auto retval = PED::CREATE_GROUP(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_AS_GROUP_LEADER( int ped, int groupId) { invoke<void )
	{
		PED::SET_PED_AS_GROUP_LEADER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_AS_GROUP_MEMBER( int ped, int groupId) { invoke<void )
	{
		PED::SET_PED_AS_GROUP_MEMBER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_TELEPORT_TO_GROUP_LEADER( int pedHandle, int groupHandle, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_TELEPORT_TO_GROUP_LEADER(pedHandle, groupHandle, invoke<void);
	}

	void LUA_NATIVE_PED_REMOVE_GROUP( int groupId) { invoke<void )
	{
		PED::REMOVE_GROUP(invoke<void);
	}

	void LUA_NATIVE_PED_REMOVE_PED_FROM_GROUP( int ped) { invoke<void )
	{
		PED::REMOVE_PED_FROM_GROUP(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_GROUP_MEMBER( int ped, int groupId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_GROUP_MEMBER(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_HANGING_ON_TO_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HANGING_ON_TO_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_GROUP_SEPARATION_RANGE( int groupHandle, float separationRange) { invoke<void )
	{
		PED::SET_GROUP_SEPARATION_RANGE(groupHandle, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MIN_GROUND_TIME_FOR_STUNGUN( int ped, int ms) { invoke<void )
	{
		PED::SET_PED_MIN_GROUND_TIME_FOR_STUNGUN(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_PRONE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_PRONE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_COMBAT( int ped, int target) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_COMBAT(ped, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_TARGET_FROM_COMBAT_PED( int ped, Any p1) { return invoke<int )
	{
		auto retval = PED::GET_PED_TARGET_FROM_COMBAT_PED(ped, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_CAN_PED_IN_COMBAT_SEE_TARGET( int ped, int target) { return invoke<BOOL )
	{
		auto retval = (bool)PED::CAN_PED_IN_COMBAT_SEE_TARGET(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_DOING_DRIVEBY( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DOING_DRIVEBY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_JACKING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_JACKING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BEING_JACKED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BEING_JACKED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BEING_STUNNED( int ped, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BEING_STUNNED(ped, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PEDS_JACKER( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PEDS_JACKER(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_JACK_TARGET( int ped) { return invoke<int )
	{
		auto retval = PED::GET_JACK_TARGET(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_FLEEING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_FLEEING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_COVER( int ped, bool exceptUseWeapon) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_COVER(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_COVER_FACING_LEFT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_COVER_FACING_LEFT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_HIGH_COVER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_HIGH_COVER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_GOING_INTO_COVER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_GOING_INTO_COVER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_SET_PED_PINNED_DOWN( int ped, bool pinned, int i) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_PINNED_DOWN(ped, pinned, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_SEAT_PED_IS_TRYING_TO_ENTER( int ped) { return invoke<int )
	{
		auto retval = PED::GET_SEAT_PED_IS_TRYING_TO_ENTER(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_VEHICLE_PED_IS_TRYING_TO_ENTER( int ped) { return invoke<int )
	{
		auto retval = PED::GET_VEHICLE_PED_IS_TRYING_TO_ENTER(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_SOURCE_OF_DEATH( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_SOURCE_OF_DEATH(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_PED_GET_PED_CAUSE_OF_DEATH( int ped) { return invoke<unsigned )
	{
		auto retval = PED::GET_PED_CAUSE_OF_DEATH(invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_TIME_OF_DEATH( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_TIME_OF_DEATH(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_COUNT_PEDS_IN_COMBAT_WITH_TARGET( int ped) { return invoke<int )
	{
		auto retval = PED::COUNT_PEDS_IN_COMBAT_WITH_TARGET(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_COUNT_PEDS_IN_COMBAT_WITH_TARGET_WITHIN_RADIUS( int ped, float x, float y, float z, float radius) { return invoke<int )
	{
		auto retval = PED::COUNT_PEDS_IN_COMBAT_WITH_TARGET_WITHIN_RADIUS(ped, x, y, z, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_RELATIONSHIP_GROUP_DEFAULT_HASH( int ped, unsigned hash) { invoke<void )
	{
		PED::SET_PED_RELATIONSHIP_GROUP_DEFAULT_HASH(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_RELATIONSHIP_GROUP_HASH( int ped, unsigned hash) { invoke<void )
	{
		PED::SET_PED_RELATIONSHIP_GROUP_HASH(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_RELATIONSHIP_BETWEEN_GROUPS( int relationship, unsigned group1, unsigned group2) { invoke<void )
	{
		PED::SET_RELATIONSHIP_BETWEEN_GROUPS(relationship, group1, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_RELATIONSHIP_BETWEEN_GROUPS( int relationship, unsigned group1, unsigned group2) { invoke<void )
	{
		PED::CLEAR_RELATIONSHIP_BETWEEN_GROUPS(relationship, group1, invoke<void);
	}

	std::tuple<bool, unsigned groupHash) { return> LUA_NATIVE_PED_ADD_RELATIONSHIP_GROUP( const char* name, unsigned groupHash) { return invoke<BOOL )
	{
		std::tuple<bool, unsigned groupHash) { return> return_values;
		std::get<0>(return_values) = (bool)PED::ADD_RELATIONSHIP_GROUP(name, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_REMOVE_RELATIONSHIP_GROUP( unsigned groupHash) { invoke<void )
	{
		PED::REMOVE_RELATIONSHIP_GROUP(invoke<void);
	}

	bool LUA_NATIVE_PED_DOES_RELATIONSHIP_GROUP_EXIST( unsigned groupHash) { return invoke<BOOL )
	{
		auto retval = (bool)PED::DOES_RELATIONSHIP_GROUP_EXIST(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_RELATIONSHIP_BETWEEN_PEDS( int ped1, int ped2) { return invoke<int )
	{
		auto retval = PED::GET_RELATIONSHIP_BETWEEN_PEDS(ped1, invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_PED_GET_PED_RELATIONSHIP_GROUP_DEFAULT_HASH( int ped) { return invoke<unsigned )
	{
		auto retval = PED::GET_PED_RELATIONSHIP_GROUP_DEFAULT_HASH(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_PED_GET_PED_RELATIONSHIP_GROUP_HASH( int ped) { return invoke<unsigned )
	{
		auto retval = PED::GET_PED_RELATIONSHIP_GROUP_HASH(invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_PED_GET_RELATIONSHIP_BETWEEN_GROUPS( unsigned group1, unsigned group2) { return invoke<int )
	{
		auto retval = PED::GET_RELATIONSHIP_BETWEEN_GROUPS(group1, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_RELATIONSHIP_GROUP_AFFECTS_WANTED_LEVEL( unsigned group, bool p1) { invoke<void )
	{
		PED::SET_RELATIONSHIP_GROUP_AFFECTS_WANTED_LEVEL(group, invoke<void);
	}

	void LUA_NATIVE_PED_TELL_GROUP_PEDS_IN_AREA_TO_ATTACK( int ped, Any p1, float p2, unsigned hash, Any p4, Any p5) { invoke<void )
	{
		PED::TELL_GROUP_PEDS_IN_AREA_TO_ATTACK(ped, p1, p2, hash, p4, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_TARGETED_WITHOUT_LOS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_TARGETED_WITHOUT_LOS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_TO_INFORM_RESPECTED_FRIENDS( int ped, float radius, int maxFriends) { invoke<void )
	{
		PED::SET_PED_TO_INFORM_RESPECTED_FRIENDS(ped, radius, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_RESPONDING_TO_EVENT( int ped, Any event) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RESPONDING_TO_EVENT(ped, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_PED_GET_POS_FROM_FIRED_EVENT( int ped, int eventType, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)PED::GET_POS_FROM_FIRED_EVENT(ped, eventType, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_SET_PED_FIRING_PATTERN( int ped, unsigned patternHash) { invoke<void )
	{
		PED::SET_PED_FIRING_PATTERN(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SHOOT_RATE( int ped, int shootRate) { invoke<void )
	{
		PED::SET_PED_SHOOT_RATE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_COMBAT_FLOAT( int ped, int combatType, float p2) { invoke<void )
	{
		PED::SET_COMBAT_FLOAT(ped, combatType, invoke<void);
	}

	float LUA_NATIVE_PED_GET_COMBAT_FLOAT( int ped, int p1) { return invoke<float )
	{
		auto retval = PED::GET_COMBAT_FLOAT(ped, invoke<float);
		return retval;
	}

	std::tuple<Any, int sizeInMembers) {> LUA_NATIVE_PED_GET_GROUP_SIZE( int groupID, Any p1, int sizeInMembers) { invoke<void )
	{
		std::tuple<Any, int sizeInMembers) {> return_values;
		PED::GET_GROUP_SIZE(groupID, &p1, &invoke<void);
		std::get<0>(return_values) = p1;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	bool LUA_NATIVE_PED_DOES_GROUP_EXIST( int groupId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::DOES_GROUP_EXIST(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_GROUP_INDEX( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_GROUP_INDEX(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_IN_GROUP( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_GROUP(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PLAYER_PED_IS_FOLLOWING( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PLAYER_PED_IS_FOLLOWING(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_GROUP_FORMATION( int groupId, int formationType) { invoke<void )
	{
		PED::SET_GROUP_FORMATION(groupId, invoke<void);
	}

	void LUA_NATIVE_PED_SET_GROUP_FORMATION_SPACING( int groupId, float x, float y, float z) { invoke<void )
	{
		PED::SET_GROUP_FORMATION_SPACING(groupId, x, y, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_GROUP_FORMATION_DEFAULT_SPACING( int groupHandle) { invoke<void )
	{
		PED::RESET_GROUP_FORMATION_DEFAULT_SPACING(invoke<void);
	}

	int LUA_NATIVE_PED_GET_VEHICLE_PED_IS_USING( int ped) { return invoke<int )
	{
		auto retval = PED::GET_VEHICLE_PED_IS_USING(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_VEHICLE_PED_IS_ENTERING( int ped) { return invoke<int )
	{
		auto retval = PED::GET_VEHICLE_PED_IS_ENTERING(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_GRAVITY( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_GRAVITY(ped, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_DAMAGE_TO_PED( int ped, int damageAmount, bool p2, Any p3) { invoke<void )
	{
		PED::APPLY_DAMAGE_TO_PED(ped, damageAmount, p2, invoke<void);
	}

	int LUA_NATIVE_PED_GET_TIME_PED_DAMAGED_BY_WEAPON( int ped, unsigned weaponHash) { return invoke<int )
	{
		auto retval = PED::GET_TIME_PED_DAMAGED_BY_WEAPON(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ALLOWED_TO_DUCK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_ALLOWED_TO_DUCK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_NEVER_LEAVES_GROUP( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_NEVER_LEAVES_GROUP(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_TYPE( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_AS_COP( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_AS_COP(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HEALTH_PENDING_LAST_DAMAGE_EVENT_OVERRIDE_FLAG( bool toggle) { invoke<void )
	{
		PED::SET_PED_HEALTH_PENDING_LAST_DAMAGE_EVENT_OVERRIDE_FLAG(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MAX_HEALTH( int ped, int value) { invoke<void )
	{
		PED::SET_PED_MAX_HEALTH(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_MAX_HEALTH( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_MAX_HEALTH(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_MAX_TIME_IN_WATER( int ped, float value) { invoke<void )
	{
		PED::SET_PED_MAX_TIME_IN_WATER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MAX_TIME_UNDERWATER( int ped, float value) { invoke<void )
	{
		PED::SET_PED_MAX_TIME_UNDERWATER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_CORPSE_RAGDOLL_FRICTION( int ped, float p1) { invoke<void )
	{
		PED::SET_CORPSE_RAGDOLL_FRICTION(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_VEHICLE_FORCED_SEAT_USAGE( int ped, int vehicle, int seatIndex, int flags, Any p4) { invoke<void )
	{
		PED::SET_PED_VEHICLE_FORCED_SEAT_USAGE(ped, vehicle, seatIndex, flags, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_ALL_PED_VEHICLE_FORCED_SEAT_USAGE( int ped) { invoke<void )
	{
		PED::CLEAR_ALL_PED_VEHICLE_FORCED_SEAT_USAGE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_KNOCKED_OFF_BIKE( Any p0, Any p1) { invoke<void )
	{
		PED::SET_PED_CAN_BE_KNOCKED_OFF_BIKE(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_KNOCKED_OFF_VEHICLE( int ped, int state) { invoke<void )
	{
		PED::SET_PED_CAN_BE_KNOCKED_OFF_VEHICLE(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_CAN_KNOCK_PED_OFF_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::CAN_KNOCK_PED_OFF_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_KNOCK_PED_OFF_VEHICLE( int ped) { invoke<void )
	{
		PED::KNOCK_PED_OFF_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_COORDS_NO_GANG( int ped, float posX, float posY, float posZ) { invoke<void )
	{
		PED::SET_PED_COORDS_NO_GANG(ped, posX, posY, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_AS_GROUP_MEMBER( int groupID, int memberNumber) { return invoke<int )
	{
		auto retval = PED::GET_PED_AS_GROUP_MEMBER(groupID, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_AS_GROUP_LEADER( int groupID) { return invoke<int )
	{
		auto retval = PED::GET_PED_AS_GROUP_LEADER(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_KEEP_TASK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_KEEP_TASK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ALLOW_MINOR_REACTIONS_AS_MISSION_PED( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_ALLOW_MINOR_REACTIONS_AS_MISSION_PED(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_SWIMMING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SWIMMING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_SWIMMING_UNDER_WATER( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SWIMMING_UNDER_WATER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_COORDS_KEEP_VEHICLE( int ped, float posX, float posY, float posZ) { invoke<void )
	{
		PED::SET_PED_COORDS_KEEP_VEHICLE(ped, posX, posY, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DIES_IN_VEHICLE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DIES_IN_VEHICLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_CREATE_RANDOM_COPS( bool toggle) { invoke<void )
	{
		PED::SET_CREATE_RANDOM_COPS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_CREATE_RANDOM_COPS_NOT_ON_SCENARIOS( bool toggle) { invoke<void )
	{
		PED::SET_CREATE_RANDOM_COPS_NOT_ON_SCENARIOS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_CREATE_RANDOM_COPS_ON_SCENARIOS( bool toggle) { invoke<void )
	{
		PED::SET_CREATE_RANDOM_COPS_ON_SCENARIOS(invoke<void);
	}

	bool LUA_NATIVE_PED_CAN_CREATE_RANDOM_COPS(  )
	{
		auto retval = (bool)PED::CAN_CREATE_RANDOM_COPS();
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_AS_ENEMY( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_AS_ENEMY(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_SMASH_GLASS( int ped, bool p1, bool p2) { invoke<void )
	{
		PED::SET_PED_CAN_SMASH_GLASS(ped, p1, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_IN_ANY_TRAIN( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_IN_ANY_TRAIN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_GETTING_INTO_A_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_GETTING_INTO_A_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_TRYING_TO_ENTER_A_LOCKED_VEHICLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_TRYING_TO_ENTER_A_LOCKED_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_ENABLE_HANDCUFFS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ENABLE_HANDCUFFS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_ENABLE_BOUND_ANKLES( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ENABLE_BOUND_ANKLES(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_ENABLE_SCUBA( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ENABLE_SCUBA(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_CAN_ATTACK_FRIENDLY( int ped, bool toggle, bool p2) { invoke<void )
	{
		PED::SET_CAN_ATTACK_FRIENDLY(ped, toggle, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_ALERTNESS( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_ALERTNESS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ALERTNESS( int ped, int value) { invoke<void )
	{
		PED::SET_PED_ALERTNESS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_GET_OUT_UPSIDE_DOWN_VEHICLE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_GET_OUT_UPSIDE_DOWN_VEHICLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MOVEMENT_CLIPSET( int ped, const char* clipSet, float transitionSpeed) { invoke<void )
	{
		PED::SET_PED_MOVEMENT_CLIPSET(ped, clipSet, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_MOVEMENT_CLIPSET( int ped, float p1) { invoke<void )
	{
		PED::RESET_PED_MOVEMENT_CLIPSET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STRAFE_CLIPSET( int ped, const char* clipSet) { invoke<void )
	{
		PED::SET_PED_STRAFE_CLIPSET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_STRAFE_CLIPSET( int ped) { invoke<void )
	{
		PED::RESET_PED_STRAFE_CLIPSET(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_WEAPON_MOVEMENT_CLIPSET( int ped, const char* clipSet) { invoke<void )
	{
		PED::SET_PED_WEAPON_MOVEMENT_CLIPSET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_WEAPON_MOVEMENT_CLIPSET( int ped) { invoke<void )
	{
		PED::RESET_PED_WEAPON_MOVEMENT_CLIPSET(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DRIVE_BY_CLIPSET_OVERRIDE( int ped, const char* clipset) { invoke<void )
	{
		PED::SET_PED_DRIVE_BY_CLIPSET_OVERRIDE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_DRIVE_BY_CLIPSET_OVERRIDE( int ped) { invoke<void )
	{
		PED::CLEAR_PED_DRIVE_BY_CLIPSET_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MOTION_IN_COVER_CLIPSET_OVERRIDE( int ped, const char* p1) { invoke<void )
	{
		PED::SET_PED_MOTION_IN_COVER_CLIPSET_OVERRIDE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_MOTION_IN_COVER_CLIPSET_OVERRIDE( int ped) { invoke<void )
	{
		PED::CLEAR_PED_MOTION_IN_COVER_CLIPSET_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_FALL_UPPER_BODY_CLIPSET_OVERRIDE( int ped) { invoke<void )
	{
		PED::CLEAR_PED_FALL_UPPER_BODY_CLIPSET_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_IN_VEHICLE_CONTEXT( int ped, unsigned context) { invoke<void )
	{
		PED::SET_PED_IN_VEHICLE_CONTEXT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_IN_VEHICLE_CONTEXT( int ped) { invoke<void )
	{
		PED::RESET_PED_IN_VEHICLE_CONTEXT(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_SCRIPTED_SCENARIO_PED_USING_CONDITIONAL_ANIM( int ped, const char* animDict, const char* anim) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_SCRIPTED_SCENARIO_PED_USING_CONDITIONAL_ANIM(ped, animDict, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ALTERNATE_WALK_ANIM( int ped, const char* animDict, const char* animName, float p3, bool p4) { invoke<void )
	{
		PED::SET_PED_ALTERNATE_WALK_ANIM(ped, animDict, animName, p3, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_ALTERNATE_WALK_ANIM( int ped, float p1) { invoke<void )
	{
		PED::CLEAR_PED_ALTERNATE_WALK_ANIM(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ALTERNATE_MOVEMENT_ANIM( int ped, int stance, const char* animDictionary, const char* animationName, float p4, bool p5) { invoke<void )
	{
		PED::SET_PED_ALTERNATE_MOVEMENT_ANIM(ped, stance, animDictionary, animationName, p4, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_ALTERNATE_MOVEMENT_ANIM( int ped, int stance, float p2) { invoke<void )
	{
		PED::CLEAR_PED_ALTERNATE_MOVEMENT_ANIM(ped, stance, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_GESTURE_GROUP( int ped, const char* animGroupGesture) { invoke<void )
	{
		PED::SET_PED_GESTURE_GROUP(ped, invoke<void);
	}

	Vector3 LUA_NATIVE_PED_GET_ANIM_INITIAL_OFFSET_POSITION( const char* animDict, const char* animName, float x, float y, float z, float xRot, float yRot, float zRot, float p8, int p9) { return invoke<Vector3 )
	{
		auto retval = PED::GET_ANIM_INITIAL_OFFSET_POSITION(animDict, animName, x, y, z, xRot, yRot, zRot, p8, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_PED_GET_ANIM_INITIAL_OFFSET_ROTATION( const char* animDict, const char* animName, float x, float y, float z, float xRot, float yRot, float zRot, float p8, int p9) { return invoke<Vector3 )
	{
		auto retval = PED::GET_ANIM_INITIAL_OFFSET_ROTATION(animDict, animName, x, y, z, xRot, yRot, zRot, p8, invoke<Vector3);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_DRAWABLE_VARIATION( int ped, int componentId) { return invoke<int )
	{
		auto retval = PED::GET_PED_DRAWABLE_VARIATION(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_NUMBER_OF_PED_DRAWABLE_VARIATIONS( int ped, int componentId) { return invoke<int )
	{
		auto retval = PED::GET_NUMBER_OF_PED_DRAWABLE_VARIATIONS(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_TEXTURE_VARIATION( int ped, int componentId) { return invoke<int )
	{
		auto retval = PED::GET_PED_TEXTURE_VARIATION(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_NUMBER_OF_PED_TEXTURE_VARIATIONS( int ped, int componentId, int drawableId) { return invoke<int )
	{
		auto retval = PED::GET_NUMBER_OF_PED_TEXTURE_VARIATIONS(ped, componentId, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_NUMBER_OF_PED_PROP_DRAWABLE_VARIATIONS( int ped, int propId) { return invoke<int )
	{
		auto retval = PED::GET_NUMBER_OF_PED_PROP_DRAWABLE_VARIATIONS(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS( int ped, int propId, int drawableId) { return invoke<int )
	{
		auto retval = PED::GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS(ped, propId, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_PALETTE_VARIATION( int ped, int componentId) { return invoke<int )
	{
		auto retval = PED::GET_PED_PALETTE_VARIATION(ped, invoke<int);
		return retval;
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_PED_GET_MP_OUTFIT_DATA_FROM_METADATA( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)PED::GET_MP_OUTFIT_DATA_FROM_METADATA(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_PED_GET_FM_MALE_SHOP_PED_APPAREL_ITEM_INDEX( int p0) { return invoke<int )
	{
		auto retval = PED::GET_FM_MALE_SHOP_PED_APPAREL_ITEM_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_FM_FEMALE_SHOP_PED_APPAREL_ITEM_INDEX( int p0) { return invoke<int )
	{
		auto retval = PED::GET_FM_FEMALE_SHOP_PED_APPAREL_ITEM_INDEX(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_COMPONENT_VARIATION_VALID( int ped, int componentId, int drawableId, int textureId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_COMPONENT_VARIATION_VALID(ped, componentId, drawableId, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_COMPONENT_VARIATION( int ped, int componentId, int drawableId, int textureId, int paletteId) { invoke<void )
	{
		PED::SET_PED_COMPONENT_VARIATION(ped, componentId, drawableId, textureId, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_RANDOM_COMPONENT_VARIATION( int ped, int p1) { invoke<void )
	{
		PED::SET_PED_RANDOM_COMPONENT_VARIATION(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_RANDOM_PROPS( int ped) { invoke<void )
	{
		PED::SET_PED_RANDOM_PROPS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DEFAULT_COMPONENT_VARIATION( int ped) { invoke<void )
	{
		PED::SET_PED_DEFAULT_COMPONENT_VARIATION(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_BLEND_FROM_PARENTS( int ped, Any p1, Any p2, float p3, float p4) { invoke<void )
	{
		PED::SET_PED_BLEND_FROM_PARENTS(ped, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HEAD_BLEND_DATA( int ped, int shapeFirstID, int shapeSecondID, int shapeThirdID, int skinFirstID, int skinSecondID, int skinThirdID, float shapeMix, float skinMix, float thirdMix, bool isParent) { invoke<void )
	{
		PED::SET_PED_HEAD_BLEND_DATA(ped, shapeFirstID, shapeSecondID, shapeThirdID, skinFirstID, skinSecondID, skinThirdID, shapeMix, skinMix, thirdMix, invoke<void);
	}

	std::tuple<bool, Any headBlendData) { return> LUA_NATIVE_PED_GET_PED_HEAD_BLEND_DATA( int ped, Any headBlendData) { return invoke<BOOL )
	{
		std::tuple<bool, Any headBlendData) { return> return_values;
		std::get<0>(return_values) = (bool)PED::GET_PED_HEAD_BLEND_DATA(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_UPDATE_PED_HEAD_BLEND_DATA( int ped, float shapeMix, float skinMix, float thirdMix) { invoke<void )
	{
		PED::UPDATE_PED_HEAD_BLEND_DATA(ped, shapeMix, skinMix, invoke<void);
	}

	void LUA_NATIVE_PED_SET_HEAD_BLEND_EYE_COLOR( int ped, int index) { invoke<void )
	{
		PED::SET_HEAD_BLEND_EYE_COLOR(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_HEAD_BLEND_EYE_COLOR( int ped) { return invoke<int )
	{
		auto retval = PED::GET_HEAD_BLEND_EYE_COLOR(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_HEAD_OVERLAY( int ped, int overlayID, int index, float opacity) { invoke<void )
	{
		PED::SET_PED_HEAD_OVERLAY(ped, overlayID, index, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_HEAD_OVERLAY( int ped, int overlayID) { return invoke<int )
	{
		auto retval = PED::GET_PED_HEAD_OVERLAY(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_HEAD_OVERLAY_NUM( int overlayID) { return invoke<int )
	{
		auto retval = PED::GET_PED_HEAD_OVERLAY_NUM(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_HEAD_OVERLAY_TINT( int ped, int overlayID, int colorType, int colorID, int secondColorID) { invoke<void )
	{
		PED::SET_PED_HEAD_OVERLAY_TINT(ped, overlayID, colorType, colorID, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HAIR_TINT( int ped, int colorID, int highlightColorID) { invoke<void )
	{
		PED::SET_PED_HAIR_TINT(ped, colorID, invoke<void);
	}

	int LUA_NATIVE_PED_GET_NUM_PED_HAIR_TINTS(  )
	{
		auto retval = PED::GET_NUM_PED_HAIR_TINTS();
		return retval;
	}

	int LUA_NATIVE_PED_GET_NUM_PED_MAKEUP_TINTS(  )
	{
		auto retval = PED::GET_NUM_PED_MAKEUP_TINTS();
		return retval;
	}

	std::tuple<int, int, int outB) {> LUA_NATIVE_PED_GET_PED_HAIR_TINT_COLOR( int hairColorIndex, int outR, int outG, int outB) { invoke<void )
	{
		std::tuple<int, int, int outB) {> return_values;
		PED::GET_PED_HAIR_TINT_COLOR(hairColorIndex, &outR, &outG, &invoke<void);
		std::get<0>(return_values) = outR;
		std::get<1>(return_values) = outG;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int, int outB) {> LUA_NATIVE_PED_GET_PED_MAKEUP_TINT_COLOR( int makeupColorIndex, int outR, int outG, int outB) { invoke<void )
	{
		std::tuple<int, int, int outB) {> return_values;
		PED::GET_PED_MAKEUP_TINT_COLOR(makeupColorIndex, &outR, &outG, &invoke<void);
		std::get<0>(return_values) = outR;
		std::get<1>(return_values) = outG;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	bool LUA_NATIVE_PED_IS_PED_HAIR_TINT_FOR_CREATOR( int colorId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HAIR_TINT_FOR_CREATOR(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_DEFAULT_SECONDARY_TINT_FOR_CREATOR( int colorId) { return invoke<int )
	{
		auto retval = PED::GET_DEFAULT_SECONDARY_TINT_FOR_CREATOR(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_LIPSTICK_TINT_FOR_CREATOR( int colorId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_LIPSTICK_TINT_FOR_CREATOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BLUSH_TINT_FOR_CREATOR( int colorId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BLUSH_TINT_FOR_CREATOR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_HAIR_TINT_FOR_BARBER( int colorID) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HAIR_TINT_FOR_BARBER(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_DEFAULT_SECONDARY_TINT_FOR_BARBER( int colorID) { return invoke<int )
	{
		auto retval = PED::GET_DEFAULT_SECONDARY_TINT_FOR_BARBER(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_LIPSTICK_TINT_FOR_BARBER( int colorID) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_LIPSTICK_TINT_FOR_BARBER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BLUSH_TINT_FOR_BARBER( int colorID) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BLUSH_TINT_FOR_BARBER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BLUSH_FACEPAINT_TINT_FOR_BARBER( int colorId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BLUSH_FACEPAINT_TINT_FOR_BARBER(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_TINT_INDEX_FOR_LAST_GEN_HAIR_TEXTURE( unsigned modelHash, int drawableId, int textureId) { return invoke<int )
	{
		auto retval = PED::GET_TINT_INDEX_FOR_LAST_GEN_HAIR_TEXTURE(modelHash, drawableId, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_MICRO_MORPH( int ped, int index, float scale) { invoke<void )
	{
		PED::SET_PED_MICRO_MORPH(ped, index, invoke<void);
	}

	bool LUA_NATIVE_PED_HAS_PED_HEAD_BLEND_FINISHED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_PED_HEAD_BLEND_FINISHED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_FINALIZE_HEAD_BLEND( int ped) { invoke<void )
	{
		PED::FINALIZE_HEAD_BLEND(invoke<void);
	}

	void LUA_NATIVE_PED_SET_HEAD_BLEND_PALETTE_COLOR( int ped, int r, int g, int b, int id) { invoke<void )
	{
		PED::SET_HEAD_BLEND_PALETTE_COLOR(ped, r, g, b, invoke<void);
	}

	void LUA_NATIVE_PED_DISABLE_HEAD_BLEND_PALETTE_COLOR( int ped) { invoke<void )
	{
		PED::DISABLE_HEAD_BLEND_PALETTE_COLOR(invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_HEAD_BLEND_FIRST_INDEX( int type) { return invoke<int )
	{
		auto retval = PED::GET_PED_HEAD_BLEND_FIRST_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_HEAD_BLEND_NUM_HEADS( int type) { return invoke<int )
	{
		auto retval = PED::GET_PED_HEAD_BLEND_NUM_HEADS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_SET_PED_PRELOAD_VARIATION_DATA( int ped, int slot, int drawableId, int textureId) { return invoke<int )
	{
		auto retval = PED::SET_PED_PRELOAD_VARIATION_DATA(ped, slot, drawableId, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_HAS_PED_PRELOAD_VARIATION_DATA_FINISHED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_PED_PRELOAD_VARIATION_DATA_FINISHED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_RELEASE_PED_PRELOAD_VARIATION_DATA( int ped) { invoke<void )
	{
		PED::RELEASE_PED_PRELOAD_VARIATION_DATA(invoke<void);
	}

	int LUA_NATIVE_PED_SET_PED_PRELOAD_PROP_DATA( int ped, int componentId, int drawableId, int TextureId) { return invoke<int )
	{
		auto retval = PED::SET_PED_PRELOAD_PROP_DATA(ped, componentId, drawableId, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_HAS_PED_PRELOAD_PROP_DATA_FINISHED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_PED_PRELOAD_PROP_DATA_FINISHED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_RELEASE_PED_PRELOAD_PROP_DATA( int ped) { invoke<void )
	{
		PED::RELEASE_PED_PRELOAD_PROP_DATA(invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_PROP_INDEX( int ped, int componentId, Any p2) { return invoke<int )
	{
		auto retval = PED::GET_PED_PROP_INDEX(ped, componentId, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_PROP_INDEX( int ped, int componentId, int drawableId, int TextureId, bool attach, Any p5) { invoke<void )
	{
		PED::SET_PED_PROP_INDEX(ped, componentId, drawableId, TextureId, attach, invoke<void);
	}

	void LUA_NATIVE_PED_KNOCK_OFF_PED_PROP( int ped, bool p1, bool p2, bool p3, bool p4) { invoke<void )
	{
		PED::KNOCK_OFF_PED_PROP(ped, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_PROP( int ped, int propId, Any p2) { invoke<void )
	{
		PED::CLEAR_PED_PROP(ped, propId, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_ALL_PED_PROPS( int ped, Any p1) { invoke<void )
	{
		PED::CLEAR_ALL_PED_PROPS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_DROP_AMBIENT_PROP( int ped) { invoke<void )
	{
		PED::DROP_AMBIENT_PROP(invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_PROP_TEXTURE_INDEX( int ped, int componentId) { return invoke<int )
	{
		auto retval = PED::GET_PED_PROP_TEXTURE_INDEX(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_CLEAR_PED_PARACHUTE_PACK_VARIATION( int ped) { invoke<void )
	{
		PED::CLEAR_PED_PARACHUTE_PACK_VARIATION(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SCUBA_GEAR_VARIATION( int ped) { invoke<void )
	{
		PED::SET_PED_SCUBA_GEAR_VARIATION(invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_SCUBA_GEAR_VARIATION( int ped) { invoke<void )
	{
		PED::CLEAR_PED_SCUBA_GEAR_VARIATION(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_USING_PED_SCUBA_GEAR_VARIATION( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_USING_PED_SCUBA_GEAR_VARIATION(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_BOUNDS_ORIENTATION( int ped, float p1, float p2, float x, float y, float z) { invoke<void )
	{
		PED::SET_PED_BOUNDS_ORIENTATION(ped, p1, p2, x, y, invoke<void);
	}

	void LUA_NATIVE_PED_REGISTER_TARGET( int ped, int target) { invoke<void )
	{
		PED::REGISTER_TARGET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_REGISTER_HATED_TARGETS_AROUND_PED( int ped, float radius) { invoke<void )
	{
		PED::REGISTER_HATED_TARGETS_AROUND_PED(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_RANDOM_PED_AT_COORD( float x, float y, float z, float xRadius, float yRadius, float zRadius, int pedType) { return invoke<int )
	{
		auto retval = PED::GET_RANDOM_PED_AT_COORD(x, y, z, xRadius, yRadius, zRadius, invoke<int);
		return retval;
	}

	std::tuple<bool, int> LUA_NATIVE_PED_GET_CLOSEST_PED( float x, float y, float z, float radius, bool p4, bool p5, int outPed, bool p7, bool p8, int pedType) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)PED::GET_CLOSEST_PED(x, y, z, radius, p4, p5, &outPed, p7, p8, invoke<BOOL);
		std::get<1>(return_values) = outPed;

		return return_values;
	}

	void LUA_NATIVE_PED_SET_SCENARIO_PEDS_TO_BE_RETURNED_BY_NEXT_COMMAND( bool value) { invoke<void )
	{
		PED::SET_SCENARIO_PEDS_TO_BE_RETURNED_BY_NEXT_COMMAND(invoke<void);
	}

	bool LUA_NATIVE_PED_GET_CAN_PED_BE_GRABBED_BY_SCRIPT( int ped, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, Any p8) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_CAN_PED_BE_GRABBED_BY_SCRIPT(ped, p1, p2, p3, p4, p5, p6, p7, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_DRIVER_RACING_MODIFIER( int driver, float modifier) { invoke<void )
	{
		PED::SET_DRIVER_RACING_MODIFIER(driver, invoke<void);
	}

	void LUA_NATIVE_PED_SET_DRIVER_ABILITY( int driver, float ability) { invoke<void )
	{
		PED::SET_DRIVER_ABILITY(driver, invoke<void);
	}

	void LUA_NATIVE_PED_SET_DRIVER_AGGRESSIVENESS( int driver, float aggressiveness) { invoke<void )
	{
		PED::SET_DRIVER_AGGRESSIVENESS(driver, invoke<void);
	}

	bool LUA_NATIVE_PED_CAN_PED_RAGDOLL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::CAN_PED_RAGDOLL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_SET_PED_TO_RAGDOLL( int ped, int time1, int time2, int ragdollType, bool p4, bool p5, bool p6) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_TO_RAGDOLL(ped, time1, time2, ragdollType, p4, p5, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_SET_PED_TO_RAGDOLL_WITH_FALL( int ped, int time, int p2, int ragdollType, float x, float y, float z, float velocity, float p8, float p9, float p10, float p11, float p12, float p13) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_TO_RAGDOLL_WITH_FALL(ped, time, p2, ragdollType, x, y, z, velocity, p8, p9, p10, p11, p12, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_RAGDOLL_ON_COLLISION( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_RAGDOLL_ON_COLLISION(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_RAGDOLL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RAGDOLL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_RUNNING_RAGDOLL_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RUNNING_RAGDOLL_TASK(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_RAGDOLL_FORCE_FALL( int ped) { invoke<void )
	{
		PED::SET_PED_RAGDOLL_FORCE_FALL(invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_RAGDOLL_TIMER( int ped) { invoke<void )
	{
		PED::RESET_PED_RAGDOLL_TIMER(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_RAGDOLL( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_RAGDOLL(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_RUNNING_MELEE_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RUNNING_MELEE_TASK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_RUNNING_MOBILE_PHONE_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_RUNNING_MOBILE_PHONE_TASK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_MOBILE_PHONE_TO_PED_EAR( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_MOBILE_PHONE_TO_PED_EAR(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_RAGDOLL_BLOCKING_FLAGS( int ped, int blockingFlag) { invoke<void )
	{
		PED::SET_RAGDOLL_BLOCKING_FLAGS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_RAGDOLL_BLOCKING_FLAGS( int ped, int blockingFlag) { invoke<void )
	{
		PED::CLEAR_RAGDOLL_BLOCKING_FLAGS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ANGLED_DEFENSIVE_AREA( int ped, float p1, float p2, float p3, float p4, float p5, float p6, float p7, bool p8, bool p9) { invoke<void )
	{
		PED::SET_PED_ANGLED_DEFENSIVE_AREA(ped, p1, p2, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SPHERE_DEFENSIVE_AREA( int ped, float x, float y, float z, float radius, bool p5, bool p6) { invoke<void )
	{
		PED::SET_PED_SPHERE_DEFENSIVE_AREA(ped, x, y, z, radius, p5, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DEFENSIVE_SPHERE_ATTACHED_TO_PED( int ped, int target, float xOffset, float yOffset, float zOffset, float radius, bool p6) { invoke<void )
	{
		PED::SET_PED_DEFENSIVE_SPHERE_ATTACHED_TO_PED(ped, target, xOffset, yOffset, zOffset, radius, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DEFENSIVE_SPHERE_ATTACHED_TO_VEHICLE( int ped, int target, float xOffset, float yOffset, float zOffset, float radius, bool p6) { invoke<void )
	{
		PED::SET_PED_DEFENSIVE_SPHERE_ATTACHED_TO_VEHICLE(ped, target, xOffset, yOffset, zOffset, radius, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DEFENSIVE_AREA_ATTACHED_TO_PED( int ped, int attachPed, float p2, float p3, float p4, float p5, float p6, float p7, float p8, bool p9, bool p10) { invoke<void )
	{
		PED::SET_PED_DEFENSIVE_AREA_ATTACHED_TO_PED(ped, attachPed, p2, p3, p4, p5, p6, p7, p8, p9, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DEFENSIVE_AREA_DIRECTION( int ped, float p1, float p2, float p3, bool p4) { invoke<void )
	{
		PED::SET_PED_DEFENSIVE_AREA_DIRECTION(ped, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PED_REMOVE_PED_DEFENSIVE_AREA( int ped, bool toggle) { invoke<void )
	{
		PED::REMOVE_PED_DEFENSIVE_AREA(ped, invoke<void);
	}

	Vector3 LUA_NATIVE_PED_GET_PED_DEFENSIVE_AREA_POSITION( int ped, bool p1) { return invoke<Vector3 )
	{
		auto retval = PED::GET_PED_DEFENSIVE_AREA_POSITION(ped, invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_DEFENSIVE_AREA_ACTIVE( int ped, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_DEFENSIVE_AREA_ACTIVE(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_PREFERRED_COVER_SET( int ped, Any itemSet) { invoke<void )
	{
		PED::SET_PED_PREFERRED_COVER_SET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_REMOVE_PED_PREFERRED_COVER_SET( int ped) { invoke<void )
	{
		PED::REMOVE_PED_PREFERRED_COVER_SET(invoke<void);
	}

	void LUA_NATIVE_PED_REVIVE_INJURED_PED( int ped) { invoke<void )
	{
		PED::REVIVE_INJURED_PED(invoke<void);
	}

	void LUA_NATIVE_PED_RESURRECT_PED( int ped) { invoke<void )
	{
		PED::RESURRECT_PED(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_NAME_DEBUG( int ped, const char* name) { invoke<void )
	{
		PED::SET_PED_NAME_DEBUG(ped, invoke<void);
	}

	Vector3 LUA_NATIVE_PED_GET_PED_EXTRACTED_DISPLACEMENT( int ped, bool worldSpace) { return invoke<Vector3 )
	{
		auto retval = PED::GET_PED_EXTRACTED_DISPLACEMENT(ped, invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_DIES_WHEN_INJURED( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DIES_WHEN_INJURED(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ENABLE_WEAPON_BLOCKING( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_ENABLE_WEAPON_BLOCKING(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SPECIAL_FUNCTION_DO_NOT_USE( int ped, bool p1) { invoke<void )
	{
		PED::SPECIAL_FUNCTION_DO_NOT_USE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_RESET_PED_VISIBLE_DAMAGE( int ped) { invoke<void )
	{
		PED::RESET_PED_VISIBLE_DAMAGE(invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_BLOOD_DAMAGE_BY_ZONE( int ped, Any p1, float p2, float p3, Any p4) { invoke<void )
	{
		PED::APPLY_PED_BLOOD_DAMAGE_BY_ZONE(ped, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_BLOOD( int ped, int boneIndex, float xRot, float yRot, float zRot, const char* woundType) { invoke<void )
	{
		PED::APPLY_PED_BLOOD(ped, boneIndex, xRot, yRot, zRot, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_BLOOD_BY_ZONE( int ped, int p1, float p2, float p3, const char* p4) { invoke<void )
	{
		PED::APPLY_PED_BLOOD_BY_ZONE(ped, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_BLOOD_SPECIFIC( int ped, int p1, float p2, float p3, float p4, float p5, int p6, float p7, const char* p8) { invoke<void )
	{
		PED::APPLY_PED_BLOOD_SPECIFIC(ped, p1, p2, p3, p4, p5, p6, p7, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_DAMAGE_DECAL( int ped, int damageZone, float xOffset, float yOffset, float heading, float scale, float alpha, int variation, bool fadeIn, const char* decalName) { invoke<void )
	{
		PED::APPLY_PED_DAMAGE_DECAL(ped, damageZone, xOffset, yOffset, heading, scale, alpha, variation, fadeIn, invoke<void);
	}

	void LUA_NATIVE_PED_APPLY_PED_DAMAGE_PACK( int ped, const char* damagePack, float damage, float mult) { invoke<void )
	{
		PED::APPLY_PED_DAMAGE_PACK(ped, damagePack, damage, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_BLOOD_DAMAGE( int ped) { invoke<void )
	{
		PED::CLEAR_PED_BLOOD_DAMAGE(invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_BLOOD_DAMAGE_BY_ZONE( int ped, int p1) { invoke<void )
	{
		PED::CLEAR_PED_BLOOD_DAMAGE_BY_ZONE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_HIDE_PED_BLOOD_DAMAGE_BY_ZONE( int ped, Any p1, bool p2) { invoke<void )
	{
		PED::HIDE_PED_BLOOD_DAMAGE_BY_ZONE(ped, p1, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_DAMAGE_DECAL_BY_ZONE( int ped, int p1, const char* p2) { invoke<void )
	{
		PED::CLEAR_PED_DAMAGE_DECAL_BY_ZONE(ped, p1, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_DECORATIONS_STATE( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_DECORATIONS_STATE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_MARK_PED_DECORATIONS_AS_CLONED_FROM_LOCAL_PLAYER( int ped, bool p1) { invoke<void )
	{
		PED::MARK_PED_DECORATIONS_AS_CLONED_FROM_LOCAL_PLAYER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_WETNESS( int ped) { invoke<void )
	{
		PED::CLEAR_PED_WETNESS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_WETNESS_HEIGHT( int ped, float height) { invoke<void )
	{
		PED::SET_PED_WETNESS_HEIGHT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_WETNESS_ENABLED_THIS_FRAME( int ped) { invoke<void )
	{
		PED::SET_PED_WETNESS_ENABLED_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_WETNESS( int ped, float wetLevel) { invoke<void )
	{
		PED::SET_PED_WETNESS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_ENV_DIRT( int ped) { invoke<void )
	{
		PED::CLEAR_PED_ENV_DIRT(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SWEAT( int ped, float sweat) { invoke<void )
	{
		PED::SET_PED_SWEAT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_ADD_PED_DECORATION_FROM_HASHES( int ped, unsigned collection, unsigned overlay) { invoke<void )
	{
		PED::ADD_PED_DECORATION_FROM_HASHES(ped, collection, invoke<void);
	}

	void LUA_NATIVE_PED_ADD_PED_DECORATION_FROM_HASHES_IN_CORONA( int ped, unsigned collection, unsigned overlay) { invoke<void )
	{
		PED::ADD_PED_DECORATION_FROM_HASHES_IN_CORONA(ped, collection, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_DECORATION_ZONE_FROM_HASHES( unsigned collection, unsigned overlay) { return invoke<int )
	{
		auto retval = PED::GET_PED_DECORATION_ZONE_FROM_HASHES(collection, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_CLEAR_PED_DECORATIONS( int ped) { invoke<void )
	{
		PED::CLEAR_PED_DECORATIONS(invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_PED_DECORATIONS_LEAVE_SCARS( int ped) { invoke<void )
	{
		PED::CLEAR_PED_DECORATIONS_LEAVE_SCARS(invoke<void);
	}

	bool LUA_NATIVE_PED_WAS_PED_SKELETON_UPDATED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::WAS_PED_SKELETON_UPDATED(invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_PED_GET_PED_BONE_COORDS( int ped, int boneId, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3 )
	{
		auto retval = PED::GET_PED_BONE_COORDS(ped, boneId, offsetX, offsetY, invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_PED_CREATE_NM_MESSAGE( bool startImmediately, int messageId) { invoke<void )
	{
		PED::CREATE_NM_MESSAGE(startImmediately, invoke<void);
	}

	void LUA_NATIVE_PED_GIVE_PED_NM_MESSAGE( int ped) { invoke<void )
	{
		PED::GIVE_PED_NM_MESSAGE(invoke<void);
	}

	int LUA_NATIVE_PED_ADD_SCENARIO_BLOCKING_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool p6, bool p7, bool p8, bool p9) { return invoke<int )
	{
		auto retval = PED::ADD_SCENARIO_BLOCKING_AREA(x1, y1, z1, x2, y2, z2, p6, p7, p8, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_REMOVE_SCENARIO_BLOCKING_AREAS(  )
	{
		PED::REMOVE_SCENARIO_BLOCKING_AREAS();
	}

	void LUA_NATIVE_PED_REMOVE_SCENARIO_BLOCKING_AREA( Any p0, bool p1) { invoke<void )
	{
		PED::REMOVE_SCENARIO_BLOCKING_AREA(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_SCENARIO_PEDS_SPAWN_IN_SPHERE_AREA( float x, float y, float z, float range, int p4) { invoke<void )
	{
		PED::SET_SCENARIO_PEDS_SPAWN_IN_SPHERE_AREA(x, y, z, range, invoke<void);
	}

	bool LUA_NATIVE_PED_DOES_SCENARIO_BLOCKING_AREA_EXISTS( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)PED::DOES_SCENARIO_BLOCKING_AREA_EXISTS(x1, y1, z1, x2, y2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_USING_SCENARIO( int ped, const char* scenario) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_USING_SCENARIO(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_USING_ANY_SCENARIO( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_USING_ANY_SCENARIO(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_SET_PED_PANIC_EXIT_SCENARIO( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_PANIC_EXIT_SCENARIO(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_TOGGLE_SCENARIO_PED_COWER_IN_PLACE( int ped, bool toggle) { invoke<void )
	{
		PED::TOGGLE_SCENARIO_PED_COWER_IN_PLACE(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_TRIGGER_PED_SCENARIO_PANICEXITTOFLEE( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)PED::TRIGGER_PED_SCENARIO_PANICEXITTOFLEE(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_SET_PED_SHOULD_PLAY_DIRECTED_NORMAL_SCENARIO_EXIT( Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_SHOULD_PLAY_DIRECTED_NORMAL_SCENARIO_EXIT(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_SHOULD_PLAY_NORMAL_SCENARIO_EXIT( int ped) { invoke<void )
	{
		PED::SET_PED_SHOULD_PLAY_NORMAL_SCENARIO_EXIT(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SHOULD_PLAY_IMMEDIATE_SCENARIO_EXIT( int ped) { invoke<void )
	{
		PED::SET_PED_SHOULD_PLAY_IMMEDIATE_SCENARIO_EXIT(invoke<void);
	}

	bool LUA_NATIVE_PED_SET_PED_SHOULD_PLAY_FLEE_SCENARIO_EXIT( int ped, Any p1, Any p2, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)PED::SET_PED_SHOULD_PLAY_FLEE_SCENARIO_EXIT(ped, p1, p2, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_SHOULD_IGNORE_SCENARIO_EXIT_COLLISION_CHECKS( int ped, bool p1) { invoke<void )
	{
		PED::SET_PED_SHOULD_IGNORE_SCENARIO_EXIT_COLLISION_CHECKS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SHOULD_IGNORE_SCENARIO_NAV_CHECKS( Any p0, bool p1) { invoke<void )
	{
		PED::SET_PED_SHOULD_IGNORE_SCENARIO_NAV_CHECKS(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_SHOULD_PROBE_FOR_SCENARIO_EXITS_IN_ONE_FRAME( Any p0, bool p1) { invoke<void )
	{
		PED::SET_PED_SHOULD_PROBE_FOR_SCENARIO_EXITS_IN_ONE_FRAME(p0, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_GESTURING( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_GESTURING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_RESET_FACIAL_IDLE_ANIM( int ped) { invoke<void )
	{
		PED::RESET_FACIAL_IDLE_ANIM(invoke<void);
	}

	void LUA_NATIVE_PED_PLAY_FACIAL_ANIM( int ped, const char* animName, const char* animDict) { invoke<void )
	{
		PED::PLAY_FACIAL_ANIM(ped, animName, invoke<void);
	}

	void LUA_NATIVE_PED_SET_FACIAL_CLIPSET( int ped, const char* animDict) { invoke<void )
	{
		PED::SET_FACIAL_CLIPSET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_FACIAL_IDLE_ANIM_OVERRIDE( int ped, const char* animName, const char* animDict) { invoke<void )
	{
		PED::SET_FACIAL_IDLE_ANIM_OVERRIDE(ped, animName, invoke<void);
	}

	void LUA_NATIVE_PED_CLEAR_FACIAL_IDLE_ANIM_OVERRIDE( int ped) { invoke<void )
	{
		PED::CLEAR_FACIAL_IDLE_ANIM_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PLAY_GESTURE_ANIMS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_PLAY_GESTURE_ANIMS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PLAY_VISEME_ANIMS( int ped, bool toggle, bool p2) { invoke<void )
	{
		PED::SET_PED_CAN_PLAY_VISEME_ANIMS(ped, toggle, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_IS_IGNORED_BY_AUTO_OPEN_DOORS( int ped, bool p1) { invoke<void )
	{
		PED::SET_PED_IS_IGNORED_BY_AUTO_OPEN_DOORS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PLAY_AMBIENT_ANIMS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_PLAY_AMBIENT_ANIMS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PLAY_AMBIENT_BASE_ANIMS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_PLAY_AMBIENT_BASE_ANIMS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_TRIGGER_IDLE_ANIMATION_ON_PED( int ped) { invoke<void )
	{
		PED::TRIGGER_IDLE_ANIMATION_ON_PED(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_ARM_IK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_ARM_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_HEAD_IK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_HEAD_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_LEG_IK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_LEG_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_TORSO_IK( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_TORSO_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_TORSO_REACT_IK( int ped, bool p1) { invoke<void )
	{
		PED::SET_PED_CAN_TORSO_REACT_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_TORSO_VEHICLE_IK( int ped, bool p1) { invoke<void )
	{
		PED::SET_PED_CAN_TORSO_VEHICLE_IK(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_USE_AUTO_CONVERSATION_LOOKAT( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_USE_AUTO_CONVERSATION_LOOKAT(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_HEADTRACKING_PED( int ped1, int ped2) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HEADTRACKING_PED(ped1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_HEADTRACKING_ENTITY( int ped, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HEADTRACKING_ENTITY(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_PRIMARY_LOOKAT( int ped, int lookAt) { invoke<void )
	{
		PED::SET_PED_PRIMARY_LOOKAT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CLOTH_PIN_FRAMES( Any p0, Any p1) { invoke<void )
	{
		PED::SET_PED_CLOTH_PIN_FRAMES(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CLOTH_PACKAGE_INDEX( Any p0, Any p1) { invoke<void )
	{
		PED::SET_PED_CLOTH_PACKAGE_INDEX(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CLOTH_PRONE( Any p0, bool p1) { invoke<void )
	{
		PED::SET_PED_CLOTH_PRONE(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CONFIG_FLAG( int ped, int flagId, bool value) { invoke<void )
	{
		PED::SET_PED_CONFIG_FLAG(ped, flagId, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_RESET_FLAG( int ped, int flagId, bool doReset) { invoke<void )
	{
		PED::SET_PED_RESET_FLAG(ped, flagId, invoke<void);
	}

	bool LUA_NATIVE_PED_GET_PED_CONFIG_FLAG( int ped, int flagId, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_PED_CONFIG_FLAG(ped, flagId, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_GET_PED_RESET_FLAG( int ped, int flagId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_PED_RESET_FLAG(ped, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_GROUP_MEMBER_PASSENGER_INDEX( int ped, int index) { invoke<void )
	{
		PED::SET_PED_GROUP_MEMBER_PASSENGER_INDEX(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_EVASIVE_DIVE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_EVASIVE_DIVE(ped, invoke<void);
	}

	std::tuple<bool, int evadingEntity) { return> LUA_NATIVE_PED_IS_PED_EVASIVE_DIVING( int ped, int evadingEntity) { return invoke<BOOL )
	{
		std::tuple<bool, int evadingEntity) { return> return_values;
		std::get<0>(return_values) = (bool)PED::IS_PED_EVASIVE_DIVING(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_SET_PED_SHOOTS_AT_COORD( int ped, float x, float y, float z, bool toggle) { invoke<void )
	{
		PED::SET_PED_SHOOTS_AT_COORD(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MODEL_IS_SUPPRESSED( unsigned modelHash, bool toggle) { invoke<void )
	{
		PED::SET_PED_MODEL_IS_SUPPRESSED(modelHash, invoke<void);
	}

	void LUA_NATIVE_PED_STOP_ANY_PED_MODEL_BEING_SUPPRESSED(  )
	{
		PED::STOP_ANY_PED_MODEL_BEING_SUPPRESSED();
	}

	void LUA_NATIVE_PED_SET_PED_CAN_BE_TARGETED_WHEN_INJURED( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_BE_TARGETED_WHEN_INJURED(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_GENERATES_DEAD_BODY_EVENTS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_GENERATES_DEAD_BODY_EVENTS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_BLOCK_PED_FROM_GENERATING_DEAD_BODY_EVENTS_WHEN_DEAD( int ped, bool toggle) { invoke<void )
	{
		PED::BLOCK_PED_FROM_GENERATING_DEAD_BODY_EVENTS_WHEN_DEAD(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_WILL_ONLY_ATTACK_WANTED_PLAYER( Any p0, Any p1) { invoke<void )
	{
		PED::SET_PED_WILL_ONLY_ATTACK_WANTED_PLAYER(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_RAGDOLL_FROM_PLAYER_IMPACT( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_RAGDOLL_FROM_PLAYER_IMPACT(ped, invoke<void);
	}

	void LUA_NATIVE_PED_GIVE_PED_HELMET( int ped, bool cannotRemove, int helmetFlag, int textureIndex) { invoke<void )
	{
		PED::GIVE_PED_HELMET(ped, cannotRemove, helmetFlag, invoke<void);
	}

	void LUA_NATIVE_PED_REMOVE_PED_HELMET( int ped, bool instantly) { invoke<void )
	{
		PED::REMOVE_PED_HELMET(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_TAKING_OFF_HELMET( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_TAKING_OFF_HELMET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_HELMET( int ped, bool canWearHelmet) { invoke<void )
	{
		PED::SET_PED_HELMET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HELMET_FLAG( int ped, int helmetFlag) { invoke<void )
	{
		PED::SET_PED_HELMET_FLAG(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HELMET_PROP_INDEX( int ped, int propIndex, bool p2) { invoke<void )
	{
		PED::SET_PED_HELMET_PROP_INDEX(ped, propIndex, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_HELMET_VISOR_PROP_INDICES( int ped, bool p1, int p2, int p3) { invoke<void )
	{
		PED::SET_PED_HELMET_VISOR_PROP_INDICES(ped, p1, p2, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_HELMET_VISOR_UP( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HELMET_VISOR_UP(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_HELMET_TEXTURE_INDEX( int ped, int textureIndex) { invoke<void )
	{
		PED::SET_PED_HELMET_TEXTURE_INDEX(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_WEARING_HELMET( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_WEARING_HELMET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_CLEAR_PED_STORED_HAT_PROP( int ped) { invoke<void )
	{
		PED::CLEAR_PED_STORED_HAT_PROP(invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_HELMET_STORED_HAT_PROP_INDEX( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_HELMET_STORED_HAT_PROP_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_HELMET_STORED_HAT_TEX_INDEX( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_HELMET_STORED_HAT_TEX_INDEX(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_CURRENT_HEAD_PROP_A_HELMET( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_CURRENT_HEAD_PROP_A_HELMET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_TO_LOAD_COVER( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_TO_LOAD_COVER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_COWER_IN_COVER( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_COWER_IN_COVER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PEEK_IN_COVER( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_PEEK_IN_COVER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_PLAYS_HEAD_ON_HORN_ANIM_WHEN_DIES_IN_VEHICLE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_PLAYS_HEAD_ON_HORN_ANIM_WHEN_DIES_IN_VEHICLE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_LEG_IK_MODE( int ped, int mode) { invoke<void )
	{
		PED::SET_PED_LEG_IK_MODE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MOTION_BLUR( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_MOTION_BLUR(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_SWITCH_WEAPON( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_SWITCH_WEAPON(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_DIES_INSTANTLY_IN_WATER( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_DIES_INSTANTLY_IN_WATER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_LADDER_CLIMB_INPUT_STATE( int ped, int p1) { invoke<void )
	{
		PED::SET_LADDER_CLIMB_INPUT_STATE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_STOP_PED_WEAPON_FIRING_WHEN_DROPPED( int ped) { invoke<void )
	{
		PED::STOP_PED_WEAPON_FIRING_WHEN_DROPPED(invoke<void);
	}

	void LUA_NATIVE_PED_SET_SCRIPTED_ANIM_SEAT_OFFSET( int ped, float p1) { invoke<void )
	{
		PED::SET_SCRIPTED_ANIM_SEAT_OFFSET(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_COMBAT_MOVEMENT( int ped, int combatMovement) { invoke<void )
	{
		PED::SET_PED_COMBAT_MOVEMENT(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_COMBAT_MOVEMENT( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_COMBAT_MOVEMENT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_COMBAT_ABILITY( int ped, int abilityLevel) { invoke<void )
	{
		PED::SET_PED_COMBAT_ABILITY(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_COMBAT_RANGE( int ped, int combatRange) { invoke<void )
	{
		PED::SET_PED_COMBAT_RANGE(ped, invoke<void);
	}

	int LUA_NATIVE_PED_GET_PED_COMBAT_RANGE( int ped) { return invoke<int )
	{
		auto retval = PED::GET_PED_COMBAT_RANGE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_COMBAT_ATTRIBUTES( int ped, int attributeId, bool enabled) { invoke<void )
	{
		PED::SET_PED_COMBAT_ATTRIBUTES(ped, attributeId, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_TARGET_LOSS_RESPONSE( int ped, int responseType) { invoke<void )
	{
		PED::SET_PED_TARGET_LOSS_RESPONSE(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_PERFORMING_MELEE_ACTION( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_PERFORMING_MELEE_ACTION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_PERFORMING_STEALTH_KILL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_PERFORMING_STEALTH_KILL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_PERFORMING_A_COUNTER_ATTACK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_PERFORMING_A_COUNTER_ATTACK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_BEING_STEALTH_KILLED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_BEING_STEALTH_KILLED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_MELEE_TARGET_FOR_PED( int ped) { return invoke<int )
	{
		auto retval = PED::GET_MELEE_TARGET_FOR_PED(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_WAS_PED_KILLED_BY_STEALTH( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::WAS_PED_KILLED_BY_STEALTH(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_WAS_PED_KILLED_BY_TAKEDOWN( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::WAS_PED_KILLED_BY_TAKEDOWN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_WAS_PED_KNOCKED_OUT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::WAS_PED_KNOCKED_OUT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_FLEE_ATTRIBUTES( int ped, int attributeFlags, bool enable) { invoke<void )
	{
		PED::SET_PED_FLEE_ATTRIBUTES(ped, attributeFlags, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_COWER_HASH( int ped, const char* p1) { invoke<void )
	{
		PED::SET_PED_COWER_HASH(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STEERS_AROUND_DEAD_BODIES( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_STEERS_AROUND_DEAD_BODIES(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STEERS_AROUND_PEDS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_STEERS_AROUND_PEDS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STEERS_AROUND_OBJECTS( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_STEERS_AROUND_OBJECTS(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STEERS_AROUND_VEHICLES( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_STEERS_AROUND_VEHICLES(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_IS_AVOIDED_BY_OTHERS( Any p0, bool p1) { invoke<void )
	{
		PED::SET_PED_IS_AVOIDED_BY_OTHERS(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_INCREASED_AVOIDANCE_RADIUS( int ped) { invoke<void )
	{
		PED::SET_PED_INCREASED_AVOIDANCE_RADIUS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_BLOCKS_PATHING_WHEN_DEAD( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_BLOCKS_PATHING_WHEN_DEAD(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_NO_TIME_DELAY_BEFORE_SHOT( Any p0) { invoke<void )
	{
		PED::SET_PED_NO_TIME_DELAY_BEFORE_SHOT(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_ANY_PED_NEAR_POINT( float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_ANY_PED_NEAR_POINT(x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_FORCE_PED_AI_AND_ANIMATION_UPDATE( int ped, bool p1, bool p2) { invoke<void )
	{
		PED::FORCE_PED_AI_AND_ANIMATION_UPDATE(ped, p1, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_HEADING_TOWARDS_POSITION( int ped, float x, float y, float z, float p4) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_HEADING_TOWARDS_POSITION(ped, x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_REQUEST_PED_VISIBILITY_TRACKING( int ped) { invoke<void )
	{
		PED::REQUEST_PED_VISIBILITY_TRACKING(invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_PED_VEHICLE_VISIBILITY_TRACKING( int ped, bool p1) { invoke<void )
	{
		PED::REQUEST_PED_VEHICLE_VISIBILITY_TRACKING(ped, invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_PED_RESTRICTED_VEHICLE_VISIBILITY_TRACKING( int ped, bool p1) { invoke<void )
	{
		PED::REQUEST_PED_RESTRICTED_VEHICLE_VISIBILITY_TRACKING(ped, invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_PED_USE_SMALL_BBOX_VISIBILITY_TRACKING( int ped, bool p1) { invoke<void )
	{
		PED::REQUEST_PED_USE_SMALL_BBOX_VISIBILITY_TRACKING(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_TRACKED_PED_VISIBLE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_TRACKED_PED_VISIBLE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_GET_TRACKED_PED_PIXELCOUNT( int ped) { return invoke<int )
	{
		auto retval = PED::GET_TRACKED_PED_PIXELCOUNT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_TRACKED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_TRACKED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_HAS_PED_RECEIVED_EVENT( int ped, int eventId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_PED_RECEIVED_EVENT(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_CAN_PED_SEE_HATED_PED( int ped1, int ped2) { return invoke<BOOL )
	{
		auto retval = (bool)PED::CAN_PED_SEE_HATED_PED(ped1, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int p1) { return> LUA_NATIVE_PED_CAN_PED_SHUFFLE_TO_OR_FROM_TURRET_SEAT( int ped, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, int p1) { return> return_values;
		std::get<0>(return_values) = (bool)PED::CAN_PED_SHUFFLE_TO_OR_FROM_TURRET_SEAT(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int p1) { return> LUA_NATIVE_PED_CAN_PED_SHUFFLE_TO_OR_FROM_EXTRA_SEAT( int ped, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, int p1) { return> return_values;
		std::get<0>(return_values) = (bool)PED::CAN_PED_SHUFFLE_TO_OR_FROM_EXTRA_SEAT(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_PED_GET_PED_BONE_INDEX( int ped, int boneId) { return invoke<int )
	{
		auto retval = PED::GET_PED_BONE_INDEX(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_GET_PED_RAGDOLL_BONE_INDEX( int ped, int bone) { return invoke<int )
	{
		auto retval = PED::GET_PED_RAGDOLL_BONE_INDEX(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ENVEFF_SCALE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_ENVEFF_SCALE(ped, invoke<void);
	}

	float LUA_NATIVE_PED_GET_PED_ENVEFF_SCALE( int ped) { return invoke<float )
	{
		auto retval = PED::GET_PED_ENVEFF_SCALE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PED_SET_ENABLE_PED_ENVEFF_SCALE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ENABLE_PED_ENVEFF_SCALE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ENVEFF_CPV_ADD( int ped, float p1) { invoke<void )
	{
		PED::SET_PED_ENVEFF_CPV_ADD(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_ENVEFF_COLOR_MODULATOR( int ped, int p1, int p2, int p3) { invoke<void )
	{
		PED::SET_PED_ENVEFF_COLOR_MODULATOR(ped, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_EMISSIVE_SCALE( int ped, float intensity) { invoke<void )
	{
		PED::SET_PED_EMISSIVE_SCALE(ped, invoke<void);
	}

	float LUA_NATIVE_PED_GET_PED_EMISSIVE_SCALE( int ped) { return invoke<float )
	{
		auto retval = PED::GET_PED_EMISSIVE_SCALE(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_SHADER_READY( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SHADER_READY(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_ENABLE_CREW_EMBLEM( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_ENABLE_CREW_EMBLEM(ped, invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_RAGDOLL_BOUNDS_UPDATE( Any p0, Any p1) { invoke<void )
	{
		PED::REQUEST_RAGDOLL_BOUNDS_UPDATE(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_AO_BLOB_RENDERING( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_AO_BLOB_RENDERING(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_SHELTERED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SHELTERED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_SYNCHRONIZED_SCENE( float x, float y, float z, float roll, float pitch, float yaw, int p6) { return invoke<int )
	{
		auto retval = PED::CREATE_SYNCHRONIZED_SCENE(x, y, z, roll, pitch, yaw, invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_CREATE_SYNCHRONIZED_SCENE_AT_MAP_OBJECT( float x, float y, float z, float radius, unsigned object) { return invoke<int )
	{
		auto retval = PED::CREATE_SYNCHRONIZED_SCENE_AT_MAP_OBJECT(x, y, z, radius, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_SYNCHRONIZED_SCENE_RUNNING( int sceneId) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_SYNCHRONIZED_SCENE_RUNNING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_SYNCHRONIZED_SCENE_ORIGIN( int sceneID, float x, float y, float z, float roll, float pitch, float yaw, bool p7) { invoke<void )
	{
		PED::SET_SYNCHRONIZED_SCENE_ORIGIN(sceneID, x, y, z, roll, pitch, yaw, invoke<void);
	}

	void LUA_NATIVE_PED_SET_SYNCHRONIZED_SCENE_PHASE( int sceneID, float phase) { invoke<void )
	{
		PED::SET_SYNCHRONIZED_SCENE_PHASE(sceneID, invoke<void);
	}

	float LUA_NATIVE_PED_GET_SYNCHRONIZED_SCENE_PHASE( int sceneID) { return invoke<float )
	{
		auto retval = PED::GET_SYNCHRONIZED_SCENE_PHASE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PED_SET_SYNCHRONIZED_SCENE_RATE( int sceneID, float rate) { invoke<void )
	{
		PED::SET_SYNCHRONIZED_SCENE_RATE(sceneID, invoke<void);
	}

	float LUA_NATIVE_PED_GET_SYNCHRONIZED_SCENE_RATE( int sceneID) { return invoke<float )
	{
		auto retval = PED::GET_SYNCHRONIZED_SCENE_RATE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PED_SET_SYNCHRONIZED_SCENE_LOOPED( int sceneID, bool toggle) { invoke<void )
	{
		PED::SET_SYNCHRONIZED_SCENE_LOOPED(sceneID, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_SYNCHRONIZED_SCENE_LOOPED( int sceneID) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_SYNCHRONIZED_SCENE_LOOPED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_SYNCHRONIZED_SCENE_HOLD_LAST_FRAME( int sceneID, bool toggle) { invoke<void )
	{
		PED::SET_SYNCHRONIZED_SCENE_HOLD_LAST_FRAME(sceneID, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_SYNCHRONIZED_SCENE_HOLD_LAST_FRAME( int sceneID) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_SYNCHRONIZED_SCENE_HOLD_LAST_FRAME(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_ATTACH_SYNCHRONIZED_SCENE_TO_ENTITY( int sceneID, int entity, int boneIndex) { invoke<void )
	{
		PED::ATTACH_SYNCHRONIZED_SCENE_TO_ENTITY(sceneID, entity, invoke<void);
	}

	void LUA_NATIVE_PED_DETACH_SYNCHRONIZED_SCENE( int sceneID) { invoke<void )
	{
		PED::DETACH_SYNCHRONIZED_SCENE(invoke<void);
	}

	void LUA_NATIVE_PED_TAKE_OWNERSHIP_OF_SYNCHRONIZED_SCENE( int scene) { invoke<void )
	{
		PED::TAKE_OWNERSHIP_OF_SYNCHRONIZED_SCENE(invoke<void);
	}

	bool LUA_NATIVE_PED_FORCE_PED_MOTION_STATE( int ped, unsigned motionStateHash, bool p2, int p3, bool p4) { return invoke<BOOL )
	{
		auto retval = (bool)PED::FORCE_PED_MOTION_STATE(ped, motionStateHash, p2, p3, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, float, float speedY) { return> LUA_NATIVE_PED_GET_PED_CURRENT_MOVE_BLEND_RATIO( int ped, float speedX, float speedY) { return invoke<BOOL )
	{
		std::tuple<bool, float, float speedY) { return> return_values;
		std::get<0>(return_values) = (bool)PED::GET_PED_CURRENT_MOVE_BLEND_RATIO(ped, &speedX, &invoke<BOOL);
		std::get<1>(return_values) = speedX;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PED_SET_PED_MAX_MOVE_BLEND_RATIO( int ped, float value) { invoke<void )
	{
		PED::SET_PED_MAX_MOVE_BLEND_RATIO(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MIN_MOVE_BLEND_RATIO( int ped, float value) { invoke<void )
	{
		PED::SET_PED_MIN_MOVE_BLEND_RATIO(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MOVE_RATE_OVERRIDE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_MOVE_RATE_OVERRIDE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_MOVE_RATE_IN_WATER_OVERRIDE( int ped, float p1) { invoke<void )
	{
		PED::SET_PED_MOVE_RATE_IN_WATER_OVERRIDE(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_PED_HAS_SEXINESS_FLAG_SET( int ped, int sexinessFlag) { return invoke<BOOL )
	{
		auto retval = (bool)PED::PED_HAS_SEXINESS_FLAG_SET(ped, invoke<BOOL);
		return retval;
	}

	std::tuple<int, Any sizeAndVehs) { return> LUA_NATIVE_PED_GET_PED_NEARBY_VEHICLES( int ped, Any sizeAndVehs) { return invoke<int )
	{
		std::tuple<int, Any sizeAndVehs) { return> return_values;
		std::get<0>(return_values) = PED::GET_PED_NEARBY_VEHICLES(ped, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, Any> LUA_NATIVE_PED_GET_PED_NEARBY_PEDS( int ped, Any sizeAndPeds, int ignore) { return invoke<int )
	{
		std::tuple<int, Any> return_values;
		std::get<0>(return_values) = PED::GET_PED_NEARBY_PEDS(ped, &sizeAndPeds, invoke<int);
		std::get<1>(return_values) = sizeAndPeds;

		return return_values;
	}

	bool LUA_NATIVE_PED_HAVE_ALL_STREAMING_REQUESTS_COMPLETED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAVE_ALL_STREAMING_REQUESTS_COMPLETED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PED_USING_ACTION_MODE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_USING_ACTION_MODE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_USING_ACTION_MODE( int ped, bool p1, int p2, const char* action) { invoke<void )
	{
		PED::SET_PED_USING_ACTION_MODE(ped, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PED_SET_MOVEMENT_MODE_OVERRIDE( int ped, const char* name) { invoke<void )
	{
		PED::SET_MOVEMENT_MODE_OVERRIDE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAPSULE( int ped, float value) { invoke<void )
	{
		PED::SET_PED_CAPSULE(ped, invoke<void);
	}

	int LUA_NATIVE_PED_REGISTER_PEDHEADSHOT( int ped) { return invoke<int )
	{
		auto retval = PED::REGISTER_PEDHEADSHOT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_REGISTER_PEDHEADSHOT_HIRES( int ped) { return invoke<int )
	{
		auto retval = PED::REGISTER_PEDHEADSHOT_HIRES(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PED_REGISTER_PEDHEADSHOT_TRANSPARENT( int ped) { return invoke<int )
	{
		auto retval = PED::REGISTER_PEDHEADSHOT_TRANSPARENT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PED_UNREGISTER_PEDHEADSHOT( int id) { invoke<void )
	{
		PED::UNREGISTER_PEDHEADSHOT(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PEDHEADSHOT_VALID( int id) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PEDHEADSHOT_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PED_IS_PEDHEADSHOT_READY( int id) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PEDHEADSHOT_READY(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_PED_GET_PEDHEADSHOT_TXD_STRING( int id) { return invoke<const char* )
	{
		auto retval = PED::GET_PEDHEADSHOT_TXD_STRING(char*);
		return retval;
	}

	bool LUA_NATIVE_PED_REQUEST_PEDHEADSHOT_IMG_UPLOAD( int id) { return invoke<BOOL )
	{
		auto retval = (bool)PED::REQUEST_PEDHEADSHOT_IMG_UPLOAD(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_RELEASE_PEDHEADSHOT_IMG_UPLOAD( int id) { invoke<void )
	{
		PED::RELEASE_PEDHEADSHOT_IMG_UPLOAD(invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PEDHEADSHOT_IMG_UPLOAD_AVAILABLE(  )
	{
		auto retval = (bool)PED::IS_PEDHEADSHOT_IMG_UPLOAD_AVAILABLE();
		return retval;
	}

	bool LUA_NATIVE_PED_HAS_PEDHEADSHOT_IMG_UPLOAD_FAILED(  )
	{
		auto retval = (bool)PED::HAS_PEDHEADSHOT_IMG_UPLOAD_FAILED();
		return retval;
	}

	bool LUA_NATIVE_PED_HAS_PEDHEADSHOT_IMG_UPLOAD_SUCCEEDED(  )
	{
		auto retval = (bool)PED::HAS_PEDHEADSHOT_IMG_UPLOAD_SUCCEEDED();
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_HEATSCALE_OVERRIDE( int ped, float heatScale) { invoke<void )
	{
		PED::SET_PED_HEATSCALE_OVERRIDE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_DISABLE_PED_HEATSCALE_OVERRIDE( int ped) { invoke<void )
	{
		PED::DISABLE_PED_HEATSCALE_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PED_SPAWNPOINTS_START_SEARCH( float p0, float p1, float p2, float p3, float p4, int interiorFlags, float scale, int duration) { invoke<void )
	{
		PED::SPAWNPOINTS_START_SEARCH(p0, p1, p2, p3, p4, interiorFlags, scale, invoke<void);
	}

	void LUA_NATIVE_PED_SPAWNPOINTS_START_SEARCH_IN_ANGLED_AREA( float x1, float y1, float z1, float x2, float y2, float z2, float width, int interiorFlags, float scale, int duration) { invoke<void )
	{
		PED::SPAWNPOINTS_START_SEARCH_IN_ANGLED_AREA(x1, y1, z1, x2, y2, z2, width, interiorFlags, scale, invoke<void);
	}

	void LUA_NATIVE_PED_SPAWNPOINTS_CANCEL_SEARCH(  )
	{
		PED::SPAWNPOINTS_CANCEL_SEARCH();
	}

	bool LUA_NATIVE_PED_SPAWNPOINTS_IS_SEARCH_ACTIVE(  )
	{
		auto retval = (bool)PED::SPAWNPOINTS_IS_SEARCH_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_PED_SPAWNPOINTS_IS_SEARCH_COMPLETE(  )
	{
		auto retval = (bool)PED::SPAWNPOINTS_IS_SEARCH_COMPLETE();
		return retval;
	}

	bool LUA_NATIVE_PED_SPAWNPOINTS_IS_SEARCH_FAILED(  )
	{
		auto retval = (bool)PED::SPAWNPOINTS_IS_SEARCH_FAILED();
		return retval;
	}

	int LUA_NATIVE_PED_SPAWNPOINTS_GET_NUM_SEARCH_RESULTS(  )
	{
		auto retval = PED::SPAWNPOINTS_GET_NUM_SEARCH_RESULTS();
		return retval;
	}

	std::tuple<float, float, float z) {> LUA_NATIVE_PED_SPAWNPOINTS_GET_SEARCH_RESULT( int randomInt, float x, float y, float z) { invoke<void )
	{
		std::tuple<float, float, float z) {> return_values;
		PED::SPAWNPOINTS_GET_SEARCH_RESULT(randomInt, &x, &y, &invoke<void);
		std::get<0>(return_values) = x;
		std::get<1>(return_values) = y;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	int p1) { LUA_NATIVE_PED_SPAWNPOINTS_GET_SEARCH_RESULT_FLAGS( int p0, int p1) { invoke<void )
	{
		PED::SPAWNPOINTS_GET_SEARCH_RESULT_FLAGS(p0, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PED_SET_IK_TARGET( int ped, int ikIndex, int entityLookAt, int boneLookAt, float offsetX, float offsetY, float offsetZ, Any p7, int blendInDuration, int blendOutDuration) { invoke<void )
	{
		PED::SET_IK_TARGET(ped, ikIndex, entityLookAt, boneLookAt, offsetX, offsetY, offsetZ, p7, blendInDuration, invoke<void);
	}

	void LUA_NATIVE_PED_FORCE_INSTANT_LEG_IK_SETUP( int ped) { invoke<void )
	{
		PED::FORCE_INSTANT_LEG_IK_SETUP(invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_ACTION_MODE_ASSET( const char* asset) { invoke<void )
	{
		PED::REQUEST_ACTION_MODE_ASSET(invoke<void);
	}

	bool LUA_NATIVE_PED_HAS_ACTION_MODE_ASSET_LOADED( const char* asset) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_ACTION_MODE_ASSET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_REMOVE_ACTION_MODE_ASSET( const char* asset) { invoke<void )
	{
		PED::REMOVE_ACTION_MODE_ASSET(invoke<void);
	}

	void LUA_NATIVE_PED_REQUEST_STEALTH_MODE_ASSET( const char* asset) { invoke<void )
	{
		PED::REQUEST_STEALTH_MODE_ASSET(invoke<void);
	}

	bool LUA_NATIVE_PED_HAS_STEALTH_MODE_ASSET_LOADED( const char* asset) { return invoke<BOOL )
	{
		auto retval = (bool)PED::HAS_STEALTH_MODE_ASSET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_REMOVE_STEALTH_MODE_ASSET( const char* asset) { invoke<void )
	{
		PED::REMOVE_STEALTH_MODE_ASSET(invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_LOD_MULTIPLIER( int ped, float multiplier) { invoke<void )
	{
		PED::SET_PED_LOD_MULTIPLIER(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_CAN_LOSE_PROPS_ON_DAMAGE( int ped, bool toggle, int p2) { invoke<void )
	{
		PED::SET_PED_CAN_LOSE_PROPS_ON_DAMAGE(ped, toggle, invoke<void);
	}

	void LUA_NATIVE_PED_SET_FORCE_FOOTSTEP_UPDATE( int ped, bool toggle) { invoke<void )
	{
		PED::SET_FORCE_FOOTSTEP_UPDATE(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_FORCE_STEP_TYPE( int ped, bool p1, int type, int p3) { invoke<void )
	{
		PED::SET_FORCE_STEP_TYPE(ped, p1, type, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_ANY_HOSTILE_PED_NEAR_POINT( int ped, float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_ANY_HOSTILE_PED_NEAR_POINT(ped, x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_CAN_PLAY_IN_CAR_IDLES( int ped, bool toggle) { invoke<void )
	{
		PED::SET_PED_CAN_PLAY_IN_CAR_IDLES(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_TARGET_PED_IN_PERCEPTION_AREA( int ped, int targetPed, float p2, float p3, float p4, float p5) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_TARGET_PED_IN_PERCEPTION_AREA(ped, targetPed, p2, p3, p4, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_POP_CONTROL_SPHERE_THIS_FRAME( float x, float y, float z, float min, float max) { invoke<void )
	{
		PED::SET_POP_CONTROL_SPHERE_THIS_FRAME(x, y, z, min, invoke<void);
	}

	void LUA_NATIVE_PED_FORCE_ZERO_MASS_IN_COLLISIONS( int ped) { invoke<void )
	{
		PED::FORCE_ZERO_MASS_IN_COLLISIONS(invoke<void);
	}

	void LUA_NATIVE_PED_SET_DISABLE_HIGH_FALL_DEATH( int ped, bool toggle) { invoke<void )
	{
		PED::SET_DISABLE_HIGH_FALL_DEATH(ped, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_PHONE_PALETTE_IDX( Any p0, Any p1) { invoke<void )
	{
		PED::SET_PED_PHONE_PALETTE_IDX(p0, invoke<void);
	}

	void LUA_NATIVE_PED_SET_PED_STEER_BIAS( int ped, float value) { invoke<void )
	{
		PED::SET_PED_STEER_BIAS(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_IS_PED_SWITCHING_WEAPON( int Ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::IS_PED_SWITCHING_WEAPON(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_SET_PED_TREATED_AS_FRIENDLY( Any p0, Any p1, Any p2) { invoke<void )
	{
		PED::SET_PED_TREATED_AS_FRIENDLY(p0, p1, invoke<void);
	}

	void LUA_NATIVE_PED_SET_DISABLE_PED_MAP_COLLISION( int ped) { invoke<void )
	{
		PED::SET_DISABLE_PED_MAP_COLLISION(invoke<void);
	}

	void LUA_NATIVE_PED_ENABLE_MP_LIGHT( int ped, bool toggle) { invoke<void )
	{
		PED::ENABLE_MP_LIGHT(ped, invoke<void);
	}

	bool LUA_NATIVE_PED_GET_MP_LIGHT_ENABLED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PED::GET_MP_LIGHT_ENABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PED_CLEAR_COVER_POINT_FOR_PED( int ped) { invoke<void )
	{
		PED::CLEAR_COVER_POINT_FOR_PED(invoke<void);
	}

	void LUA_NATIVE_PED_SET_ALLOW_STUNT_JUMP_CAMERA( int ped, bool toggle) { invoke<void )
	{
		PED::SET_ALLOW_STUNT_JUMP_CAMERA(ped, invoke<void);
	}

	std::tuple<int, Any unkPtr) { return> LUA_NATIVE_PHYSICS_ADD_ROPE( float x, float y, float z, float rotX, float rotY, float rotZ, float length, int ropeType, float maxLength, float minLength, float windingSpeed, bool p11, bool p12, bool rigid, float p14, bool breakWhenShot, Any unkPtr) { return invoke<int )
	{
		std::tuple<int, Any unkPtr) { return> return_values;
		std::get<0>(return_values) = PHYSICS::ADD_ROPE(x, y, z, rotX, rotY, rotZ, length, ropeType, maxLength, minLength, windingSpeed, p11, p12, rigid, p14, breakWhenShot, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	int ropeId) { LUA_NATIVE_PHYSICS_DELETE_ROPE( int ropeId) { invoke<void )
	{
		PHYSICS::DELETE_ROPE(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PHYSICS_DELETE_CHILD_ROPE( int ropeId) { invoke<void )
	{
		PHYSICS::DELETE_CHILD_ROPE(invoke<void);
	}

	std::tuple<bool, int ropeId) { return> LUA_NATIVE_PHYSICS_DOES_ROPE_EXIST( int ropeId) { return invoke<BOOL )
	{
		std::tuple<bool, int ropeId) { return> return_values;
		std::get<0>(return_values) = (bool)PHYSICS::DOES_ROPE_EXIST(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_PHYSICS_ROPE_DRAW_ENABLED( int ropeId, bool p1) { invoke<void )
	{
		PHYSICS::ROPE_DRAW_ENABLED(&ropeId, invoke<void);
		return ropeId;
	}

	int LUA_NATIVE_PHYSICS_ROPE_DRAW_SHADOW_ENABLED( int ropeId, bool toggle) { invoke<void )
	{
		PHYSICS::ROPE_DRAW_SHADOW_ENABLED(&ropeId, invoke<void);
		return ropeId;
	}

	void LUA_NATIVE_PHYSICS_LOAD_ROPE_DATA( int ropeId, const char* rope_preset) { invoke<void )
	{
		PHYSICS::LOAD_ROPE_DATA(ropeId, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_PIN_ROPE_VERTEX( int ropeId, int vertex, float x, float y, float z) { invoke<void )
	{
		PHYSICS::PIN_ROPE_VERTEX(ropeId, vertex, x, y, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_UNPIN_ROPE_VERTEX( int ropeId, int vertex) { invoke<void )
	{
		PHYSICS::UNPIN_ROPE_VERTEX(ropeId, invoke<void);
	}

	int LUA_NATIVE_PHYSICS_GET_ROPE_VERTEX_COUNT( int ropeId) { return invoke<int )
	{
		auto retval = PHYSICS::GET_ROPE_VERTEX_COUNT(invoke<int);
		return retval;
	}

	std::tuple<Any, Any p13) {> LUA_NATIVE_PHYSICS_ATTACH_ENTITIES_TO_ROPE( int ropeId, int ent1, int ent2, float ent1_x, float ent1_y, float ent1_z, float ent2_x, float ent2_y, float ent2_z, float length, bool p10, bool p11, Any p12, Any p13) { invoke<void )
	{
		std::tuple<Any, Any p13) {> return_values;
		PHYSICS::ATTACH_ENTITIES_TO_ROPE(ropeId, ent1, ent2, ent1_x, ent1_y, ent1_z, ent2_x, ent2_y, ent2_z, length, p10, p11, &p12, &invoke<void);
		std::get<0>(return_values) = p12;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_PHYSICS_ATTACH_ROPE_TO_ENTITY( int ropeId, int entity, float x, float y, float z, bool p5) { invoke<void )
	{
		PHYSICS::ATTACH_ROPE_TO_ENTITY(ropeId, entity, x, y, z, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_DETACH_ROPE_FROM_ENTITY( int ropeId, int entity) { invoke<void )
	{
		PHYSICS::DETACH_ROPE_FROM_ENTITY(ropeId, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_SET_UPDATE_PINVERTS( int ropeId) { invoke<void )
	{
		PHYSICS::ROPE_SET_UPDATE_PINVERTS(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_SET_UPDATE_ORDER( int ropeId, Any p1) { invoke<void )
	{
		PHYSICS::ROPE_SET_UPDATE_ORDER(ropeId, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_SET_SMOOTH_REELIN( int ropeId, bool p1) { invoke<void )
	{
		PHYSICS::ROPE_SET_SMOOTH_REELIN(ropeId, invoke<void);
	}

	std::tuple<bool, int ropeId) { return> LUA_NATIVE_PHYSICS_IS_ROPE_ATTACHED_AT_BOTH_ENDS( int ropeId) { return invoke<BOOL )
	{
		std::tuple<bool, int ropeId) { return> return_values;
		std::get<0>(return_values) = (bool)PHYSICS::IS_ROPE_ATTACHED_AT_BOTH_ENDS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	Vector3 LUA_NATIVE_PHYSICS_GET_ROPE_LAST_VERTEX_COORD( int ropeId) { return invoke<Vector3 )
	{
		auto retval = PHYSICS::GET_ROPE_LAST_VERTEX_COORD(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_PHYSICS_GET_ROPE_VERTEX_COORD( int ropeId, int vertex) { return invoke<Vector3 )
	{
		auto retval = PHYSICS::GET_ROPE_VERTEX_COORD(ropeId, invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_PHYSICS_START_ROPE_WINDING( int ropeId) { invoke<void )
	{
		PHYSICS::START_ROPE_WINDING(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_STOP_ROPE_WINDING( int ropeId) { invoke<void )
	{
		PHYSICS::STOP_ROPE_WINDING(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_START_ROPE_UNWINDING_FRONT( int ropeId) { invoke<void )
	{
		PHYSICS::START_ROPE_UNWINDING_FRONT(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_STOP_ROPE_UNWINDING_FRONT( int ropeId) { invoke<void )
	{
		PHYSICS::STOP_ROPE_UNWINDING_FRONT(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_CONVERT_TO_SIMPLE( int ropeId) { invoke<void )
	{
		PHYSICS::ROPE_CONVERT_TO_SIMPLE(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_LOAD_TEXTURES(  )
	{
		PHYSICS::ROPE_LOAD_TEXTURES();
	}

	bool LUA_NATIVE_PHYSICS_ROPE_ARE_TEXTURES_LOADED(  )
	{
		auto retval = (bool)PHYSICS::ROPE_ARE_TEXTURES_LOADED();
		return retval;
	}

	void LUA_NATIVE_PHYSICS_ROPE_UNLOAD_TEXTURES(  )
	{
		PHYSICS::ROPE_UNLOAD_TEXTURES();
	}

	bool LUA_NATIVE_PHYSICS_DOES_SCRIPT_OWN_ROPE( int ropeId) { return invoke<BOOL )
	{
		auto retval = (bool)PHYSICS::DOES_SCRIPT_OWN_ROPE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PHYSICS_ROPE_ATTACH_VIRTUAL_BOUND_GEOM( int ropeId, int p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13) { invoke<void )
	{
		PHYSICS::ROPE_ATTACH_VIRTUAL_BOUND_GEOM(ropeId, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_CHANGE_SCRIPT_OWNER( Any p0, bool p1, bool p2) { invoke<void )
	{
		PHYSICS::ROPE_CHANGE_SCRIPT_OWNER(p0, p1, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_SET_REFFRAMEVELOCITY_COLLIDERORDER( int ropeId, int p1) { invoke<void )
	{
		PHYSICS::ROPE_SET_REFFRAMEVELOCITY_COLLIDERORDER(ropeId, invoke<void);
	}

	float LUA_NATIVE_PHYSICS_ROPE_GET_DISTANCE_BETWEEN_ENDS( int ropeId) { return invoke<float )
	{
		auto retval = PHYSICS::ROPE_GET_DISTANCE_BETWEEN_ENDS(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PHYSICS_ROPE_FORCE_LENGTH( int ropeId, float length) { invoke<void )
	{
		PHYSICS::ROPE_FORCE_LENGTH(ropeId, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ROPE_RESET_LENGTH( int ropeId, float length) { invoke<void )
	{
		PHYSICS::ROPE_RESET_LENGTH(ropeId, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_APPLY_IMPULSE_TO_CLOTH( float posX, float posY, float posZ, float vecX, float vecY, float vecZ, float impulse) { invoke<void )
	{
		PHYSICS::APPLY_IMPULSE_TO_CLOTH(posX, posY, posZ, vecX, vecY, vecZ, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_DAMPING( int entity, int vertex, float value) { invoke<void )
	{
		PHYSICS::SET_DAMPING(entity, vertex, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_ACTIVATE_PHYSICS( int entity) { invoke<void )
	{
		PHYSICS::ACTIVATE_PHYSICS(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_CGOFFSET( int entity, float x, float y, float z) { invoke<void )
	{
		PHYSICS::SET_CGOFFSET(entity, x, y, invoke<void);
	}

	Vector3 LUA_NATIVE_PHYSICS_GET_CGOFFSET( int entity) { return invoke<Vector3 )
	{
		auto retval = PHYSICS::GET_CGOFFSET(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_PHYSICS_SET_CG_AT_BOUNDCENTER( int entity) { invoke<void )
	{
		PHYSICS::SET_CG_AT_BOUNDCENTER(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_BREAK_ENTITY_GLASS( int entity, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, Any p9, bool p10) { invoke<void )
	{
		PHYSICS::BREAK_ENTITY_GLASS(entity, p1, p2, p3, p4, p5, p6, p7, p8, p9, invoke<void);
	}

	bool LUA_NATIVE_PHYSICS_GET_IS_ENTITY_A_FRAG( Object object) { return invoke<BOOL )
	{
		auto retval = (bool)PHYSICS::GET_IS_ENTITY_A_FRAG(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PHYSICS_SET_DISABLE_BREAKING( Object object, bool toggle) { invoke<void )
	{
		PHYSICS::SET_DISABLE_BREAKING(object, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_RESET_DISABLE_BREAKING( Object object) { invoke<void )
	{
		PHYSICS::RESET_DISABLE_BREAKING(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_DISABLE_FRAG_DAMAGE( Object object, bool toggle) { invoke<void )
	{
		PHYSICS::SET_DISABLE_FRAG_DAMAGE(object, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_USE_KINEMATIC_PHYSICS( int entity, bool toggle) { invoke<void )
	{
		PHYSICS::SET_USE_KINEMATIC_PHYSICS(entity, invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_IN_STUNT_MODE( bool p0) { invoke<void )
	{
		PHYSICS::SET_IN_STUNT_MODE(invoke<void);
	}

	void LUA_NATIVE_PHYSICS_SET_IN_ARENA_MODE( bool toggle) { invoke<void )
	{
		PHYSICS::SET_IN_ARENA_MODE(invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_PED( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_PED(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_PED_SCRIPT_INDEX( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_PED_SCRIPT_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MODEL( int player, unsigned model) { invoke<void )
	{
		PLAYER::SET_PLAYER_MODEL(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_CHANGE_PLAYER_PED( int player, int ped, bool p2, bool resetDamage) { invoke<void )
	{
		PLAYER::CHANGE_PLAYER_PED(player, ped, p2, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_PLAYER_GET_PLAYER_RGB_COLOUR( int player, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		PLAYER::GET_PLAYER_RGB_COLOUR(player, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_PLAYER_GET_NUMBER_OF_PLAYERS(  )
	{
		auto retval = PLAYER::GET_NUMBER_OF_PLAYERS();
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_TEAM( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_TEAM(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_TEAM( int player, int team) { invoke<void )
	{
		PLAYER::SET_PLAYER_TEAM(player, invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_NUMBER_OF_PLAYERS_IN_TEAM( int team) { return invoke<int )
	{
		auto retval = PLAYER::GET_NUMBER_OF_PLAYERS_IN_TEAM(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_PLAYER_GET_PLAYER_NAME( int player) { return invoke<const char* )
	{
		auto retval = PLAYER::GET_PLAYER_NAME(char*);
		return retval;
	}

	float LUA_NATIVE_PLAYER_GET_WANTED_LEVEL_RADIUS( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_WANTED_LEVEL_RADIUS(invoke<float);
		return retval;
	}

	Vector3 LUA_NATIVE_PLAYER_GET_PLAYER_WANTED_CENTRE_POSITION( int player) { return invoke<Vector3 )
	{
		auto retval = PLAYER::GET_PLAYER_WANTED_CENTRE_POSITION(invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_PLAYER_SET_PLAYER_WANTED_CENTRE_POSITION( int player, Vector3 position, bool p2, bool p3) { invoke<void )
	{
		PLAYER::SET_PLAYER_WANTED_CENTRE_POSITION(player, &position, p2, invoke<void);
		return position;
	}

	int LUA_NATIVE_PLAYER_GET_WANTED_LEVEL_THRESHOLD( int wantedLevel) { return invoke<int )
	{
		auto retval = PLAYER::GET_WANTED_LEVEL_THRESHOLD(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WANTED_LEVEL( int player, int wantedLevel, bool disableNoMission) { invoke<void )
	{
		PLAYER::SET_PLAYER_WANTED_LEVEL(player, wantedLevel, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WANTED_LEVEL_NO_DROP( int player, int wantedLevel, bool p2) { invoke<void )
	{
		PLAYER::SET_PLAYER_WANTED_LEVEL_NO_DROP(player, wantedLevel, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WANTED_LEVEL_NOW( int player, bool p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_WANTED_LEVEL_NOW(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_ARE_PLAYER_FLASHING_STARS_ABOUT_TO_DROP( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::ARE_PLAYER_FLASHING_STARS_ABOUT_TO_DROP(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_ARE_PLAYER_STARS_GREYED_OUT( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::ARE_PLAYER_STARS_GREYED_OUT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_WANTED_AND_HAS_BEEN_SEEN_BY_COPS( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_WANTED_AND_HAS_BEEN_SEEN_BY_COPS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_DISPATCH_COPS_FOR_PLAYER( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_DISPATCH_COPS_FOR_PLAYER(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_WANTED_LEVEL_GREATER( int player, int wantedLevel) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_WANTED_LEVEL_GREATER(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_WANTED_LEVEL( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_WANTED_LEVEL(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_DEAD( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_DEAD(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_PRESSING_HORN( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_PRESSING_HORN(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CONTROL( int player, bool bHasControl, int flags) { invoke<void )
	{
		PLAYER::SET_PLAYER_CONTROL(player, bHasControl, invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_WANTED_LEVEL( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_WANTED_LEVEL(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_MAX_WANTED_LEVEL( int maxWantedLevel) { invoke<void )
	{
		PLAYER::SET_MAX_WANTED_LEVEL(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_POLICE_RADAR_BLIPS( bool toggle) { invoke<void )
	{
		PLAYER::SET_POLICE_RADAR_BLIPS(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_POLICE_IGNORE_PLAYER( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_POLICE_IGNORE_PLAYER(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_PLAYING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_PLAYING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_EVERYONE_IGNORE_PLAYER( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_EVERYONE_IGNORE_PLAYER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_ALL_RANDOM_PEDS_FLEE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_ALL_RANDOM_PEDS_FLEE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_ALL_RANDOM_PEDS_FLEE_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::SET_ALL_RANDOM_PEDS_FLEE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_ALL_NEUTRAL_RANDOM_PEDS_FLEE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_ALL_NEUTRAL_RANDOM_PEDS_FLEE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_ALL_NEUTRAL_RANDOM_PEDS_FLEE_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::SET_ALL_NEUTRAL_RANDOM_PEDS_FLEE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_LAW_PEDS_CAN_ATTACK_NON_WANTED_PLAYER_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::SET_LAW_PEDS_CAN_ATTACK_NON_WANTED_PLAYER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_IGNORE_LOW_PRIORITY_SHOCKING_EVENTS( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_IGNORE_LOW_PRIORITY_SHOCKING_EVENTS(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_WANTED_LEVEL_MULTIPLIER( float multiplier) { invoke<void )
	{
		PLAYER::SET_WANTED_LEVEL_MULTIPLIER(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_WANTED_LEVEL_DIFFICULTY( int player, float difficulty) { invoke<void )
	{
		PLAYER::SET_WANTED_LEVEL_DIFFICULTY(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_WANTED_LEVEL_DIFFICULTY( int player) { invoke<void )
	{
		PLAYER::RESET_WANTED_LEVEL_DIFFICULTY(invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_WANTED_LEVEL_TIME_TO_ESCAPE(  )
	{
		auto retval = PLAYER::GET_WANTED_LEVEL_TIME_TO_ESCAPE();
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_WANTED_LEVEL_HIDDEN_ESCAPE_TIME( int player, int wantedLevel, int lossTime) { invoke<void )
	{
		PLAYER::SET_WANTED_LEVEL_HIDDEN_ESCAPE_TIME(player, wantedLevel, invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_WANTED_LEVEL_HIDDEN_ESCAPE_TIME( int player) { invoke<void )
	{
		PLAYER::RESET_WANTED_LEVEL_HIDDEN_ESCAPE_TIME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_START_FIRING_AMNESTY( int duration) { invoke<void )
	{
		PLAYER::START_FIRING_AMNESTY(invoke<void);
	}

	void LUA_NATIVE_PLAYER_REPORT_CRIME( int player, int crimeType, int wantedLvlThresh) { invoke<void )
	{
		PLAYER::REPORT_CRIME(player, crimeType, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SUPPRESS_CRIME_THIS_FRAME( int player, int crimeType) { invoke<void )
	{
		PLAYER::SUPPRESS_CRIME_THIS_FRAME(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_UPDATE_WANTED_POSITION_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::UPDATE_WANTED_POSITION_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SUPPRESS_LOSING_WANTED_LEVEL_IF_HIDDEN_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::SUPPRESS_LOSING_WANTED_LEVEL_IF_HIDDEN_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_ALLOW_EVASION_HUD_IF_DISABLING_HIDDEN_EVASION_THIS_FRAME( int player, Any p1) { invoke<void )
	{
		PLAYER::ALLOW_EVASION_HUD_IF_DISABLING_HIDDEN_EVASION_THIS_FRAME(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_FORCE_START_HIDDEN_EVASION( int player) { invoke<void )
	{
		PLAYER::FORCE_START_HIDDEN_EVASION(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SUPPRESS_WITNESSES_CALLING_POLICE_THIS_FRAME( int player) { invoke<void )
	{
		PLAYER::SUPPRESS_WITNESSES_CALLING_POLICE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_PLAYER_REPORT_POLICE_SPOTTED_PLAYER( int player) { invoke<void )
	{
		PLAYER::REPORT_POLICE_SPOTTED_PLAYER(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_LAW_RESPONSE_DELAY_OVERRIDE( float p0) { invoke<void )
	{
		PLAYER::SET_LAW_RESPONSE_DELAY_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_LAW_RESPONSE_DELAY_OVERRIDE(  )
	{
		PLAYER::RESET_LAW_RESPONSE_DELAY_OVERRIDE();
	}

	bool LUA_NATIVE_PLAYER_CAN_PLAYER_START_MISSION( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::CAN_PLAYER_START_MISSION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_READY_FOR_CUTSCENE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_READY_FOR_CUTSCENE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_TARGETTING_ENTITY( int player, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_TARGETTING_ENTITY(player, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int entity) { return> LUA_NATIVE_PLAYER_GET_PLAYER_TARGET_ENTITY( int player, int entity) { return invoke<BOOL )
	{
		std::tuple<bool, int entity) { return> return_values;
		std::get<0>(return_values) = (bool)PLAYER::GET_PLAYER_TARGET_ENTITY(player, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_FREE_AIMING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_FREE_AIMING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_FREE_AIMING_AT_ENTITY( int player, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_FREE_AIMING_AT_ENTITY(player, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int entity) { return> LUA_NATIVE_PLAYER_GET_ENTITY_PLAYER_IS_FREE_AIMING_AT( int player, int entity) { return invoke<BOOL )
	{
		std::tuple<bool, int entity) { return> return_values;
		std::get<0>(return_values) = (bool)PLAYER::GET_ENTITY_PLAYER_IS_FREE_AIMING_AT(player, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_LOCKON_RANGE_OVERRIDE( int player, float range) { invoke<void )
	{
		PLAYER::SET_PLAYER_LOCKON_RANGE_OVERRIDE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_DO_DRIVE_BY( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_DO_DRIVE_BY(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_BE_HASSLED_BY_GANGS( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_BE_HASSLED_BY_GANGS(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_USE_COVER( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_USE_COVER(player, invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_MAX_WANTED_LEVEL(  )
	{
		auto retval = PLAYER::GET_MAX_WANTED_LEVEL();
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_TARGETTING_ANYTHING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_TARGETTING_ANYTHING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_SPRINT( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_SPRINT(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_PLAYER_STAMINA( int player) { invoke<void )
	{
		PLAYER::RESET_PLAYER_STAMINA(invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESTORE_PLAYER_STAMINA( int player, float p1) { invoke<void )
	{
		PLAYER::RESTORE_PLAYER_STAMINA(player, invoke<void);
	}

	float LUA_NATIVE_PLAYER_GET_PLAYER_SPRINT_STAMINA_REMAINING( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_PLAYER_SPRINT_STAMINA_REMAINING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_PLAYER_GET_PLAYER_SPRINT_TIME_REMAINING( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_PLAYER_SPRINT_TIME_REMAINING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_PLAYER_GET_PLAYER_UNDERWATER_TIME_REMAINING( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_PLAYER_UNDERWATER_TIME_REMAINING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_PLAYER_SET_PLAYER_UNDERWATER_BREATH_PERCENT_REMAINING( int player, float time) { return invoke<float )
	{
		auto retval = PLAYER::SET_PLAYER_UNDERWATER_BREATH_PERCENT_REMAINING(player, invoke<float);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_GROUP( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_GROUP(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_MAX_ARMOUR( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_MAX_ARMOUR(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_CONTROL_ON( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_CONTROL_ON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_ARE_CAMERA_CONTROLS_DISABLED(  )
	{
		auto retval = (bool)PLAYER::GET_ARE_CAMERA_CONTROLS_DISABLED();
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_SCRIPT_CONTROL_ON( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_SCRIPT_CONTROL_ON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_CLIMBING( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_CLIMBING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_BEING_ARRESTED( int player, bool atArresting) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_BEING_ARRESTED(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_RESET_PLAYER_ARREST_STATE( int player) { invoke<void )
	{
		PLAYER::RESET_PLAYER_ARREST_STATE(invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_PLAYERS_LAST_VEHICLE(  )
	{
		auto retval = PLAYER::GET_PLAYERS_LAST_VEHICLE();
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_INDEX(  )
	{
		auto retval = PLAYER::GET_PLAYER_INDEX();
		return retval;
	}

	int LUA_NATIVE_PLAYER_INT_TO_PLAYERINDEX( int value) { return invoke<int )
	{
		auto retval = PLAYER::INT_TO_PLAYERINDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_INT_TO_PARTICIPANTINDEX( int value) { return invoke<int )
	{
		auto retval = PLAYER::INT_TO_PARTICIPANTINDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_PLAYER_HIT_VEHICLE( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_TIME_SINCE_PLAYER_HIT_VEHICLE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_PLAYER_HIT_PED( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_TIME_SINCE_PLAYER_HIT_PED(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_PLAYER_DROVE_ON_PAVEMENT( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_TIME_SINCE_PLAYER_DROVE_ON_PAVEMENT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_PLAYER_DROVE_AGAINST_TRAFFIC( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_TIME_SINCE_PLAYER_DROVE_AGAINST_TRAFFIC(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_FREE_FOR_AMBIENT_TASK( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_FREE_FOR_AMBIENT_TASK(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PLAYER_PLAYER_ID(  )
	{
		auto retval = PLAYER::PLAYER_ID();
		return retval;
	}

	int LUA_NATIVE_PLAYER_PLAYER_PED_ID(  )
	{
		auto retval = PLAYER::PLAYER_PED_ID();
		return retval;
	}

	int LUA_NATIVE_PLAYER_NETWORK_PLAYER_ID_TO_INT(  )
	{
		auto retval = PLAYER::NETWORK_PLAYER_ID_TO_INT();
		return retval;
	}

	bool LUA_NATIVE_PLAYER_HAS_FORCE_CLEANUP_OCCURRED( int cleanupFlags) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_FORCE_CLEANUP_OCCURRED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_FORCE_CLEANUP( int cleanupFlags) { invoke<void )
	{
		PLAYER::FORCE_CLEANUP(invoke<void);
	}

	void LUA_NATIVE_PLAYER_FORCE_CLEANUP_FOR_ALL_THREADS_WITH_THIS_NAME( const char* name, int cleanupFlags) { invoke<void )
	{
		PLAYER::FORCE_CLEANUP_FOR_ALL_THREADS_WITH_THIS_NAME(name, invoke<void);
	}

	void LUA_NATIVE_PLAYER_FORCE_CLEANUP_FOR_THREAD_WITH_THIS_ID( int id, int cleanupFlags) { invoke<void )
	{
		PLAYER::FORCE_CLEANUP_FOR_THREAD_WITH_THIS_ID(id, invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_CAUSE_OF_MOST_RECENT_FORCE_CLEANUP(  )
	{
		auto retval = PLAYER::GET_CAUSE_OF_MOST_RECENT_FORCE_CLEANUP();
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MAY_ONLY_ENTER_THIS_VEHICLE( int player, int vehicle) { invoke<void )
	{
		PLAYER::SET_PLAYER_MAY_ONLY_ENTER_THIS_VEHICLE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MAY_NOT_ENTER_ANY_VEHICLE( int player) { invoke<void )
	{
		PLAYER::SET_PLAYER_MAY_NOT_ENTER_ANY_VEHICLE(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_GIVE_ACHIEVEMENT_TO_PLAYER( int achievementId) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GIVE_ACHIEVEMENT_TO_PLAYER(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_SET_ACHIEVEMENT_PROGRESS( int achievementId, int progress) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::SET_ACHIEVEMENT_PROGRESS(achievementId, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_ACHIEVEMENT_PROGRESS( int achievementId) { return invoke<int )
	{
		auto retval = PLAYER::GET_ACHIEVEMENT_PROGRESS(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_HAS_ACHIEVEMENT_BEEN_PASSED( int achievementId) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_ACHIEVEMENT_BEEN_PASSED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_ONLINE(  )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_ONLINE();
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_LOGGING_IN_NP(  )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_LOGGING_IN_NP();
		return retval;
	}

	void LUA_NATIVE_PLAYER_DISPLAY_SYSTEM_SIGNIN_UI( bool p0) { invoke<void )
	{
		PLAYER::DISPLAY_SYSTEM_SIGNIN_UI(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_SYSTEM_UI_BEING_DISPLAYED(  )
	{
		auto retval = (bool)PLAYER::IS_SYSTEM_UI_BEING_DISPLAYED();
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_INVINCIBLE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_INVINCIBLE(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_GET_PLAYER_INVINCIBLE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_PLAYER_INVINCIBLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_PLAYER_DEBUG_INVINCIBLE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_PLAYER_DEBUG_INVINCIBLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_INVINCIBLE_BUT_HAS_REACTIONS( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_INVINCIBLE_BUT_HAS_REACTIONS(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_COLLECT_DROPPED_MONEY( int player, bool p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_COLLECT_DROPPED_MONEY(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_REMOVE_PLAYER_HELMET( int player, bool p2) { invoke<void )
	{
		PLAYER::REMOVE_PLAYER_HELMET(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_GIVE_PLAYER_RAGDOLL_CONTROL( int player, bool toggle) { invoke<void )
	{
		PLAYER::GIVE_PLAYER_RAGDOLL_CONTROL(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_LOCKON( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_LOCKON(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_TARGETING_MODE( int targetMode) { invoke<void )
	{
		PLAYER::SET_PLAYER_TARGETING_MODE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_TARGET_LEVEL( int targetLevel) { invoke<void )
	{
		PLAYER::SET_PLAYER_TARGET_LEVEL(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_GET_IS_USING_FPS_THIRD_PERSON_COVER(  )
	{
		auto retval = (bool)PLAYER::GET_IS_USING_FPS_THIRD_PERSON_COVER();
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_IS_USING_HOOD_CAMERA(  )
	{
		auto retval = (bool)PLAYER::GET_IS_USING_HOOD_CAMERA();
		return retval;
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_HAS_DAMAGED_AT_LEAST_ONE_PED( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_HAS_DAMAGED_AT_LEAST_ONE_PED(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_HAS_PLAYER_DAMAGED_AT_LEAST_ONE_PED( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_PLAYER_DAMAGED_AT_LEAST_ONE_PED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_HAS_DAMAGED_AT_LEAST_ONE_NON_ANIMAL_PED( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_HAS_DAMAGED_AT_LEAST_ONE_NON_ANIMAL_PED(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_HAS_PLAYER_DAMAGED_AT_LEAST_ONE_NON_ANIMAL_PED( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_PLAYER_DAMAGED_AT_LEAST_ONE_NON_ANIMAL_PED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_AIR_DRAG_MULTIPLIER_FOR_PLAYERS_VEHICLE( int player, float multiplier) { invoke<void )
	{
		PLAYER::SET_AIR_DRAG_MULTIPLIER_FOR_PLAYERS_VEHICLE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_SWIM_MULTIPLIER_FOR_PLAYER( int player, float multiplier) { invoke<void )
	{
		PLAYER::SET_SWIM_MULTIPLIER_FOR_PLAYER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_RUN_SPRINT_MULTIPLIER_FOR_PLAYER( int player, float multiplier) { invoke<void )
	{
		PLAYER::SET_RUN_SPRINT_MULTIPLIER_FOR_PLAYER(player, invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_LAST_ARREST(  )
	{
		auto retval = PLAYER::GET_TIME_SINCE_LAST_ARREST();
		return retval;
	}

	int LUA_NATIVE_PLAYER_GET_TIME_SINCE_LAST_DEATH(  )
	{
		auto retval = PLAYER::GET_TIME_SINCE_LAST_DEATH();
		return retval;
	}

	void LUA_NATIVE_PLAYER_ASSISTED_MOVEMENT_CLOSE_ROUTE(  )
	{
		PLAYER::ASSISTED_MOVEMENT_CLOSE_ROUTE();
	}

	void LUA_NATIVE_PLAYER_ASSISTED_MOVEMENT_FLUSH_ROUTE(  )
	{
		PLAYER::ASSISTED_MOVEMENT_FLUSH_ROUTE();
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_FORCED_AIM( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_FORCED_AIM(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_FORCED_ZOOM( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_FORCED_ZOOM(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_FORCE_SKIP_AIM_INTRO( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_FORCE_SKIP_AIM_INTRO(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_DISABLE_PLAYER_FIRING( int player, bool toggle) { invoke<void )
	{
		PLAYER::DISABLE_PLAYER_FIRING(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_DISABLE_PLAYER_THROW_GRENADE_WHILE_USING_GUN(  )
	{
		PLAYER::DISABLE_PLAYER_THROW_GRENADE_WHILE_USING_GUN();
	}

	void LUA_NATIVE_PLAYER_SET_DISABLE_AMBIENT_MELEE_MOVE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_DISABLE_AMBIENT_MELEE_MOVE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MAX_ARMOUR( int player, int value) { invoke<void )
	{
		PLAYER::SET_PLAYER_MAX_ARMOUR(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_ACTIVATE( int player, int p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_ACTIVATE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_SPECIAL_ABILITY_MP( int player, int p1, Any p2) { invoke<void )
	{
		PLAYER::SET_SPECIAL_ABILITY_MP(player, p1, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_DEACTIVATE_MP( int player, int p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_DEACTIVATE_MP(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_DEACTIVATE( int player, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_DEACTIVATE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_DEACTIVATE_FAST( int player, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_DEACTIVATE_FAST(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_RESET( int player, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_RESET(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_ON_MISSION_FAILED( int player, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_ON_MISSION_FAILED(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_SMALL( int player, bool p1, bool p2, Any p3) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_SMALL(player, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_MEDIUM( int player, bool p1, bool p2, Any p3) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_MEDIUM(player, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_LARGE( int player, bool p1, bool p2, Any p3) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_LARGE(player, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_CONTINUOUS( int player, int p1, Any p2) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_CONTINUOUS(player, p1, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_ABSOLUTE( int player, int p1, bool p2, Any p3) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_ABSOLUTE(player, p1, p2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_CHARGE_NORMALIZED( int player, float normalizedValue, bool p2, Any p3) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_CHARGE_NORMALIZED(player, normalizedValue, p2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_FILL_METER( int player, bool p1, Any p2) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_FILL_METER(player, p1, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_DEPLETE_METER( int player, bool p1, Any p2) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_DEPLETE_METER(player, p1, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_LOCK( unsigned playerModel, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_LOCK(playerModel, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SPECIAL_ABILITY_UNLOCK( unsigned playerModel, Any p1) { invoke<void )
	{
		PLAYER::SPECIAL_ABILITY_UNLOCK(playerModel, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_SPECIAL_ABILITY_UNLOCKED( unsigned playerModel) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_SPECIAL_ABILITY_UNLOCKED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_SPECIAL_ABILITY_ACTIVE( int player, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_SPECIAL_ABILITY_ACTIVE(player, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_SPECIAL_ABILITY_METER_FULL( int player, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_SPECIAL_ABILITY_METER_FULL(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_ENABLE_SPECIAL_ABILITY( int player, bool toggle, Any p2) { invoke<void )
	{
		PLAYER::ENABLE_SPECIAL_ABILITY(player, toggle, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_SPECIAL_ABILITY_ENABLED( int player, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_SPECIAL_ABILITY_ENABLED(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_SPECIAL_ABILITY_MULTIPLIER( float multiplier) { invoke<void )
	{
		PLAYER::SET_SPECIAL_ABILITY_MULTIPLIER(invoke<void);
	}

	void LUA_NATIVE_PLAYER_UPDATE_SPECIAL_ABILITY_FROM_STAT( int player, Any p1) { invoke<void )
	{
		PLAYER::UPDATE_SPECIAL_ABILITY_FROM_STAT(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_GET_IS_PLAYER_DRIVING_ON_HIGHWAY( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_IS_PLAYER_DRIVING_ON_HIGHWAY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_IS_PLAYER_DRIVING_WRECKLESS( int player, int p1) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_IS_PLAYER_DRIVING_WRECKLESS(player, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_IS_MOPPING_AREA_FREE_IN_FRONT_OF_PLAYER( int player, float p1) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_IS_MOPPING_AREA_FREE_IN_FRONT_OF_PLAYER(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_START_PLAYER_TELEPORT( int player, float x, float y, float z, float heading, bool p5, bool findCollisionLand, bool p7) { invoke<void )
	{
		PLAYER::START_PLAYER_TELEPORT(player, x, y, z, heading, p5, findCollisionLand, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_UPDATE_PLAYER_TELEPORT( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::UPDATE_PLAYER_TELEPORT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_STOP_PLAYER_TELEPORT(  )
	{
		PLAYER::STOP_PLAYER_TELEPORT();
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_TELEPORT_ACTIVE(  )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_TELEPORT_ACTIVE();
		return retval;
	}

	float LUA_NATIVE_PLAYER_GET_PLAYER_CURRENT_STEALTH_NOISE( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_PLAYER_CURRENT_STEALTH_NOISE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_HEALTH_RECHARGE_MULTIPLIER( int player, float regenRate) { invoke<void )
	{
		PLAYER::SET_PLAYER_HEALTH_RECHARGE_MULTIPLIER(player, invoke<void);
	}

	float LUA_NATIVE_PLAYER_GET_PLAYER_HEALTH_RECHARGE_MAX_PERCENT( int player) { return invoke<float )
	{
		auto retval = PLAYER::GET_PLAYER_HEALTH_RECHARGE_MAX_PERCENT(invoke<float);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_HEALTH_RECHARGE_MAX_PERCENT( int player, float limit) { invoke<void )
	{
		PLAYER::SET_PLAYER_HEALTH_RECHARGE_MAX_PERCENT(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_DISABLE_PLAYER_HEALTH_RECHARGE( int player) { invoke<void )
	{
		PLAYER::DISABLE_PLAYER_HEALTH_RECHARGE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_FALL_DISTANCE_TO_TRIGGER_RAGDOLL_OVERRIDE( int player, float p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_FALL_DISTANCE_TO_TRIGGER_RAGDOLL_OVERRIDE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WEAPON_DAMAGE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_WEAPON_DAMAGE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WEAPON_DEFENSE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_WEAPON_DEFENSE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WEAPON_MINIGUN_DEFENSE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_WEAPON_MINIGUN_DEFENSE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MELEE_WEAPON_DAMAGE_MODIFIER( int player, float modifier, bool p2) { invoke<void )
	{
		PLAYER::SET_PLAYER_MELEE_WEAPON_DAMAGE_MODIFIER(player, modifier, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MELEE_WEAPON_DEFENSE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_MELEE_WEAPON_DEFENSE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_VEHICLE_DAMAGE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_VEHICLE_DAMAGE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_VEHICLE_DEFENSE_MODIFIER( int player, float modifier) { invoke<void )
	{
		PLAYER::SET_PLAYER_VEHICLE_DEFENSE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_MAX_EXPLOSIVE_DAMAGE( int player, float p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_MAX_EXPLOSIVE_DAMAGE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_EXPLOSIVE_DAMAGE_MODIFIER( int player, Any p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_EXPLOSIVE_DAMAGE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_WEAPON_TAKEDOWN_DEFENSE_MODIFIER( int player, float p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_WEAPON_TAKEDOWN_DEFENSE_MODIFIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_TINT_INDEX( int player, int tintIndex) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_TINT_INDEX(player, invoke<void);
	}

	int tintIndex) { LUA_NATIVE_PLAYER_GET_PLAYER_PARACHUTE_TINT_INDEX( int player, int tintIndex) { invoke<void )
	{
		PLAYER::GET_PLAYER_PARACHUTE_TINT_INDEX(player, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_RESERVE_PARACHUTE_TINT_INDEX( int player, int index) { invoke<void )
	{
		PLAYER::SET_PLAYER_RESERVE_PARACHUTE_TINT_INDEX(player, invoke<void);
	}

	int index) { LUA_NATIVE_PLAYER_GET_PLAYER_RESERVE_PARACHUTE_TINT_INDEX( int player, int index) { invoke<void )
	{
		PLAYER::GET_PLAYER_RESERVE_PARACHUTE_TINT_INDEX(player, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_PACK_TINT_INDEX( int player, int tintIndex) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_PACK_TINT_INDEX(player, invoke<void);
	}

	int tintIndex) { LUA_NATIVE_PLAYER_GET_PLAYER_PARACHUTE_PACK_TINT_INDEX( int player, int tintIndex) { invoke<void )
	{
		PLAYER::GET_PLAYER_PARACHUTE_PACK_TINT_INDEX(player, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_HAS_RESERVE_PARACHUTE( int player) { invoke<void )
	{
		PLAYER::SET_PLAYER_HAS_RESERVE_PARACHUTE(invoke<void);
	}

	bool LUA_NATIVE_PLAYER_GET_PLAYER_HAS_RESERVE_PARACHUTE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_PLAYER_HAS_RESERVE_PARACHUTE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_LEAVE_PARACHUTE_SMOKE_TRAIL( int player, bool enabled) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_LEAVE_PARACHUTE_SMOKE_TRAIL(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_SMOKE_TRAIL_COLOR( int player, int r, int g, int b) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_SMOKE_TRAIL_COLOR(player, r, g, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_PLAYER_GET_PLAYER_PARACHUTE_SMOKE_TRAIL_COLOR( int player, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		PLAYER::GET_PLAYER_PARACHUTE_SMOKE_TRAIL_COLOR(player, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PHONE_PALETTE_IDX( int player, int flags) { invoke<void )
	{
		PLAYER::SET_PLAYER_PHONE_PALETTE_IDX(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_NOISE_MULTIPLIER( int player, float multiplier) { invoke<void )
	{
		PLAYER::SET_PLAYER_NOISE_MULTIPLIER(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_SNEAKING_NOISE_MULTIPLIER( int player, float multiplier) { invoke<void )
	{
		PLAYER::SET_PLAYER_SNEAKING_NOISE_MULTIPLIER(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_CAN_PED_HEAR_PLAYER( int player, int ped) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::CAN_PED_HEAR_PLAYER(player, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SIMULATE_PLAYER_INPUT_GAIT( int player, float amount, int gaitType, float speed, bool p4, bool p5, Any p6) { invoke<void )
	{
		PLAYER::SIMULATE_PLAYER_INPUT_GAIT(player, amount, gaitType, speed, p4, p5, invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_PLAYER_INPUT_GAIT( int player) { invoke<void )
	{
		PLAYER::RESET_PLAYER_INPUT_GAIT(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_AUTO_GIVE_PARACHUTE_WHEN_ENTER_PLANE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_AUTO_GIVE_PARACHUTE_WHEN_ENTER_PLANE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_AUTO_GIVE_SCUBA_GEAR_WHEN_EXIT_VEHICLE( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_AUTO_GIVE_SCUBA_GEAR_WHEN_EXIT_VEHICLE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_STEALTH_PERCEPTION_MODIFIER( int player, float value) { invoke<void )
	{
		PLAYER::SET_PLAYER_STEALTH_PERCEPTION_MODIFIER(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_REMOTE_PLAYER_IN_NON_CLONED_VEHICLE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_REMOTE_PLAYER_IN_NON_CLONED_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_INCREASE_PLAYER_JUMP_SUPPRESSION_RANGE( int player) { invoke<void )
	{
		PLAYER::INCREASE_PLAYER_JUMP_SUPPRESSION_RANGE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_SIMULATE_AIMING( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_SIMULATE_AIMING(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CLOTH_PIN_FRAMES( int player, int p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_CLOTH_PIN_FRAMES(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CLOTH_PACKAGE_INDEX( int index) { invoke<void )
	{
		PLAYER::SET_PLAYER_CLOTH_PACKAGE_INDEX(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CLOTH_LOCK_COUNTER( int value) { invoke<void )
	{
		PLAYER::SET_PLAYER_CLOTH_LOCK_COUNTER(invoke<void);
	}

	void LUA_NATIVE_PLAYER_PLAYER_ATTACH_VIRTUAL_BOUND( float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7) { invoke<void )
	{
		PLAYER::PLAYER_ATTACH_VIRTUAL_BOUND(p0, p1, p2, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_PLAYER_PLAYER_DETACH_VIRTUAL_BOUND(  )
	{
		PLAYER::PLAYER_DETACH_VIRTUAL_BOUND();
	}

	bool LUA_NATIVE_PLAYER_HAS_PLAYER_BEEN_SPOTTED_IN_STOLEN_VEHICLE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_PLAYER_BEEN_SPOTTED_IN_STOLEN_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_BATTLE_AWARE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_BATTLE_AWARE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_GET_PLAYER_RECEIVED_BATTLE_EVENT_RECENTLY( int player, int p1, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::GET_PLAYER_RECEIVED_BATTLE_EVENT_RECENTLY(player, p1, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_EXTEND_WORLD_BOUNDARY_FOR_PLAYER( float x, float y, float z) { invoke<void )
	{
		PLAYER::EXTEND_WORLD_BOUNDARY_FOR_PLAYER(x, y, invoke<void);
	}

	void LUA_NATIVE_PLAYER_RESET_WORLD_BOUNDARY_FOR_PLAYER(  )
	{
		PLAYER::RESET_WORLD_BOUNDARY_FOR_PLAYER();
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_RIDING_TRAIN( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_RIDING_TRAIN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_PLAYER_HAS_PLAYER_LEFT_THE_WORLD( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::HAS_PLAYER_LEFT_THE_WORLD(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_LEAVE_PED_BEHIND( int player, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_LEAVE_PED_BEHIND(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_VARIATION_OVERRIDE( int player, int p1, Any p2, Any p3, bool p4) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_VARIATION_OVERRIDE(player, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_PARACHUTE_VARIATION_OVERRIDE( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_PARACHUTE_VARIATION_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_MODEL_OVERRIDE( int player, unsigned model) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_MODEL_OVERRIDE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE( int player, unsigned model) { invoke<void )
	{
		PLAYER::SET_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE(player, invoke<void);
	}

	unsigned LUA_NATIVE_PLAYER_GET_PLAYER_PARACHUTE_MODEL_OVERRIDE( int player) { return invoke<unsigned )
	{
		auto retval = PLAYER::GET_PLAYER_PARACHUTE_MODEL_OVERRIDE(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_PLAYER_GET_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE( int player) { return invoke<unsigned )
	{
		auto retval = PLAYER::GET_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_PARACHUTE_MODEL_OVERRIDE( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_PARACHUTE_MODEL_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_RESERVE_PARACHUTE_MODEL_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PARACHUTE_PACK_MODEL_OVERRIDE( int player, unsigned model) { invoke<void )
	{
		PLAYER::SET_PLAYER_PARACHUTE_PACK_MODEL_OVERRIDE(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_CLEAR_PLAYER_PARACHUTE_PACK_MODEL_OVERRIDE( int player) { invoke<void )
	{
		PLAYER::CLEAR_PLAYER_PARACHUTE_PACK_MODEL_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_DISABLE_PLAYER_VEHICLE_REWARDS( int player) { invoke<void )
	{
		PLAYER::DISABLE_PLAYER_VEHICLE_REWARDS(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_SPECTATED_VEHICLE_RADIO_OVERRIDE( bool p0) { invoke<void )
	{
		PLAYER::SET_PLAYER_SPECTATED_VEHICLE_RADIO_OVERRIDE(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_BLUETOOTH_STATE( int player, bool state) { invoke<void )
	{
		PLAYER::SET_PLAYER_BLUETOOTH_STATE(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_BLUETOOTH_ENABLE( int player) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_BLUETOOTH_ENABLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_DISABLE_CAMERA_VIEW_MODE_CYCLE( int player) { invoke<void )
	{
		PLAYER::DISABLE_CAMERA_VIEW_MODE_CYCLE(invoke<void);
	}

	int LUA_NATIVE_PLAYER_GET_PLAYER_FAKE_WANTED_LEVEL( int player) { return invoke<int )
	{
		auto retval = PLAYER::GET_PLAYER_FAKE_WANTED_LEVEL(invoke<int);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_CAN_DAMAGE_PLAYER( int player1, int player2, bool toggle) { invoke<void )
	{
		PLAYER::SET_PLAYER_CAN_DAMAGE_PLAYER(player1, player2, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_APPLY_WAYPOINT_OF_PLAYER( int player, int hudColor) { invoke<void )
	{
		PLAYER::SET_APPLY_WAYPOINT_OF_PLAYER(player, invoke<void);
	}

	bool LUA_NATIVE_PLAYER_IS_PLAYER_VEHICLE_WEAPON_TOGGLED_TO_NON_HOMING( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)PLAYER::IS_PLAYER_VEHICLE_WEAPON_TOGGLED_TO_NON_HOMING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_VEHICLE_WEAPON_TO_NON_HOMING( Any p0) { invoke<void )
	{
		PLAYER::SET_PLAYER_VEHICLE_WEAPON_TO_NON_HOMING(invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_HOMING_DISABLED_FOR_ALL_VEHICLE_WEAPONS( Any p0, Any p1) { invoke<void )
	{
		PLAYER::SET_PLAYER_HOMING_DISABLED_FOR_ALL_VEHICLE_WEAPONS(p0, invoke<void);
	}

	void LUA_NATIVE_PLAYER_ADD_PLAYER_TARGETABLE_ENTITY( int player, int entity) { invoke<void )
	{
		PLAYER::ADD_PLAYER_TARGETABLE_ENTITY(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_REMOVE_PLAYER_TARGETABLE_ENTITY( int player, int entity) { invoke<void )
	{
		PLAYER::REMOVE_PLAYER_TARGETABLE_ENTITY(player, invoke<void);
	}

	void LUA_NATIVE_PLAYER_SET_PLAYER_PREVIOUS_VARIATION_DATA( int player, int p1, int p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		PLAYER::SET_PLAYER_PREVIOUS_VARIATION_DATA(player, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_PLAYER_REMOVE_SCRIPT_FIRE_POSITION(  )
	{
		PLAYER::REMOVE_SCRIPT_FIRE_POSITION();
	}

	void LUA_NATIVE_PLAYER_SET_SCRIPT_FIRE_POSITION( float coordX, float coordY, float coordZ) { invoke<void )
	{
		PLAYER::SET_SCRIPT_FIRE_POSITION(coordX, coordY, invoke<void);
	}

	void LUA_NATIVE_RECORDING_REPLAY_START_EVENT( int p0) { invoke<void )
	{
		RECORDING::REPLAY_START_EVENT(invoke<void);
	}

	void LUA_NATIVE_RECORDING_REPLAY_STOP_EVENT(  )
	{
		RECORDING::REPLAY_STOP_EVENT();
	}

	void LUA_NATIVE_RECORDING_REPLAY_CANCEL_EVENT(  )
	{
		RECORDING::REPLAY_CANCEL_EVENT();
	}

	void LUA_NATIVE_RECORDING_REPLAY_RECORD_BACK_FOR_TIME( float p0, float p1, int p2) { invoke<void )
	{
		RECORDING::REPLAY_RECORD_BACK_FOR_TIME(p0, p1, invoke<void);
	}

	void LUA_NATIVE_RECORDING_REPLAY_CHECK_FOR_EVENT_THIS_FRAME( const char* missionNameLabel, Any p1) { invoke<void )
	{
		RECORDING::REPLAY_CHECK_FOR_EVENT_THIS_FRAME(missionNameLabel, invoke<void);
	}

	void LUA_NATIVE_RECORDING_REPLAY_PREVENT_RECORDING_THIS_FRAME(  )
	{
		RECORDING::REPLAY_PREVENT_RECORDING_THIS_FRAME();
	}

	void LUA_NATIVE_RECORDING_REPLAY_RESET_EVENT_INFO(  )
	{
		RECORDING::REPLAY_RESET_EVENT_INFO();
	}

	void LUA_NATIVE_RECORDING_REPLAY_DISABLE_CAMERA_MOVEMENT_THIS_FRAME(  )
	{
		RECORDING::REPLAY_DISABLE_CAMERA_MOVEMENT_THIS_FRAME();
	}

	void LUA_NATIVE_RECORDING_RECORD_GREATEST_MOMENT( int p0, int p1, int p2) { invoke<void )
	{
		RECORDING::RECORD_GREATEST_MOMENT(p0, p1, invoke<void);
	}

	void LUA_NATIVE_RECORDING_START_REPLAY_RECORDING( int mode) { invoke<void )
	{
		RECORDING::START_REPLAY_RECORDING(invoke<void);
	}

	void LUA_NATIVE_RECORDING_STOP_REPLAY_RECORDING(  )
	{
		RECORDING::STOP_REPLAY_RECORDING();
	}

	void LUA_NATIVE_RECORDING_CANCEL_REPLAY_RECORDING(  )
	{
		RECORDING::CANCEL_REPLAY_RECORDING();
	}

	bool LUA_NATIVE_RECORDING_SAVE_REPLAY_RECORDING(  )
	{
		auto retval = (bool)RECORDING::SAVE_REPLAY_RECORDING();
		return retval;
	}

	bool LUA_NATIVE_RECORDING_IS_REPLAY_RECORDING(  )
	{
		auto retval = (bool)RECORDING::IS_REPLAY_RECORDING();
		return retval;
	}

	bool LUA_NATIVE_RECORDING_IS_REPLAY_INITIALIZED(  )
	{
		auto retval = (bool)RECORDING::IS_REPLAY_INITIALIZED();
		return retval;
	}

	bool LUA_NATIVE_RECORDING_IS_REPLAY_AVAILABLE(  )
	{
		auto retval = (bool)RECORDING::IS_REPLAY_AVAILABLE();
		return retval;
	}

	bool LUA_NATIVE_RECORDING_IS_REPLAY_RECORD_SPACE_AVAILABLE( bool p0) { return invoke<BOOL )
	{
		auto retval = (bool)RECORDING::IS_REPLAY_RECORD_SPACE_AVAILABLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_REPLAY_REGISTER_EFFECT_FOR_REPLAY_EDITOR( const char* p0, bool p1) { invoke<void )
	{
		REPLAY::REGISTER_EFFECT_FOR_REPLAY_EDITOR(p0, invoke<void);
	}

	bool LUA_NATIVE_REPLAY_REPLAY_SYSTEM_HAS_REQUESTED_A_SCRIPT_CLEANUP(  )
	{
		auto retval = (bool)REPLAY::REPLAY_SYSTEM_HAS_REQUESTED_A_SCRIPT_CLEANUP();
		return retval;
	}

	void LUA_NATIVE_REPLAY_SET_SCRIPTS_HAVE_CLEANED_UP_FOR_REPLAY_SYSTEM(  )
	{
		REPLAY::SET_SCRIPTS_HAVE_CLEANED_UP_FOR_REPLAY_SYSTEM();
	}

	void LUA_NATIVE_REPLAY_SET_REPLAY_SYSTEM_PAUSED_FOR_SAVE( bool p0) { invoke<void )
	{
		REPLAY::SET_REPLAY_SYSTEM_PAUSED_FOR_SAVE(invoke<void);
	}

	void LUA_NATIVE_REPLAY_REPLAY_CONTROL_SHUTDOWN(  )
	{
		REPLAY::REPLAY_CONTROL_SHUTDOWN();
	}

	void LUA_NATIVE_REPLAY_ACTIVATE_ROCKSTAR_EDITOR( int p0) { invoke<void )
	{
		REPLAY::ACTIVATE_ROCKSTAR_EDITOR(invoke<void);
	}

	bool LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_IS_MP_ENABLED(  )
	{
		auto retval = (bool)SAVEMIGRATION::SAVEMIGRATION_IS_MP_ENABLED();
		return retval;
	}

	bool LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_REQUEST_ACCOUNTS(  )
	{
		auto retval = (bool)SAVEMIGRATION::SAVEMIGRATION_MP_REQUEST_ACCOUNTS();
		return retval;
	}

	int LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_GET_ACCOUNTS_STATUS(  )
	{
		auto retval = SAVEMIGRATION::SAVEMIGRATION_MP_GET_ACCOUNTS_STATUS();
		return retval;
	}

	int LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_NUM_ACCOUNTS(  )
	{
		auto retval = SAVEMIGRATION::SAVEMIGRATION_MP_NUM_ACCOUNTS();
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_GET_ACCOUNT( int p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)SAVEMIGRATION::SAVEMIGRATION_MP_GET_ACCOUNT(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_REQUEST_STATUS(  )
	{
		auto retval = (bool)SAVEMIGRATION::SAVEMIGRATION_MP_REQUEST_STATUS();
		return retval;
	}

	int LUA_NATIVE_SAVEMIGRATION_SAVEMIGRATION_MP_GET_STATUS(  )
	{
		auto retval = SAVEMIGRATION::SAVEMIGRATION_MP_GET_STATUS();
		return retval;
	}

	void LUA_NATIVE_SCRIPT_REQUEST_SCRIPT( const char* scriptName) { invoke<void )
	{
		SCRIPT::REQUEST_SCRIPT(invoke<void);
	}

	void LUA_NATIVE_SCRIPT_SET_SCRIPT_AS_NO_LONGER_NEEDED( const char* scriptName) { invoke<void )
	{
		SCRIPT::SET_SCRIPT_AS_NO_LONGER_NEEDED(invoke<void);
	}

	bool LUA_NATIVE_SCRIPT_HAS_SCRIPT_LOADED( const char* scriptName) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::HAS_SCRIPT_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SCRIPT_DOES_SCRIPT_EXIST( const char* scriptName) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::DOES_SCRIPT_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_SCRIPT_REQUEST_SCRIPT_WITH_NAME_HASH( unsigned scriptHash) { invoke<void )
	{
		SCRIPT::REQUEST_SCRIPT_WITH_NAME_HASH(invoke<void);
	}

	void LUA_NATIVE_SCRIPT_SET_SCRIPT_WITH_NAME_HASH_AS_NO_LONGER_NEEDED( unsigned scriptHash) { invoke<void )
	{
		SCRIPT::SET_SCRIPT_WITH_NAME_HASH_AS_NO_LONGER_NEEDED(invoke<void);
	}

	bool LUA_NATIVE_SCRIPT_HAS_SCRIPT_WITH_NAME_HASH_LOADED( unsigned scriptHash) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::HAS_SCRIPT_WITH_NAME_HASH_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SCRIPT_DOES_SCRIPT_WITH_NAME_HASH_EXIST( unsigned scriptHash) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::DOES_SCRIPT_WITH_NAME_HASH_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_SCRIPT_TERMINATE_THREAD( int threadId) { invoke<void )
	{
		SCRIPT::TERMINATE_THREAD(invoke<void);
	}

	bool LUA_NATIVE_SCRIPT_IS_THREAD_ACTIVE( int threadId) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::IS_THREAD_ACTIVE(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_SCRIPT_GET_NAME_OF_SCRIPT_WITH_THIS_ID( int threadId) { return invoke<const char* )
	{
		auto retval = SCRIPT::GET_NAME_OF_SCRIPT_WITH_THIS_ID(char*);
		return retval;
	}

	void LUA_NATIVE_SCRIPT_SCRIPT_THREAD_ITERATOR_RESET(  )
	{
		SCRIPT::SCRIPT_THREAD_ITERATOR_RESET();
	}

	int LUA_NATIVE_SCRIPT_SCRIPT_THREAD_ITERATOR_GET_NEXT_THREAD_ID(  )
	{
		auto retval = SCRIPT::SCRIPT_THREAD_ITERATOR_GET_NEXT_THREAD_ID();
		return retval;
	}

	int LUA_NATIVE_SCRIPT_GET_ID_OF_THIS_THREAD(  )
	{
		auto retval = SCRIPT::GET_ID_OF_THIS_THREAD();
		return retval;
	}

	void LUA_NATIVE_SCRIPT_TERMINATE_THIS_THREAD(  )
	{
		SCRIPT::TERMINATE_THIS_THREAD();
	}

	int LUA_NATIVE_SCRIPT_GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH( unsigned scriptHash) { return invoke<int )
	{
		auto retval = SCRIPT::GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_SCRIPT_GET_THIS_SCRIPT_NAME(  )
	{
		auto retval = SCRIPT::GET_THIS_SCRIPT_NAME();
		return retval;
	}

	unsigned LUA_NATIVE_SCRIPT_GET_HASH_OF_THIS_SCRIPT_NAME(  )
	{
		auto retval = SCRIPT::GET_HASH_OF_THIS_SCRIPT_NAME();
		return retval;
	}

	int LUA_NATIVE_SCRIPT_GET_NUMBER_OF_EVENTS( int eventGroup) { return invoke<int )
	{
		auto retval = SCRIPT::GET_NUMBER_OF_EVENTS(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_SCRIPT_GET_EVENT_EXISTS( int eventGroup, int eventIndex) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::GET_EVENT_EXISTS(eventGroup, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SCRIPT_GET_EVENT_AT_INDEX( int eventGroup, int eventIndex) { return invoke<int )
	{
		auto retval = SCRIPT::GET_EVENT_AT_INDEX(eventGroup, invoke<int);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_SCRIPT_GET_EVENT_DATA( int eventGroup, int eventIndex, Any eventData, int eventDataSize) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)SCRIPT::GET_EVENT_DATA(eventGroup, eventIndex, &eventData, invoke<BOOL);
		std::get<1>(return_values) = eventData;

		return return_values;
	}

	Any LUA_NATIVE_SCRIPT_TRIGGER_SCRIPT_EVENT( int eventGroup, Any eventData, int eventDataSize, int playerBits) { invoke<void )
	{
		SCRIPT::TRIGGER_SCRIPT_EVENT(eventGroup, &eventData, eventDataSize, invoke<void);
		return eventData;
	}

	void LUA_NATIVE_SCRIPT_SHUTDOWN_LOADING_SCREEN(  )
	{
		SCRIPT::SHUTDOWN_LOADING_SCREEN();
	}

	void LUA_NATIVE_SCRIPT_SET_NO_LOADING_SCREEN( bool toggle) { invoke<void )
	{
		SCRIPT::SET_NO_LOADING_SCREEN(invoke<void);
	}

	bool LUA_NATIVE_SCRIPT_GET_NO_LOADING_SCREEN(  )
	{
		auto retval = (bool)SCRIPT::GET_NO_LOADING_SCREEN();
		return retval;
	}

	void LUA_NATIVE_SCRIPT_COMMIT_TO_LOADINGSCREEN_SELCTION(  )
	{
		SCRIPT::COMMIT_TO_LOADINGSCREEN_SELCTION();
	}

	bool LUA_NATIVE_SCRIPT_BG_IS_EXITFLAG_SET(  )
	{
		auto retval = (bool)SCRIPT::BG_IS_EXITFLAG_SET();
		return retval;
	}

	void LUA_NATIVE_SCRIPT_BG_SET_EXITFLAG_RESPONSE(  )
	{
		SCRIPT::BG_SET_EXITFLAG_RESPONSE();
	}

	void LUA_NATIVE_SCRIPT_BG_START_CONTEXT_HASH( unsigned contextHash) { invoke<void )
	{
		SCRIPT::BG_START_CONTEXT_HASH(invoke<void);
	}

	void LUA_NATIVE_SCRIPT_BG_END_CONTEXT_HASH( unsigned contextHash) { invoke<void )
	{
		SCRIPT::BG_END_CONTEXT_HASH(invoke<void);
	}

	void LUA_NATIVE_SCRIPT_BG_START_CONTEXT( const char* contextName) { invoke<void )
	{
		SCRIPT::BG_START_CONTEXT(invoke<void);
	}

	void LUA_NATIVE_SCRIPT_BG_END_CONTEXT( const char* contextName) { invoke<void )
	{
		SCRIPT::BG_END_CONTEXT(invoke<void);
	}

	bool LUA_NATIVE_SCRIPT_BG_DOES_LAUNCH_PARAM_EXIST( int scriptIndex, const char* p1) { return invoke<BOOL )
	{
		auto retval = (bool)SCRIPT::BG_DOES_LAUNCH_PARAM_EXIST(scriptIndex, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SCRIPT_BG_GET_LAUNCH_PARAM_VALUE( int scriptIndex, const char* p1) { return invoke<int )
	{
		auto retval = SCRIPT::BG_GET_LAUNCH_PARAM_VALUE(scriptIndex, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SCRIPT_BG_GET_SCRIPT_ID_FROM_NAME_HASH( unsigned p0) { return invoke<int )
	{
		auto retval = SCRIPT::BG_GET_SCRIPT_ID_FROM_NAME_HASH(invoke<int);
		return retval;
	}

	Any LUA_NATIVE_SCRIPT_SEND_TU_SCRIPT_EVENT( int eventGroup, Any eventData, int eventDataSize, int playerBits) { invoke<void )
	{
		SCRIPT::SEND_TU_SCRIPT_EVENT(eventGroup, &eventData, eventDataSize, invoke<void);
		return eventData;
	}

	Any variable) { LUA_NATIVE_SECURITY_REGISTER_SCRIPT_VARIABLE( Any variable) { invoke<void )
	{
		SECURITY::REGISTER_SCRIPT_VARIABLE(&invoke<void);
		return invoke<void;
	}

	Any variable) { LUA_NATIVE_SECURITY_UNREGISTER_SCRIPT_VARIABLE( Any variable) { invoke<void )
	{
		SECURITY::UNREGISTER_SCRIPT_VARIABLE(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_SECURITY_FORCE_CHECK_SCRIPT_VARIABLES(  )
	{
		SECURITY::FORCE_CHECK_SCRIPT_VARIABLES();
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_LOS_PROBE( float x1, float y1, float z1, float x2, float y2, float z2, int flags, int entity, int p8) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_LOS_PROBE(x1, y1, z1, x2, y2, z2, flags, entity, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_EXPENSIVE_SYNCHRONOUS_SHAPE_TEST_LOS_PROBE( float x1, float y1, float z1, float x2, float y2, float z2, int flags, int entity, int p8) { return invoke<int )
	{
		auto retval = SHAPETEST::START_EXPENSIVE_SYNCHRONOUS_SHAPE_TEST_LOS_PROBE(x1, y1, z1, x2, y2, z2, flags, entity, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_BOUNDING_BOX( int entity, int flags1, int flags2) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_BOUNDING_BOX(entity, flags1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_BOX( float x, float y, float z, float dimX, float dimY, float dimZ, float rotX, float rotY, float rotZ, Any p9, int flags, int entity, Any p12) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_BOX(x, y, z, dimX, dimY, dimZ, rotX, rotY, rotZ, p9, flags, entity, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_BOUND( int entity, int flags1, int flags2) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_BOUND(entity, flags1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_CAPSULE( float x1, float y1, float z1, float x2, float y2, float z2, float radius, int flags, int entity, int p9) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_CAPSULE(x1, y1, z1, x2, y2, z2, radius, flags, entity, invoke<int);
		return retval;
	}

	int LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_SWEPT_SPHERE( float x1, float y1, float z1, float x2, float y2, float z2, float radius, int flags, int entity, Any p9) { return invoke<int )
	{
		auto retval = SHAPETEST::START_SHAPE_TEST_SWEPT_SPHERE(x1, y1, z1, x2, y2, z2, radius, flags, entity, invoke<int);
		return retval;
	}

	std::tuple<int, Vector3, Vector3> LUA_NATIVE_SHAPETEST_START_SHAPE_TEST_MOUSE_CURSOR_LOS_PROBE( Vector3 pVec1, Vector3 pVec2, int flag, int entity, int flag2) { return invoke<int )
	{
		std::tuple<int, Vector3, Vector3> return_values;
		std::get<0>(return_values) = SHAPETEST::START_SHAPE_TEST_MOUSE_CURSOR_LOS_PROBE(&pVec1, &pVec2, flag, entity, invoke<int);
		std::get<1>(return_values) = pVec1;
		std::get<2>(return_values) = pVec2;

		return return_values;
	}

	std::tuple<int, bool, Vector3, Vector3, int entityHit) { return> LUA_NATIVE_SHAPETEST_GET_SHAPE_TEST_RESULT( int shapeTestHandle, bool hit, Vector3 endCoords, Vector3 surfaceNormal, int entityHit) { return invoke<int )
	{
		std::tuple<int, bool, Vector3, Vector3, int entityHit) { return> return_values;
		std::get<0>(return_values) = SHAPETEST::GET_SHAPE_TEST_RESULT(shapeTestHandle, (BOOL*)&hit, &endCoords, &surfaceNormal, &invoke<int);
		std::get<1>(return_values) = hit;
		std::get<2>(return_values) = endCoords;
		std::get<3>(return_values) = surfaceNormal;
		std::get<4>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, bool, Vector3, Vector3, unsigned, int entityHit) { return> LUA_NATIVE_SHAPETEST_GET_SHAPE_TEST_RESULT_INCLUDING_MATERIAL( int shapeTestHandle, bool hit, Vector3 endCoords, Vector3 surfaceNormal, unsigned materialHash, int entityHit) { return invoke<int )
	{
		std::tuple<int, bool, Vector3, Vector3, unsigned, int entityHit) { return> return_values;
		std::get<0>(return_values) = SHAPETEST::GET_SHAPE_TEST_RESULT_INCLUDING_MATERIAL(shapeTestHandle, (BOOL*)&hit, &endCoords, &surfaceNormal, &materialHash, &invoke<int);
		std::get<1>(return_values) = hit;
		std::get<2>(return_values) = endCoords;
		std::get<3>(return_values) = surfaceNormal;
		std::get<4>(return_values) = materialHash;
		std::get<5>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_SHAPETEST_RELEASE_SCRIPT_GUID_FROM_ENTITY( int entityHit) { invoke<void )
	{
		SHAPETEST::RELEASE_SCRIPT_GUID_FROM_ENTITY(invoke<void);
	}

	int LUA_NATIVE_SOCIALCLUB_SC_INBOX_GET_TOTAL_NUM_MESSAGES(  )
	{
		auto retval = SOCIALCLUB::SC_INBOX_GET_TOTAL_NUM_MESSAGES();
		return retval;
	}

	unsigned LUA_NATIVE_SOCIALCLUB_SC_INBOX_GET_MESSAGE_TYPE_AT_INDEX( int msgIndex) { return invoke<unsigned )
	{
		auto retval = SOCIALCLUB::SC_INBOX_GET_MESSAGE_TYPE_AT_INDEX(invoke<unsigned);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_INBOX_GET_MESSAGE_IS_READ_AT_INDEX( int msgIndex) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_INBOX_GET_MESSAGE_IS_READ_AT_INDEX(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_INBOX_SET_MESSAGE_AS_READ_AT_INDEX( int msgIndex) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_INBOX_SET_MESSAGE_AS_READ_AT_INDEX(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int out) { return> LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_GET_DATA_INT( int p0, const char* context, int out) { return invoke<BOOL )
	{
		std::tuple<bool, int out) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_INBOX_MESSAGE_GET_DATA_INT(p0, context, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_GET_DATA_BOOL( int p0, const char* p1) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_INBOX_MESSAGE_GET_DATA_BOOL(p0, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, char out) { return> LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_GET_DATA_STRING( int p0, const char* context, char out) { return invoke<BOOL )
	{
		std::tuple<bool, char out) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_INBOX_MESSAGE_GET_DATA_STRING(p0, context, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_DO_APPLY( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_INBOX_MESSAGE_DO_APPLY(invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_GET_RAW_TYPE_AT_INDEX( int p0) { return invoke<const char* )
	{
		auto retval = SOCIALCLUB::SC_INBOX_MESSAGE_GET_RAW_TYPE_AT_INDEX(char*);
		return retval;
	}

	Any gamerHandle) { LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_PUSH_GAMER_T0_RECIP_LIST( Any gamerHandle) { invoke<void )
	{
		SOCIALCLUB::SC_INBOX_MESSAGE_PUSH_GAMER_T0_RECIP_LIST(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_SOCIALCLUB_SC_INBOX_SEND_UGCSTATUPDATE_TO_RECIP_LIST( Any data) { invoke<void )
	{
		SOCIALCLUB::SC_INBOX_SEND_UGCSTATUPDATE_TO_RECIP_LIST(&invoke<void);
		return invoke<void;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_SOCIALCLUB_SC_INBOX_MESSAGE_GET_UGCDATA( int p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_INBOX_MESSAGE_GET_UGCDATA(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any data) { return> LUA_NATIVE_SOCIALCLUB_SC_INBOX_SEND_BOUNTY_TO_RECIP_LIST( Any data) { return invoke<BOOL )
	{
		std::tuple<bool, Any data) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_INBOX_SEND_BOUNTY_TO_RECIP_LIST(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_SOCIALCLUB_SC_INBOX_GET_BOUNTY_DATA_AT_INDEX( int index, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_INBOX_GET_BOUNTY_DATA_AT_INDEX(index, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_SOCIALCLUB_SC_EMAIL_RETRIEVE_EMAILS( int offset, int limit) { invoke<void )
	{
		SOCIALCLUB::SC_EMAIL_RETRIEVE_EMAILS(offset, invoke<void);
	}

	int LUA_NATIVE_SOCIALCLUB_SC_EMAIL_GET_RETRIEVAL_STATUS(  )
	{
		auto retval = SOCIALCLUB::SC_EMAIL_GET_RETRIEVAL_STATUS();
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_EMAIL_GET_NUM_RETRIEVED_EMAILS(  )
	{
		auto retval = SOCIALCLUB::SC_EMAIL_GET_NUM_RETRIEVED_EMAILS();
		return retval;
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_SOCIALCLUB_SC_EMAIL_GET_EMAIL_AT_INDEX( int p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_EMAIL_GET_EMAIL_AT_INDEX(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	Any LUA_NATIVE_SOCIALCLUB_SC_EMAIL_DELETE_EMAILS( Any p0, Any p1) { invoke<void )
	{
		SOCIALCLUB::SC_EMAIL_DELETE_EMAILS(&p0, invoke<void);
		return p0;
	}

	Any gamerHandle) { LUA_NATIVE_SOCIALCLUB_SC_EMAIL_MESSAGE_PUSH_GAMER_TO_RECIP_LIST( Any gamerHandle) { invoke<void )
	{
		SOCIALCLUB::SC_EMAIL_MESSAGE_PUSH_GAMER_TO_RECIP_LIST(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_SOCIALCLUB_SC_EMAIL_MESSAGE_CLEAR_RECIP_LIST(  )
	{
		SOCIALCLUB::SC_EMAIL_MESSAGE_CLEAR_RECIP_LIST();
	}

	void LUA_NATIVE_SOCIALCLUB_SC_EMAIL_SEND_EMAIL( const char* p0) { invoke<void )
	{
		SOCIALCLUB::SC_EMAIL_SEND_EMAIL(invoke<void);
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_EMAIL_SET_CURRENT_EMAIL_TAG( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_EMAIL_SET_CURRENT_EMAIL_TAG(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_SOCIALCLUB_SC_CACHE_NEW_ROCKSTAR_MSGS( bool toggle) { invoke<void )
	{
		SOCIALCLUB::SC_CACHE_NEW_ROCKSTAR_MSGS(invoke<void);
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_HAS_NEW_ROCKSTAR_MSG(  )
	{
		auto retval = (bool)SOCIALCLUB::SC_HAS_NEW_ROCKSTAR_MSG();
		return retval;
	}

	const char* LUA_NATIVE_SOCIALCLUB_SC_GET_NEW_ROCKSTAR_MSG(  )
	{
		auto retval = SOCIALCLUB::SC_GET_NEW_ROCKSTAR_MSG();
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PRESENCE_ATTR_SET_INT( unsigned attrHash, int value) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PRESENCE_ATTR_SET_INT(attrHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PRESENCE_ATTR_SET_FLOAT( unsigned attrHash, float value) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PRESENCE_ATTR_SET_FLOAT(attrHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PRESENCE_ATTR_SET_STRING( unsigned attrHash, const char* value) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PRESENCE_ATTR_SET_STRING(attrHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PRESENCE_SET_ACTIVITY_RATING( Any p0, float p1) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PRESENCE_SET_ACTIVITY_RATING(p0, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int value) { return> LUA_NATIVE_SOCIALCLUB_SC_GAMERDATA_GET_INT( const char* name, int value) { return invoke<BOOL )
	{
		std::tuple<bool, int value) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_GAMERDATA_GET_INT(name, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_SOCIALCLUB_SC_GAMERDATA_GET_FLOAT( const char* name, float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_GAMERDATA_GET_FLOAT(name, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_GAMERDATA_GET_BOOL( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_GAMERDATA_GET_BOOL(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, char value) { return> LUA_NATIVE_SOCIALCLUB_SC_GAMERDATA_GET_STRING( const char* name, char value) { return invoke<BOOL )
	{
		std::tuple<bool, char value) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_GAMERDATA_GET_STRING(name, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_SOCIALCLUB_SC_GAMERDATA_GET_ACTIVE_XP_BONUS( float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_GAMERDATA_GET_ACTIVE_XP_BONUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int token) { return> LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_CHECK_STRING( const char* string, int token) { return invoke<BOOL )
	{
		std::tuple<bool, int token) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_PROFANITY_CHECK_STRING(string, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int token) { return> LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_CHECK_STRING_UGC( const char* string, int token) { return invoke<BOOL )
	{
		std::tuple<bool, int token) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_PROFANITY_CHECK_STRING_UGC(string, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_GET_CHECK_IS_VALID( int token) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PROFANITY_GET_CHECK_IS_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_GET_CHECK_IS_PENDING( int token) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PROFANITY_GET_CHECK_IS_PENDING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_GET_STRING_PASSED( int token) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PROFANITY_GET_STRING_PASSED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_PROFANITY_GET_STRING_STATUS( int token) { return invoke<int )
	{
		auto retval = SOCIALCLUB::SC_PROFANITY_GET_STRING_STATUS(invoke<int);
		return retval;
	}

	std::tuple<bool, int p1) { return> LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_CHECK_STRING( const char* p0, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, int p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_LICENSEPLATE_CHECK_STRING(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_CHECK_IS_VALID( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_LICENSEPLATE_GET_CHECK_IS_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_CHECK_IS_PENDING( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_LICENSEPLATE_GET_CHECK_IS_PENDING(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_COUNT( int token) { return invoke<int )
	{
		auto retval = SOCIALCLUB::SC_LICENSEPLATE_GET_COUNT(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_PLATE( int token, int plateIndex) { return invoke<const char* )
	{
		auto retval = SOCIALCLUB::SC_LICENSEPLATE_GET_PLATE(token, char*);
		return retval;
	}

	const char* LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_PLATE_DATA( int token, int plateIndex) { return invoke<const char* )
	{
		auto retval = SOCIALCLUB::SC_LICENSEPLATE_GET_PLATE_DATA(token, char*);
		return retval;
	}

	std::tuple<bool, Any plateData) { return> LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_SET_PLATE_DATA( const char* oldPlateText, const char* newPlateText, Any plateData) { return invoke<BOOL )
	{
		std::tuple<bool, Any plateData) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_LICENSEPLATE_SET_PLATE_DATA(oldPlateText, newPlateText, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any, int token) { return> LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_ADD( const char* plateText, Any plateData, int token) { return invoke<BOOL )
	{
		std::tuple<bool, Any, int token) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_LICENSEPLATE_ADD(plateText, &plateData, &invoke<BOOL);
		std::get<1>(return_values) = plateData;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_ADD_IS_PENDING( int token) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_LICENSEPLATE_GET_ADD_IS_PENDING(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_ADD_STATUS( int token) { return invoke<int )
	{
		auto retval = SOCIALCLUB::SC_LICENSEPLATE_GET_ADD_STATUS(invoke<int);
		return retval;
	}

	std::tuple<bool, int token) { return> LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_ISVALID( const char* plateText, int token) { return invoke<BOOL )
	{
		std::tuple<bool, int token) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_LICENSEPLATE_ISVALID(plateText, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_ISVALID_IS_PENDING( int token) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_LICENSEPLATE_GET_ISVALID_IS_PENDING(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_LICENSEPLATE_GET_ISVALID_STATUS( int token) { return invoke<int )
	{
		auto retval = SOCIALCLUB::SC_LICENSEPLATE_GET_ISVALID_STATUS(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_IS_ACTIVE(  )
	{
		auto retval = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_IS_ACTIVE();
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EVENT_ID(  )
	{
		auto retval = SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EVENT_ID();
		return retval;
	}

	std::tuple<bool, int p1) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT( const char* p0, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, int p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float p1) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT( const char* p0, float p1) { return invoke<BOOL )
	{
		std::tuple<bool, float p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, char p1) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING( const char* p0, char p1) { return invoke<BOOL )
	{
		std::tuple<bool, char p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, char p0) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_DISPLAY_NAME( char p0) { return invoke<BOOL )
	{
		std::tuple<bool, char p0) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_DISPLAY_NAME(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_IS_ACTIVE_FOR_TYPE( const char* p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_IS_ACTIVE_FOR_TYPE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EVENT_ID_FOR_TYPE( const char* p0) { return invoke<int )
	{
		auto retval = SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EVENT_ID_FOR_TYPE(invoke<int);
		return retval;
	}

	std::tuple<bool, int> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT_FOR_TYPE( const char* p0, int p1, const char* p2) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT_FOR_TYPE(p0, &p1, invoke<BOOL);
		std::get<1>(return_values) = p1;

		return return_values;
	}

	std::tuple<bool, float> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT_FOR_TYPE( const char* p0, float p1, const char* p2) { return invoke<BOOL )
	{
		std::tuple<bool, float> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT_FOR_TYPE(p0, &p1, invoke<BOOL);
		std::get<1>(return_values) = p1;

		return return_values;
	}

	std::tuple<bool, char> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING_FOR_TYPE( const char* p0, char p1, const char* p2) { return invoke<BOOL )
	{
		std::tuple<bool, char> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING_FOR_TYPE(p0, &p1, invoke<BOOL);
		std::get<1>(return_values) = p1;

		return return_values;
	}

	std::tuple<bool, char> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_DISPLAY_NAME_FOR_TYPE( char p0, const char* p1) { return invoke<BOOL )
	{
		std::tuple<bool, char> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_DISPLAY_NAME_FOR_TYPE(&p0, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_IS_ACTIVE_BY_ID( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_IS_ACTIVE_BY_ID(invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int p2) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT_BY_ID( int p0, const char* p1, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int p2) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_INT_BY_ID(p0, p1, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float p2) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT_BY_ID( int p0, const char* p1, float p2) { return invoke<BOOL )
	{
		std::tuple<bool, float p2) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_FLOAT_BY_ID(p0, p1, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, char p2) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING_BY_ID( int p0, const char* p1, char p2) { return invoke<BOOL )
	{
		std::tuple<bool, char p2) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_EXTRA_DATA_STRING_BY_ID(p0, p1, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, char p1) { return> LUA_NATIVE_SOCIALCLUB_SC_COMMUNITY_EVENT_GET_DISPLAY_NAME_BY_ID( int p0, char p1) { return invoke<BOOL )
	{
		std::tuple<bool, char p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_COMMUNITY_EVENT_GET_DISPLAY_NAME_BY_ID(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_SHOW( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_TRANSITION_NEWS_SHOW(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_SHOW_TIMED( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_TRANSITION_NEWS_SHOW_TIMED(p0, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_SHOW_NEXT_ITEM(  )
	{
		auto retval = (bool)SOCIALCLUB::SC_TRANSITION_NEWS_SHOW_NEXT_ITEM();
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_HAS_EXTRA_DATA_TU(  )
	{
		auto retval = (bool)SOCIALCLUB::SC_TRANSITION_NEWS_HAS_EXTRA_DATA_TU();
		return retval;
	}

	std::tuple<bool, int p1) { return> LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_GET_EXTRA_DATA_INT_TU( const char* p0, int p1) { return invoke<BOOL )
	{
		std::tuple<bool, int p1) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_TRANSITION_NEWS_GET_EXTRA_DATA_INT_TU(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_SOCIALCLUB_SC_TRANSITION_NEWS_END(  )
	{
		SOCIALCLUB::SC_TRANSITION_NEWS_END();
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PAUSE_NEWS_INIT_STARTER_PACK( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PAUSE_NEWS_INIT_STARTER_PACK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_PAUSE_NEWS_GET_PENDING_STORY( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_PAUSE_NEWS_GET_PENDING_STORY(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_SOCIALCLUB_SC_PAUSE_NEWS_SHUTDOWN(  )
	{
		SOCIALCLUB::SC_PAUSE_NEWS_SHUTDOWN();
	}

	const char* LUA_NATIVE_SOCIALCLUB_SC_ACCOUNT_INFO_GET_NICKNAME(  )
	{
		auto retval = SOCIALCLUB::SC_ACCOUNT_INFO_GET_NICKNAME();
		return retval;
	}

	std::tuple<bool, int p0) { return> LUA_NATIVE_SOCIALCLUB_SC_ACHIEVEMENT_INFO_STATUS( int p0) { return invoke<BOOL )
	{
		std::tuple<bool, int p0) { return> return_values;
		std::get<0>(return_values) = (bool)SOCIALCLUB::SC_ACHIEVEMENT_INFO_STATUS(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_SOCIALCLUB_SC_HAS_ACHIEVEMENT_BEEN_PASSED( int achievementId) { return invoke<BOOL )
	{
		auto retval = (bool)SOCIALCLUB::SC_HAS_ACHIEVEMENT_BEEN_PASSED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_CLEAR_SLOT_FOR_RELOAD( int statSlot) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_CLEAR_SLOT_FOR_RELOAD(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_LOAD( int statSlot) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_LOAD(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SAVE( int p0, bool p1, int p2, bool p3) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SAVE(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_SET_OPEN_SAVETYPE_IN_JOB( int p0) { invoke<void )
	{
		STATS::STAT_SET_OPEN_SAVETYPE_IN_JOB(invoke<void);
	}

	bool LUA_NATIVE_STATS_STAT_LOAD_PENDING( int statSlot) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_LOAD_PENDING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SAVE_PENDING(  )
	{
		auto retval = (bool)STATS::STAT_SAVE_PENDING();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SAVE_PENDING_OR_REQUESTED(  )
	{
		auto retval = (bool)STATS::STAT_SAVE_PENDING_OR_REQUESTED();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_DELETE_SLOT( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_DELETE_SLOT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SLOT_IS_LOADED( int statSlot) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SLOT_IS_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_CLOUD_SLOT_LOAD_FAILED( int p0) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_CLOUD_SLOT_LOAD_FAILED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_CLOUD_SLOT_LOAD_FAILED_CODE( Any p0) { return invoke<int )
	{
		auto retval = STATS::STAT_CLOUD_SLOT_LOAD_FAILED_CODE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_SET_BLOCK_SAVES( bool toggle) { invoke<void )
	{
		STATS::STAT_SET_BLOCK_SAVES(invoke<void);
	}

	bool LUA_NATIVE_STATS_STAT_GET_BLOCK_SAVES(  )
	{
		auto retval = (bool)STATS::STAT_GET_BLOCK_SAVES();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_CLOUD_SLOT_SAVE_FAILED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_CLOUD_SLOT_SAVE_FAILED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_CLEAR_PENDING_SAVES( Any p0) { invoke<void )
	{
		STATS::STAT_CLEAR_PENDING_SAVES(invoke<void);
	}

	bool LUA_NATIVE_STATS_STAT_LOAD_DIRTY_READ_DETECTED(  )
	{
		auto retval = (bool)STATS::STAT_LOAD_DIRTY_READ_DETECTED();
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_CLEAR_DIRTY_READ_DETECTED(  )
	{
		STATS::STAT_CLEAR_DIRTY_READ_DETECTED();
	}

	bool LUA_NATIVE_STATS_STAT_GET_LOAD_SAFE_TO_PROGRESS_TO_MP_FROM_SP(  )
	{
		auto retval = (bool)STATS::STAT_GET_LOAD_SAFE_TO_PROGRESS_TO_MP_FROM_SP();
		return retval;
	}

	unsigned LUA_NATIVE_STATS_GET_STAT_HASH_FOR_CHARACTER_STAT_( int dataType, int statIndex, int charSlot) { return invoke<unsigned )
	{
		auto retval = STATS::GET_STAT_HASH_FOR_CHARACTER_STAT_(dataType, statIndex, invoke<unsigned);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_INT( unsigned statName, int value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_INT(statName, value, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_FLOAT( unsigned statName, float value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_FLOAT(statName, value, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_BOOL( unsigned statName, bool value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_BOOL(statName, value, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_GXT_LABEL( unsigned statName, const char* value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_GXT_LABEL(statName, value, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_STAT_SET_DATE( unsigned statName, Any value, int numFields, bool save) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_SET_DATE(statName, &value, numFields, invoke<BOOL);
		std::get<1>(return_values) = value;

		return return_values;
	}

	bool LUA_NATIVE_STATS_STAT_SET_STRING( unsigned statName, const char* value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_STRING(statName, value, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_POS( unsigned statName, float x, float y, float z, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_POS(statName, x, y, z, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_MASKED_INT( unsigned statName, int p1, int p2, int p3, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_MASKED_INT(statName, p1, p2, p3, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_USER_ID( unsigned statName, const char* value, bool save) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_USER_ID(statName, value, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_CURRENT_POSIX_TIME( unsigned statName, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_CURRENT_POSIX_TIME(statName, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int> LUA_NATIVE_STATS_STAT_GET_INT( unsigned statHash, int outValue, int p2) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_INT(statHash, &outValue, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, float> LUA_NATIVE_STATS_STAT_GET_FLOAT( unsigned statHash, float outValue, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, float> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_FLOAT(statHash, &outValue, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, bool> LUA_NATIVE_STATS_STAT_GET_BOOL( unsigned statHash, bool outValue, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, bool> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_BOOL(statHash, (BOOL*)&outValue, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_STAT_GET_DATE( unsigned statHash, Any outValue, int numFields, Any p3) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_DATE(statHash, &outValue, numFields, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	const char* LUA_NATIVE_STATS_STAT_GET_STRING( unsigned statHash, int p1) { return invoke<const char* )
	{
		auto retval = STATS::STAT_GET_STRING(statHash, char*);
		return retval;
	}

	std::tuple<bool, float, float, float> LUA_NATIVE_STATS_STAT_GET_POS( unsigned statName, float outX, float outY, float outZ, Any p4) { return invoke<BOOL )
	{
		std::tuple<bool, float, float, float> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_POS(statName, &outX, &outY, &outZ, invoke<BOOL);
		std::get<1>(return_values) = outX;
		std::get<2>(return_values) = outY;
		std::get<3>(return_values) = outZ;

		return return_values;
	}

	std::tuple<bool, int> LUA_NATIVE_STATS_STAT_GET_MASKED_INT( unsigned statHash, int outValue, int p2, int p3, Any p4) { return invoke<BOOL )
	{
		std::tuple<bool, int> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_MASKED_INT(statHash, &outValue, p2, p3, invoke<BOOL);
		std::get<1>(return_values) = outValue;

		return return_values;
	}

	const char* LUA_NATIVE_STATS_STAT_GET_USER_ID( unsigned statHash) { return invoke<const char* )
	{
		auto retval = STATS::STAT_GET_USER_ID(char*);
		return retval;
	}

	const char* LUA_NATIVE_STATS_STAT_GET_LICENSE_PLATE( unsigned statName) { return invoke<const char* )
	{
		auto retval = STATS::STAT_GET_LICENSE_PLATE(char*);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SET_LICENSE_PLATE( unsigned statName, const char* str) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SET_LICENSE_PLATE(statName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_INCREMENT( unsigned statName, float value) { invoke<void )
	{
		STATS::STAT_INCREMENT(statName, invoke<void);
	}

	bool LUA_NATIVE_STATS_STAT_COMMUNITY_START_SYNCH(  )
	{
		auto retval = (bool)STATS::STAT_COMMUNITY_START_SYNCH();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_COMMUNITY_SYNCH_IS_PENDING(  )
	{
		auto retval = (bool)STATS::STAT_COMMUNITY_SYNCH_IS_PENDING();
		return retval;
	}

	std::tuple<bool, float outValue) { return> LUA_NATIVE_STATS_STAT_COMMUNITY_GET_HISTORY( unsigned statName, int p1, float outValue) { return invoke<BOOL )
	{
		std::tuple<bool, float outValue) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_COMMUNITY_GET_HISTORY(statName, p1, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_STAT_RESET_ALL_ONLINE_CHARACTER_STATS( int p0) { invoke<void )
	{
		STATS::STAT_RESET_ALL_ONLINE_CHARACTER_STATS(invoke<void);
	}

	void LUA_NATIVE_STATS_STAT_LOCAL_RESET_ALL_ONLINE_CHARACTER_STATS( int p0) { invoke<void )
	{
		STATS::STAT_LOCAL_RESET_ALL_ONLINE_CHARACTER_STATS(invoke<void);
	}

	int LUA_NATIVE_STATS_STAT_GET_NUMBER_OF_DAYS( unsigned statName) { return invoke<int )
	{
		auto retval = STATS::STAT_GET_NUMBER_OF_DAYS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_GET_NUMBER_OF_HOURS( unsigned statName) { return invoke<int )
	{
		auto retval = STATS::STAT_GET_NUMBER_OF_HOURS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_GET_NUMBER_OF_MINUTES( unsigned statName) { return invoke<int )
	{
		auto retval = STATS::STAT_GET_NUMBER_OF_MINUTES(invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_GET_NUMBER_OF_SECONDS( unsigned statName) { return invoke<int )
	{
		auto retval = STATS::STAT_GET_NUMBER_OF_SECONDS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_STATS_STAT_SET_PROFILE_SETTING_VALUE( int profileSetting, int value) { invoke<void )
	{
		STATS::STAT_SET_PROFILE_SETTING_VALUE(profileSetting, invoke<void);
	}

	void LUA_NATIVE_STATS_STATS_COMPLETED_CHARACTER_CREATION( Any p0) { invoke<void )
	{
		STATS::STATS_COMPLETED_CHARACTER_CREATION(invoke<void);
	}

	int LUA_NATIVE_STATS_PACKED_STAT_GET_INT_STAT_INDEX( int p0) { return invoke<int )
	{
		auto retval = STATS::PACKED_STAT_GET_INT_STAT_INDEX(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_STATS_GET_PACKED_INT_STAT_KEY( int index, bool spStat, bool charStat, int character) { return invoke<unsigned )
	{
		auto retval = STATS::GET_PACKED_INT_STAT_KEY(index, spStat, charStat, invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_STATS_GET_PACKED_TU_INT_STAT_KEY( int index, bool spStat, bool charStat, int character) { return invoke<unsigned )
	{
		auto retval = STATS::GET_PACKED_TU_INT_STAT_KEY(index, spStat, charStat, invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_STATS_GET_PACKED_NG_INT_STAT_KEY( int index, bool spStat, bool charStat, int character, const char* section) { return invoke<unsigned )
	{
		auto retval = STATS::GET_PACKED_NG_INT_STAT_KEY(index, spStat, charStat, character, invoke<unsigned);
		return retval;
	}

	bool LUA_NATIVE_STATS_GET_PACKED_STAT_BOOL_CODE( int index, int characterSlot) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::GET_PACKED_STAT_BOOL_CODE(index, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_STATS_GET_PACKED_STAT_INT_CODE( int index, int characterSlot) { return invoke<int )
	{
		auto retval = STATS::GET_PACKED_STAT_INT_CODE(index, invoke<int);
		return retval;
	}

	void LUA_NATIVE_STATS_SET_PACKED_STAT_BOOL_CODE( int index, bool value, int characterSlot) { invoke<void )
	{
		STATS::SET_PACKED_STAT_BOOL_CODE(index, value, invoke<void);
	}

	void LUA_NATIVE_STATS_SET_PACKED_STAT_INT_CODE( int index, int value, int characterSlot) { invoke<void )
	{
		STATS::SET_PACKED_STAT_INT_CODE(index, value, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BACKGROUND_SCRIPT_ACTION( const char* action, int value) { invoke<void )
	{
		STATS::PLAYSTATS_BACKGROUND_SCRIPT_ACTION(action, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FLOW_LOW_( float posX, float posY, float posZ, const char* p3, Any p4, int amount) { invoke<void )
	{
		STATS::PLAYSTATS_FLOW_LOW_(posX, posY, posZ, p3, p4, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_NPC_INVITE( const char* p0) { invoke<void )
	{
		STATS::PLAYSTATS_NPC_INVITE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_AWARD_XP( int amount, unsigned type, unsigned category) { invoke<void )
	{
		STATS::PLAYSTATS_AWARD_XP(amount, type, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RANK_UP( int rank) { invoke<void )
	{
		STATS::PLAYSTATS_RANK_UP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_STARTED_SESSION_IN_OFFLINEMODE(  )
	{
		STATS::PLAYSTATS_STARTED_SESSION_IN_OFFLINEMODE();
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ACTIVITY_DONE( int p0, int activityId) { invoke<void )
	{
		STATS::PLAYSTATS_ACTIVITY_DONE(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_LEAVE_JOB_CHAIN( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_LEAVE_JOB_CHAIN(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MISSION_STARTED( const char* p0, Any p1, Any p2, bool p3) { invoke<void )
	{
		STATS::PLAYSTATS_MISSION_STARTED(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MISSION_OVER( const char* p0, Any p1, Any p2, bool p3, bool p4, bool p5) { invoke<void )
	{
		STATS::PLAYSTATS_MISSION_OVER(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MISSION_CHECKPOINT( const char* p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_MISSION_CHECKPOINT(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RANDOM_MISSION_DONE( const char* name, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_RANDOM_MISSION_DONE(name, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ROS_BET( int amount, int act, int player, float cm) { invoke<void )
	{
		STATS::PLAYSTATS_ROS_BET(amount, act, player, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RACE_CHECKPOINT( int p0, Any p1, int p2, int p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_RACE_CHECKPOINT(p0, p1, p2, p3, invoke<void);
	}

	std::tuple<bool, int, int posixTime) { return> LUA_NATIVE_STATS_PLAYSTATS_CREATE_MATCH_HISTORY_ID_2( int playerAccountId, int posixTime) { return invoke<BOOL )
	{
		std::tuple<bool, int, int posixTime) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::PLAYSTATS_CREATE_MATCH_HISTORY_ID_2(&playerAccountId, &invoke<BOOL);
		std::get<1>(return_values) = playerAccountId;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MATCH_STARTED( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::PLAYSTATS_MATCH_STARTED(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SHOP_ITEM( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_SHOP_ITEM(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CRATE_DROP_MISSION_DONE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<void )
	{
		STATS::PLAYSTATS_CRATE_DROP_MISSION_DONE(p0, p1, p2, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CRATE_CREATED( float p0, float p1, float p2) { invoke<void )
	{
		STATS::PLAYSTATS_CRATE_CREATED(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HOLD_UP_MISSION_DONE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_HOLD_UP_MISSION_DONE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_IMPORT_EXPORT_MISSION_DONE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_IMPORT_EXPORT_MISSION_DONE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RACE_TO_POINT_MISSION_DONE( int p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_RACE_TO_POINT_MISSION_DONE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ACQUIRED_HIDDEN_PACKAGE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ACQUIRED_HIDDEN_PACKAGE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_WEBSITE_VISITED( unsigned scaleformHash, int p1) { invoke<void )
	{
		STATS::PLAYSTATS_WEBSITE_VISITED(scaleformHash, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FRIEND_ACTIVITY( int p0, bool p1) { invoke<void )
	{
		STATS::PLAYSTATS_FRIEND_ACTIVITY(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ODDJOB_DONE( int totalTimeMs, int p1, bool p2) { invoke<void )
	{
		STATS::PLAYSTATS_ODDJOB_DONE(totalTimeMs, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_PROP_CHANGE( int p0, int p1, int p2, int p3) { invoke<void )
	{
		STATS::PLAYSTATS_PROP_CHANGE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CLOTH_CHANGE( int p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_CLOTH_CHANGE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_WEAPON_MODE_CHANGE( unsigned weaponHash, unsigned componentHashTo, unsigned componentHashFrom) { invoke<void )
	{
		STATS::PLAYSTATS_WEAPON_MODE_CHANGE(weaponHash, componentHashTo, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CHEAT_APPLIED( const char* cheat) { invoke<void )
	{
		STATS::PLAYSTATS_CHEAT_APPLIED(invoke<void);
	}

	std::tuple<Any, Any, Any, Any p3) {> LUA_NATIVE_STATS_PLAYSTATS_JOB_ACTIVITY_END( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		std::tuple<Any, Any, Any, Any p3) {> return_values;
		STATS::PLAYSTATS_JOB_ACTIVITY_END(&p0, &p1, &p2, &invoke<void);
		std::get<0>(return_values) = p0;
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = p2;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<Any, Any, Any, Any p3) {> LUA_NATIVE_STATS_PLAYSTATS_JOB_BEND( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		std::tuple<Any, Any, Any, Any p3) {> return_values;
		STATS::PLAYSTATS_JOB_BEND(&p0, &p1, &p2, &invoke<void);
		std::get<0>(return_values) = p0;
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = p2;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<Any, Any, Any, Any p3) {> LUA_NATIVE_STATS_PLAYSTATS_JOB_LTS_END( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		std::tuple<Any, Any, Any, Any p3) {> return_values;
		STATS::PLAYSTATS_JOB_LTS_END(&p0, &p1, &p2, &invoke<void);
		std::get<0>(return_values) = p0;
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = p2;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<Any, Any, Any, Any p3) {> LUA_NATIVE_STATS_PLAYSTATS_JOB_LTS_ROUND_END( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		std::tuple<Any, Any, Any, Any p3) {> return_values;
		STATS::PLAYSTATS_JOB_LTS_ROUND_END(&p0, &p1, &p2, &invoke<void);
		std::get<0>(return_values) = p0;
		std::get<1>(return_values) = p1;
		std::get<2>(return_values) = p2;
		std::get<3>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_QUICKFIX_TOOL( int element, const char* item) { invoke<void )
	{
		STATS::PLAYSTATS_QUICKFIX_TOOL(element, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_IDLE_KICK( int msStoodIdle) { invoke<void )
	{
		STATS::PLAYSTATS_IDLE_KICK(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SET_JOIN_TYPE( int joinType) { invoke<void )
	{
		STATS::PLAYSTATS_SET_JOIN_TYPE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST_SAVE_CHEAT( unsigned hash, int p1) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST_SAVE_CHEAT(hash, invoke<void);
	}

	Any p0) { LUA_NATIVE_STATS_PLAYSTATS_APPEND_DIRECTOR_METRIC( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_APPEND_DIRECTOR_METRIC(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_AWARD_BAD_SPORT( int id) { invoke<void )
	{
		STATS::PLAYSTATS_AWARD_BAD_SPORT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_PEGASUS_AS_PERSONAL_AIRCRAFT( unsigned modelHash) { invoke<void )
	{
		STATS::PLAYSTATS_PEGASUS_AS_PERSONAL_AIRCRAFT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SHOPMENU_NAV_( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::PLAYSTATS_SHOPMENU_NAV_(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_CHALLENGES( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_CHALLENGES(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_VEHICLETARGET( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_VEHICLETARGET(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_URBANWARFARE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_URBANWARFARE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_CHECKPOINTCOLLECTION( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_CHECKPOINTCOLLECTION(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_ATOB( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_ATOB(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_PENNEDIN( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_PENNEDIN(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_PASSTHEPARCEL( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_PASSTHEPARCEL(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_HOTPROPERTY( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_HOTPROPERTY(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_DEADDROP( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_DEADDROP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_KINGOFTHECASTLE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_KINGOFTHECASTLE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_CRIMINALDAMAGE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_CRIMINALDAMAGE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_COMPETITIVEURBANWARFARE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_COMPETITIVEURBANWARFARE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_EVENT_HUNTBEAST( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_FM_EVENT_HUNTBEAST(invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_PIMENU_HIDE_OPTIONS( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_PIMENU_HIDE_OPTIONS(&invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_GET_NUMBER_OF_COLUMNS( int p0, Any p1) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_GET_NUMBER_OF_COLUMNS(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_GET_COLUMN_ID( int p0, int p1, int p2) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_GET_COLUMN_ID(p0, p1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_GET_COLUMN_TYPE( int p0, Any p1, Any p2) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_GET_COLUMN_TYPE(p0, p1, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_READ_CLEAR_ALL(  )
	{
		auto retval = STATS::LEADERBOARDS_READ_CLEAR_ALL();
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_READ_CLEAR( Any p0, Any p1, Any p2) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_READ_CLEAR(p0, p1, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_STATS_LEADERBOARDS_READ_PENDING( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::LEADERBOARDS_READ_PENDING(p0, p1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_LEADERBOARDS_READ_ANY_PENDING(  )
	{
		auto retval = (bool)STATS::LEADERBOARDS_READ_ANY_PENDING();
		return retval;
	}

	bool LUA_NATIVE_STATS_LEADERBOARDS_READ_SUCCESSFUL( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::LEADERBOARDS_READ_SUCCESSFUL(p0, p1, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, Any, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_FRIENDS_BY_ROW( Any p0, Any p1, Any p2, bool p3, Any p4, Any p5) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_FRIENDS_BY_ROW(&p0, &p1, p2, p3, p4, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;

		return return_values;
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_HANDLE( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_HANDLE(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any, Any, Any, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_ROW( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any, Any, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_ROW(&p0, &p1, p2, &p3, p4, &p5, invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;
		std::get<3>(return_values) = p3;
		std::get<4>(return_values) = p5;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_RANK( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_RANK(&p0, p1, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, Any, Any p2) { return> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_RADIUS( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p2) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_RADIUS(&p0, p1, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_SCORE_INT( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_SCORE_INT(&p0, p1, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_SCORE_FLOAT( Any p0, float p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_SCORE_FLOAT(&p0, p1, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, Any, Any, Any p2) { return> LUA_NATIVE_STATS_LEADERBOARDS2_READ_RANK_PREDICTION( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any, Any p2) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_RANK_PREDICTION(&p0, &p1, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = p1;
		std::get<3>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any> LUA_NATIVE_STATS_LEADERBOARDS2_READ_BY_PLAFORM( Any p0, const char* gamerHandleCsv, const char* platformName) { return invoke<BOOL )
	{
		std::tuple<bool, Any> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_BY_PLAFORM(&p0, gamerHandleCsv, invoke<BOOL);
		std::get<1>(return_values) = p0;

		return return_values;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_STATS_LEADERBOARDS2_READ_GET_ROW_DATA_START( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_GET_ROW_DATA_START(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_LEADERBOARDS2_READ_GET_ROW_DATA_END(  )
	{
		STATS::LEADERBOARDS2_READ_GET_ROW_DATA_END();
	}

	std::tuple<bool, Any p1) { return> LUA_NATIVE_STATS_LEADERBOARDS2_READ_GET_ROW_DATA_INFO( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_READ_GET_ROW_DATA_INFO(p0, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS2_READ_GET_ROW_DATA_INT( Any p0, Any p1) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS2_READ_GET_ROW_DATA_INT(p0, invoke<int);
		return retval;
	}

	float LUA_NATIVE_STATS_LEADERBOARDS2_READ_GET_ROW_DATA_FLOAT( Any p0, Any p1) { return invoke<float )
	{
		auto retval = STATS::LEADERBOARDS2_READ_GET_ROW_DATA_FLOAT(p0, invoke<float);
		return retval;
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_STATS_LEADERBOARDS2_WRITE_DATA( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_WRITE_DATA(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_LEADERBOARDS_WRITE_ADD_COLUMN( Any p0, Any p1, float p2) { invoke<void )
	{
		STATS::LEADERBOARDS_WRITE_ADD_COLUMN(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_LEADERBOARDS_WRITE_ADD_COLUMN_LONG( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::LEADERBOARDS_WRITE_ADD_COLUMN_LONG(p0, p1, invoke<void);
	}

	std::tuple<bool, Any p0) { return> LUA_NATIVE_STATS_LEADERBOARDS_CACHE_DATA_ROW( Any p0) { return invoke<BOOL )
	{
		std::tuple<bool, Any p0) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS_CACHE_DATA_ROW(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_LEADERBOARDS_CLEAR_CACHE_DATA(  )
	{
		STATS::LEADERBOARDS_CLEAR_CACHE_DATA();
	}

	void LUA_NATIVE_STATS_LEADERBOARDS_CLEAR_CACHE_DATA_ID( Any p0) { invoke<void )
	{
		STATS::LEADERBOARDS_CLEAR_CACHE_DATA_ID(invoke<void);
	}

	bool LUA_NATIVE_STATS_LEADERBOARDS_GET_CACHE_EXISTS( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::LEADERBOARDS_GET_CACHE_EXISTS(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_GET_CACHE_TIME( Any p0) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_GET_CACHE_TIME(invoke<int);
		return retval;
	}

	int LUA_NATIVE_STATS_LEADERBOARDS_GET_CACHE_NUMBER_OF_ROWS( Any p0) { return invoke<int )
	{
		auto retval = STATS::LEADERBOARDS_GET_CACHE_NUMBER_OF_ROWS(invoke<int);
		return retval;
	}

	std::tuple<bool, Any p2) { return> LUA_NATIVE_STATS_LEADERBOARDS_GET_CACHE_DATA_ROW( Any p0, Any p1, Any p2) { return invoke<BOOL )
	{
		std::tuple<bool, Any p2) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS_GET_CACHE_DATA_ROW(p0, p1, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_PRESENCE_EVENT_UPDATESTAT_INT( unsigned statHash, int value, int p2) { invoke<void )
	{
		STATS::PRESENCE_EVENT_UPDATESTAT_INT(statHash, value, invoke<void);
	}

	void LUA_NATIVE_STATS_PRESENCE_EVENT_UPDATESTAT_FLOAT( unsigned statHash, float value, int p2) { invoke<void )
	{
		STATS::PRESENCE_EVENT_UPDATESTAT_FLOAT(statHash, value, invoke<void);
	}

	void LUA_NATIVE_STATS_PRESENCE_EVENT_UPDATESTAT_INT_WITH_STRING( unsigned statHash, int value, int p2, const char* string) { invoke<void )
	{
		STATS::PRESENCE_EVENT_UPDATESTAT_INT_WITH_STRING(statHash, value, p2, invoke<void);
	}

	bool LUA_NATIVE_STATS_GET_PLAYER_HAS_DRIVEN_ALL_VEHICLES(  )
	{
		auto retval = (bool)STATS::GET_PLAYER_HAS_DRIVEN_ALL_VEHICLES();
		return retval;
	}

	void LUA_NATIVE_STATS_SET_HAS_POSTED_ALL_VEHICLES_DRIVEN(  )
	{
		STATS::SET_HAS_POSTED_ALL_VEHICLES_DRIVEN();
	}

	void LUA_NATIVE_STATS_SET_PROFILE_SETTING_PROLOGUE_COMPLETE(  )
	{
		STATS::SET_PROFILE_SETTING_PROLOGUE_COMPLETE();
	}

	void LUA_NATIVE_STATS_SET_PROFILE_SETTING_SP_CHOP_MISSION_COMPLETE(  )
	{
		STATS::SET_PROFILE_SETTING_SP_CHOP_MISSION_COMPLETE();
	}

	void LUA_NATIVE_STATS_SET_PROFILE_SETTING_CREATOR_RACES_DONE( int value) { invoke<void )
	{
		STATS::SET_PROFILE_SETTING_CREATOR_RACES_DONE(invoke<void);
	}

	void LUA_NATIVE_STATS_SET_PROFILE_SETTING_CREATOR_DM_DONE( int value) { invoke<void )
	{
		STATS::SET_PROFILE_SETTING_CREATOR_DM_DONE(invoke<void);
	}

	void LUA_NATIVE_STATS_SET_PROFILE_SETTING_CREATOR_CTF_DONE( int value) { invoke<void )
	{
		STATS::SET_PROFILE_SETTING_CREATOR_CTF_DONE(invoke<void);
	}

	void LUA_NATIVE_STATS_SET_JOB_ACTIVITY_ID_STARTED( Any p0, int characterSlot) { invoke<void )
	{
		STATS::SET_JOB_ACTIVITY_ID_STARTED(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_SET_FREEMODE_PROLOGUE_DONE( Any p0, int characterSlot) { invoke<void )
	{
		STATS::SET_FREEMODE_PROLOGUE_DONE(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_SET_FREEMODE_STRAND_PROGRESSION_STATUS( int profileSetting, int settingValue) { invoke<void )
	{
		STATS::SET_FREEMODE_STRAND_PROGRESSION_STATUS(profileSetting, invoke<void);
	}

	void LUA_NATIVE_STATS_STAT_NETWORK_INCREMENT_ON_SUICIDE( Any p0, float p1) { invoke<void )
	{
		STATS::STAT_NETWORK_INCREMENT_ON_SUICIDE(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_STAT_SET_CHEAT_IS_ACTIVE(  )
	{
		STATS::STAT_SET_CHEAT_IS_ACTIVE();
	}

	std::tuple<bool, Any, Any p1) { return> LUA_NATIVE_STATS_LEADERBOARDS2_WRITE_DATA_FOR_EVENT_TYPE( Any p0, Any p1) { return invoke<BOOL )
	{
		std::tuple<bool, Any, Any p1) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::LEADERBOARDS2_WRITE_DATA_FOR_EVENT_TYPE(&p0, &invoke<BOOL);
		std::get<1>(return_values) = p0;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_STATS_FORCE_CLOUD_MP_STATS_DOWNLOAD_AND_OVERWRITE_LOCAL_SAVE(  )
	{
		STATS::FORCE_CLOUD_MP_STATS_DOWNLOAD_AND_OVERWRITE_LOCAL_SAVE();
	}

	void LUA_NATIVE_STATS_STAT_MIGRATE_CLEAR_FOR_RESTART(  )
	{
		STATS::STAT_MIGRATE_CLEAR_FOR_RESTART();
	}

	bool LUA_NATIVE_STATS_STAT_MIGRATE_SAVEGAME_START( const char* platformName) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_MIGRATE_SAVEGAME_START(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_MIGRATE_SAVEGAME_GET_STATUS(  )
	{
		auto retval = STATS::STAT_MIGRATE_SAVEGAME_GET_STATUS();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_MIGRATE_CHECK_ALREADY_DONE(  )
	{
		auto retval = (bool)STATS::STAT_MIGRATE_CHECK_ALREADY_DONE();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_MIGRATE_CHECK_START(  )
	{
		auto retval = (bool)STATS::STAT_MIGRATE_CHECK_START();
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_MIGRATE_CHECK_GET_IS_PLATFORM_AVAILABLE( int p0) { return invoke<int )
	{
		auto retval = STATS::STAT_MIGRATE_CHECK_GET_IS_PLATFORM_AVAILABLE(invoke<int);
		return retval;
	}

	std::tuple<int, Any p1) { return> LUA_NATIVE_STATS_STAT_MIGRATE_CHECK_GET_PLATFORM_STATUS( int p0, Any p1) { return invoke<int )
	{
		std::tuple<int, Any p1) { return> return_values;
		std::get<0>(return_values) = STATS::STAT_MIGRATE_CHECK_GET_PLATFORM_STATUS(p0, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, Any data) { return> LUA_NATIVE_STATS_STAT_GET_SAVE_MIGRATION_STATUS( Any data) { return invoke<int )
	{
		std::tuple<int, Any data) { return> return_values;
		std::get<0>(return_values) = STATS::STAT_GET_SAVE_MIGRATION_STATUS(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	bool LUA_NATIVE_STATS_STAT_SAVE_MIGRATION_CANCEL_PENDING_OPERATION(  )
	{
		auto retval = (bool)STATS::STAT_SAVE_MIGRATION_CANCEL_PENDING_OPERATION();
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_GET_CANCEL_SAVE_MIGRATION_STATUS(  )
	{
		auto retval = STATS::STAT_GET_CANCEL_SAVE_MIGRATION_STATUS();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_SAVE_MIGRATION_CONSUME_CONTENT( unsigned contentId, const char* srcPlatform, const char* srcGamerHandle) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_SAVE_MIGRATION_CONSUME_CONTENT(contentId, srcPlatform, invoke<BOOL);
		return retval;
	}

	std::tuple<int, int p0) { return> LUA_NATIVE_STATS_STAT_GET_SAVE_MIGRATION_CONSUME_CONTENT_STATUS( int p0) { return invoke<int )
	{
		std::tuple<int, int p0) { return> return_values;
		std::get<0>(return_values) = STATS::STAT_GET_SAVE_MIGRATION_CONSUME_CONTENT_STATUS(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_STATS_STAT_ENABLE_STATS_TRACKING(  )
	{
		STATS::STAT_ENABLE_STATS_TRACKING();
	}

	void LUA_NATIVE_STATS_STAT_DISABLE_STATS_TRACKING(  )
	{
		STATS::STAT_DISABLE_STATS_TRACKING();
	}

	bool LUA_NATIVE_STATS_STAT_IS_STATS_TRACKING_ENABLED(  )
	{
		auto retval = (bool)STATS::STAT_IS_STATS_TRACKING_ENABLED();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_START_RECORD_STAT( int statType, int valueType) { return invoke<BOOL )
	{
		auto retval = (bool)STATS::STAT_START_RECORD_STAT(statType, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_STOP_RECORD_STAT(  )
	{
		auto retval = (bool)STATS::STAT_STOP_RECORD_STAT();
		return retval;
	}

	std::tuple<bool, float value) { return> LUA_NATIVE_STATS_STAT_GET_RECORDED_VALUE( float value) { return invoke<BOOL )
	{
		std::tuple<bool, float value) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_RECORDED_VALUE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_STATS_STAT_IS_RECORDING_STAT(  )
	{
		auto retval = (bool)STATS::STAT_IS_RECORDING_STAT();
		return retval;
	}

	int LUA_NATIVE_STATS_STAT_GET_CURRENT_NEAR_MISS_NOCRASH_PRECISE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_NEAR_MISS_NOCRASH_PRECISE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_REAR_WHEEL_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_REAR_WHEEL_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_FRONT_WHEEL_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_FRONT_WHEEL_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_JUMP_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_JUMP_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_DRIVE_NOCRASH_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_DRIVE_NOCRASH_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_SPEED(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_SPEED();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_DRIVING_REVERSE_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_DRIVING_REVERSE_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CURRENT_SKYDIVING_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_CURRENT_SKYDIVING_DISTANCE();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_CHALLENGE_FLYING_DIST(  )
	{
		auto retval = STATS::STAT_GET_CHALLENGE_FLYING_DIST();
		return retval;
	}

	std::tuple<bool, float outValue) { return> LUA_NATIVE_STATS_STAT_GET_FLYING_ALTITUDE( float outValue) { return invoke<BOOL )
	{
		std::tuple<bool, float outValue) { return> return_values;
		std::get<0>(return_values) = (bool)STATS::STAT_GET_FLYING_ALTITUDE(&invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_STATS_STAT_IS_PLAYER_VEHICLE_ABOVE_OCEAN(  )
	{
		auto retval = (bool)STATS::STAT_IS_PLAYER_VEHICLE_ABOVE_OCEAN();
		return retval;
	}

	float LUA_NATIVE_STATS_STAT_GET_VEHICLE_BAIL_DISTANCE(  )
	{
		auto retval = STATS::STAT_GET_VEHICLE_BAIL_DISTANCE();
		return retval;
	}

	bool LUA_NATIVE_STATS_STAT_ROLLBACK_SAVE_MIGRATION(  )
	{
		auto retval = (bool)STATS::STAT_ROLLBACK_SAVE_MIGRATION();
		return retval;
	}

	void LUA_NATIVE_STATS_SET_HAS_SPECIALEDITION_CONTENT( int value) { invoke<void )
	{
		STATS::SET_HAS_SPECIALEDITION_CONTENT(invoke<void);
	}

	void LUA_NATIVE_STATS_SET_SAVE_MIGRATION_TRANSACTION_ID_WARNING( int transactionId) { invoke<void )
	{
		STATS::SET_SAVE_MIGRATION_TRANSACTION_ID_WARNING(invoke<void);
	}

	void LUA_NATIVE_STATS_GET_BOSS_GOON_UUID( int characterSlot, Any p1, Any p2) { invoke<void )
	{
		STATS::GET_BOSS_GOON_UUID(characterSlot, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_BOSSONBOSSDEATHMATCH( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_BOSSONBOSSDEATHMATCH(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_YATCHATTACK( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_YATCHATTACK(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_HUNT_THE_BOSS( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_HUNT_THE_BOSS(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_SIGHTSEER( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_SIGHTSEER(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_ASSAULT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_ASSAULT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_BELLY_OF_THE_BEAST( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_BELLY_OF_THE_BEAST(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_HEAD_HUNTER( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_HEAD_HUNTER(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_FRAGILE_GOODS( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_FRAGILE_GOODS(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BW_AIR_FREIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BW_AIR_FREIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_CAR_JACKING( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_CAR_JACKING(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_SMASH_AND_GRAB( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_SMASH_AND_GRAB(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_PROTECTION_RACKET( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_PROTECTION_RACKET(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_MOST_WANTED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_MOST_WANTED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_FINDERS_KEEPERS( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_FINDERS_KEEPERS(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_POINT_TO_POINT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_POINT_TO_POINT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_CASHING( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_CASHING(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BC_SALVAGE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BC_SALVAGE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SPENT_PI_CUSTOM_LOADOUT( int amount) { invoke<void )
	{
		STATS::PLAYSTATS_SPENT_PI_CUSTOM_LOADOUT(invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_BUY_CONTRABAND_MISSION( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_BUY_CONTRABAND_MISSION(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_SELL_CONTRABAND_MISSION( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_SELL_CONTRABAND_MISSION(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_DEFEND_CONTRABAND_MISSION( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_DEFEND_CONTRABAND_MISSION(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_RECOVER_CONTRABAND_MISSION( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_RECOVER_CONTRABAND_MISSION(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HIT_CONTRABAND_DESTROY_LIMIT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HIT_CONTRABAND_DESTROY_LIMIT(invoke<void);
	}

	void LUA_NATIVE_STATS_START_BEING_BOSS( Any p0, Any p1) { invoke<void )
	{
		STATS::START_BEING_BOSS(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_START_BEING_GOON( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::START_BEING_GOON(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_END_BEING_BOSS( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::END_BEING_BOSS(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_END_BEING_GOON( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::END_BEING_GOON(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_HIRED_LIMO( Any p0, Any p1) { invoke<void )
	{
		STATS::HIRED_LIMO(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_ORDER_BOSS_VEHICLE( Any p0, Any p1, unsigned vehicleHash) { invoke<void )
	{
		STATS::ORDER_BOSS_VEHICLE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_CHANGE_UNIFORM( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::CHANGE_UNIFORM(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_CHANGE_GOON_LOOKING_FOR_WORK( Any p0) { invoke<void )
	{
		STATS::CHANGE_GOON_LOOKING_FOR_WORK(invoke<void);
	}

	void LUA_NATIVE_STATS_SEND_METRIC_GHOSTING_TO_PLAYER( Any p0) { invoke<void )
	{
		STATS::SEND_METRIC_GHOSTING_TO_PLAYER(invoke<void);
	}

	void LUA_NATIVE_STATS_SEND_METRIC_VIP_POACH( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::SEND_METRIC_VIP_POACH(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_SEND_METRIC_PUNISH_BODYGUARD( Any p0) { invoke<void )
	{
		STATS::SEND_METRIC_PUNISH_BODYGUARD(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_START_TRACKING_STUNTS(  )
	{
		STATS::PLAYSTATS_START_TRACKING_STUNTS();
	}

	void LUA_NATIVE_STATS_PLAYSTATS_STOP_TRACKING_STUNTS(  )
	{
		STATS::PLAYSTATS_STOP_TRACKING_STUNTS();
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MISSION_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_MISSION_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_IMPEXP_MISSION_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_IMPEXP_MISSION_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CHANGE_MC_ROLE( Any p0, Any p1, Any p2, Any p3, int role, int p5, Any p6) { invoke<void )
	{
		STATS::PLAYSTATS_CHANGE_MC_ROLE(p0, p1, p2, p3, role, p5, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CHANGE_MC_OUTFIT( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_CHANGE_MC_OUTFIT(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SWITCH_MC_EMBLEM( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_SWITCH_MC_EMBLEM(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MC_REQUEST_BIKE( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_MC_REQUEST_BIKE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MC_KILLED_RIVAL_MC_MEMBER( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_MC_KILLED_RIVAL_MC_MEMBER(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ABANDONED_MC( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_ABANDONED_MC(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_EARNED_MC_POINTS( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		STATS::PLAYSTATS_EARNED_MC_POINTS(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MC_FORMATION_ENDS( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		STATS::PLAYSTATS_MC_FORMATION_ENDS(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MC_CLUBHOUSE_ACTIVITY( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<void )
	{
		STATS::PLAYSTATS_MC_CLUBHOUSE_ACTIVITY(p0, p1, p2, p3, p4, p5, p6, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RIVAL_BEHAVIOR( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<void )
	{
		STATS::PLAYSTATS_RIVAL_BEHAVIOR(p0, p1, p2, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_COPY_RANK_INTO_NEW_SLOT( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		STATS::PLAYSTATS_COPY_RANK_INTO_NEW_SLOT(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_DUPE_DETECTED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_DUPE_DETECTED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BAN_ALERT( int p0) { invoke<void )
	{
		STATS::PLAYSTATS_BAN_ALERT(invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_GUNRUNNING_MISSION_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_GUNRUNNING_MISSION_ENDED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_GUNRUNNING_RND( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_GUNRUNNING_RND(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_BUSINESS_BATTLE_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_BUSINESS_BATTLE_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_WAREHOUSE_MISSION_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_WAREHOUSE_MISSION_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_NIGHTCLUB_MISSION_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_NIGHTCLUB_MISSION_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_DJ_USAGE( Any p0, Any p1) { invoke<void )
	{
		STATS::PLAYSTATS_DJ_USAGE(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MINIGAME_USAGE( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::PLAYSTATS_MINIGAME_USAGE(p0, p1, invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_STONE_HATCHET_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_STONE_HATCHET_ENDED(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_SMUGGLER_MISSION_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_SMUGGLER_MISSION_ENDED(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_FM_HEIST_PREP_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_FM_HEIST_PREP_ENDED(&invoke<void);
		return invoke<void;
	}

	Any LUA_NATIVE_STATS_PLAYSTATS_INSTANCED_HEIST_ENDED( Any data, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_INSTANCED_HEIST_ENDED(&data, p1, p2, invoke<void);
		return data;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_DAR_CHECKPOINT( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_DAR_CHECKPOINT(&invoke<void);
		return invoke<void;
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_ENTER_SESSION_PACK( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_ENTER_SESSION_PACK(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_DRONE_USAGE( int p0, int p1, int p2) { invoke<void )
	{
		STATS::PLAYSTATS_DRONE_USAGE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SPIN_WHEEL( int p0, int p1, int p2, int p3) { invoke<void )
	{
		STATS::PLAYSTATS_SPIN_WHEEL(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ARENA_WARS_SPECTATOR( int p0, int p1, int p2, int p3, int p4) { invoke<void )
	{
		STATS::PLAYSTATS_ARENA_WARS_SPECTATOR(p0, p1, p2, p3, invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_ARENA_WARS_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_ARENA_WARS_ENDED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SWITCH_PASSIVE_MODE( bool p0, int p1, int p2, int p3) { invoke<void )
	{
		STATS::PLAYSTATS_SWITCH_PASSIVE_MODE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_COLLECTIBLE_PICKED_UP( int p0, unsigned objectHash, Any p2, Any p3, int moneyAmount, int rpAmount, int chipsAmount, Any p7, int p8, Any p9, Any p10) { invoke<void )
	{
		STATS::PLAYSTATS_COLLECTIBLE_PICKED_UP(p0, objectHash, p2, p3, moneyAmount, rpAmount, chipsAmount, p7, p8, p9, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_STORY_MISSION_ENDED( Any p0, Any p1) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_STORY_MISSION_ENDED(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_CHIP( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_CHIP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_ROULETTE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_ROULETTE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_BLACKJACK( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_BLACKJACK(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_THREE_CARD_POKER( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_THREE_CARD_POKER(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_SLOT_MACHINE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_SLOT_MACHINE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_INSIDE_TRACK( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_INSIDE_TRACK(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_LUCKY_SEVEN( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_LUCKY_SEVEN(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_ROULETTE_LIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_ROULETTE_LIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_BLACKJACK_LIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_BLACKJACK_LIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_THREE_CARD_POKER_LIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_THREE_CARD_POKER_LIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_SLOT_MACHINE_LIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_SLOT_MACHINE_LIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CASINO_INSIDE_TRACK_LIGHT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CASINO_INSIDE_TRACK_LIGHT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ARCADE_GAME( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<void )
	{
		STATS::PLAYSTATS_ARCADE_GAME(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ARCADE_LOVE_MATCH( Any p0, Any p1) { invoke<void )
	{
		STATS::PLAYSTATS_ARCADE_LOVE_MATCH(p0, invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_FREEMODE_CASINO_MISSION_ENDED( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_FREEMODE_CASINO_MISSION_ENDED(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST3_DRONE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST3_DRONE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST3_HACK( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST3_HACK(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_NPC_PHONE( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<void )
	{
		STATS::PLAYSTATS_NPC_PHONE(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ARCADE_CABINET( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ARCADE_CABINET(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST3_FINALE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST3_FINALE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST3_PREP( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST3_PREP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MASTER_CONTROL( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_MASTER_CONTROL(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_QUIT_MODE( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_QUIT_MODE(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_MISSION_VOTE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_MISSION_VOTE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_NJVS_VOTE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_NJVS_VOTE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_KILL_YOURSELF(  )
	{
		STATS::PLAYSTATS_KILL_YOURSELF();
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FM_MISSION_END( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::PLAYSTATS_FM_MISSION_END(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST4_PREP( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST4_PREP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST4_FINALE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST4_FINALE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HEIST4_HACK( Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		STATS::PLAYSTATS_HEIST4_HACK(p0, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SUB_WEAP( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_SUB_WEAP(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_FAST_TRVL( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<void )
	{
		STATS::PLAYSTATS_FAST_TRVL(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HUB_ENTRY( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HUB_ENTRY(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_DJ_MISSION_ENDED( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_DJ_MISSION_ENDED(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ROBBERY_PREP( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ROBBERY_PREP(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ROBBERY_FINALE( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ROBBERY_FINALE(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_EXTRA_EVENT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_EXTRA_EVENT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CARCLUB_POINTS( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_CARCLUB_POINTS(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CARCLUB_CHALLENGE( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_CARCLUB_CHALLENGE(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_CARCLUB_PRIZE( int p0, unsigned vehicleModel) { invoke<void )
	{
		STATS::PLAYSTATS_CARCLUB_PRIZE(p0, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_AWARD_NAV( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STATS::PLAYSTATS_AWARD_NAV(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_INST_MISSION_END( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_INST_MISSION_END(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_HUB_EXIT( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_HUB_EXIT(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_VEH_DEL( int bossId1, int bossId2, int bossType, int vehicleID, int reason) { invoke<void )
	{
		STATS::PLAYSTATS_VEH_DEL(bossId1, bossId2, bossType, vehicleID, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_INVENTORY( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_INVENTORY(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ACID_MISSION_END_( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ACID_MISSION_END_(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ACID_RND_( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ACID_RND_(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_IDLE_( Any p0, Any p1, Any p2) { invoke<void )
	{
		STATS::PLAYSTATS_IDLE_(p0, p1, invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_PLAYER_STYLE_( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_PLAYER_STYLE_(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_RANDOM_EVENT_( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_RANDOM_EVENT_(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_ATTRITION_STAGE_END_( Any p0) { invoke<void )
	{
		STATS::PLAYSTATS_ATTRITION_STAGE_END_(invoke<void);
	}

	void LUA_NATIVE_STATS_PLAYSTATS_SHOWROOM_NAV_( Any p0, Any p1, unsigned entity) { invoke<void )
	{
		STATS::PLAYSTATS_SHOWROOM_NAV_(p0, p1, invoke<void);
	}

	Any data) { LUA_NATIVE_STATS_PLAYSTATS_SHOWROOM_OVERVIEW_( Any data) { invoke<void )
	{
		STATS::PLAYSTATS_SHOWROOM_OVERVIEW_(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_STREAMING_LOAD_ALL_OBJECTS_NOW(  )
	{
		STREAMING::LOAD_ALL_OBJECTS_NOW();
	}

	void LUA_NATIVE_STREAMING_LOAD_SCENE( float x, float y, float z) { invoke<void )
	{
		STREAMING::LOAD_SCENE(x, y, invoke<void);
	}

	bool LUA_NATIVE_STREAMING_NETWORK_UPDATE_LOAD_SCENE(  )
	{
		auto retval = (bool)STREAMING::NETWORK_UPDATE_LOAD_SCENE();
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_NETWORK_LOADING_SCENE(  )
	{
		auto retval = (bool)STREAMING::IS_NETWORK_LOADING_SCENE();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_INTERIOR_ACTIVE( int interiorID, bool toggle) { invoke<void )
	{
		STREAMING::SET_INTERIOR_ACTIVE(interiorID, invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_MODEL( unsigned model) { invoke<void )
	{
		STREAMING::REQUEST_MODEL(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_MENU_PED_MODEL( unsigned model) { invoke<void )
	{
		STREAMING::REQUEST_MENU_PED_MODEL(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_MODEL_LOADED( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_MODEL_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REQUEST_MODELS_IN_ROOM( int interior, const char* roomName) { invoke<void )
	{
		STREAMING::REQUEST_MODELS_IN_ROOM(interior, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_MODEL_AS_NO_LONGER_NEEDED( unsigned model) { invoke<void )
	{
		STREAMING::SET_MODEL_AS_NO_LONGER_NEEDED(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_IS_MODEL_IN_CDIMAGE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_MODEL_IN_CDIMAGE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_MODEL_VALID( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_MODEL_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_MODEL_A_PED( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_MODEL_A_PED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_MODEL_A_VEHICLE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_MODEL_A_VEHICLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REQUEST_COLLISION_AT_COORD( float x, float y, float z) { invoke<void )
	{
		STREAMING::REQUEST_COLLISION_AT_COORD(x, y, invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_COLLISION_FOR_MODEL( unsigned model) { invoke<void )
	{
		STREAMING::REQUEST_COLLISION_FOR_MODEL(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_COLLISION_FOR_MODEL_LOADED( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_COLLISION_FOR_MODEL_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REQUEST_ADDITIONAL_COLLISION_AT_COORD( float x, float y, float z) { invoke<void )
	{
		STREAMING::REQUEST_ADDITIONAL_COLLISION_AT_COORD(x, y, invoke<void);
	}

	bool LUA_NATIVE_STREAMING_DOES_ANIM_DICT_EXIST( const char* animDict) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::DOES_ANIM_DICT_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REQUEST_ANIM_DICT( const char* animDict) { invoke<void )
	{
		STREAMING::REQUEST_ANIM_DICT(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_ANIM_DICT_LOADED( const char* animDict) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_ANIM_DICT_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_ANIM_DICT( const char* animDict) { invoke<void )
	{
		STREAMING::REMOVE_ANIM_DICT(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_ANIM_SET( const char* animSet) { invoke<void )
	{
		STREAMING::REQUEST_ANIM_SET(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_ANIM_SET_LOADED( const char* animSet) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_ANIM_SET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_ANIM_SET( const char* animSet) { invoke<void )
	{
		STREAMING::REMOVE_ANIM_SET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_CLIP_SET( const char* clipSet) { invoke<void )
	{
		STREAMING::REQUEST_CLIP_SET(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_CLIP_SET_LOADED( const char* clipSet) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_CLIP_SET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_CLIP_SET( const char* clipSet) { invoke<void )
	{
		STREAMING::REMOVE_CLIP_SET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REQUEST_IPL( const char* iplName) { invoke<void )
	{
		STREAMING::REQUEST_IPL(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REMOVE_IPL( const char* iplName) { invoke<void )
	{
		STREAMING::REMOVE_IPL(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_IS_IPL_ACTIVE( const char* iplName) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_IPL_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_STREAMING( bool toggle) { invoke<void )
	{
		STREAMING::SET_STREAMING(invoke<void);
	}

	void LUA_NATIVE_STREAMING_LOAD_GLOBAL_WATER_FILE( int waterType) { invoke<void )
	{
		STREAMING::LOAD_GLOBAL_WATER_FILE(invoke<void);
	}

	int LUA_NATIVE_STREAMING_GET_GLOBAL_WATER_FILE(  )
	{
		auto retval = STREAMING::GET_GLOBAL_WATER_FILE();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_GAME_PAUSES_FOR_STREAMING( bool toggle) { invoke<void )
	{
		STREAMING::SET_GAME_PAUSES_FOR_STREAMING(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_REDUCE_PED_MODEL_BUDGET( bool toggle) { invoke<void )
	{
		STREAMING::SET_REDUCE_PED_MODEL_BUDGET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_REDUCE_VEHICLE_MODEL_BUDGET( bool toggle) { invoke<void )
	{
		STREAMING::SET_REDUCE_VEHICLE_MODEL_BUDGET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_DITCH_POLICE_MODELS( bool toggle) { invoke<void )
	{
		STREAMING::SET_DITCH_POLICE_MODELS(invoke<void);
	}

	int LUA_NATIVE_STREAMING_GET_NUMBER_OF_STREAMING_REQUESTS(  )
	{
		auto retval = STREAMING::GET_NUMBER_OF_STREAMING_REQUESTS();
		return retval;
	}

	void LUA_NATIVE_STREAMING_REQUEST_PTFX_ASSET(  )
	{
		STREAMING::REQUEST_PTFX_ASSET();
	}

	bool LUA_NATIVE_STREAMING_HAS_PTFX_ASSET_LOADED(  )
	{
		auto retval = (bool)STREAMING::HAS_PTFX_ASSET_LOADED();
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_PTFX_ASSET(  )
	{
		STREAMING::REMOVE_PTFX_ASSET();
	}

	void LUA_NATIVE_STREAMING_REQUEST_NAMED_PTFX_ASSET( const char* fxName) { invoke<void )
	{
		STREAMING::REQUEST_NAMED_PTFX_ASSET(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_HAS_NAMED_PTFX_ASSET_LOADED( const char* fxName) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::HAS_NAMED_PTFX_ASSET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_NAMED_PTFX_ASSET( const char* fxName) { invoke<void )
	{
		STREAMING::REMOVE_NAMED_PTFX_ASSET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_VEHICLE_POPULATION_BUDGET( int p0) { invoke<void )
	{
		STREAMING::SET_VEHICLE_POPULATION_BUDGET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_PED_POPULATION_BUDGET( int p0) { invoke<void )
	{
		STREAMING::SET_PED_POPULATION_BUDGET(invoke<void);
	}

	void LUA_NATIVE_STREAMING_CLEAR_FOCUS(  )
	{
		STREAMING::CLEAR_FOCUS();
	}

	void LUA_NATIVE_STREAMING_SET_FOCUS_POS_AND_VEL( float x, float y, float z, float offsetX, float offsetY, float offsetZ) { invoke<void )
	{
		STREAMING::SET_FOCUS_POS_AND_VEL(x, y, z, offsetX, offsetY, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_FOCUS_ENTITY( int entity) { invoke<void )
	{
		STREAMING::SET_FOCUS_ENTITY(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_IS_ENTITY_FOCUS( int entity) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::IS_ENTITY_FOCUS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_RESTORE_FOCUS_ENTITY( int p0) { invoke<void )
	{
		STREAMING::SET_RESTORE_FOCUS_ENTITY(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_MAPDATACULLBOX_ENABLED( const char* name, bool toggle) { invoke<void )
	{
		STREAMING::SET_MAPDATACULLBOX_ENABLED(name, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_ALL_MAPDATA_CULLED( Any p0) { invoke<void )
	{
		STREAMING::SET_ALL_MAPDATA_CULLED(invoke<void);
	}

	int LUA_NATIVE_STREAMING_STREAMVOL_CREATE_SPHERE( float x, float y, float z, float rad, Any p4, Any p5) { return invoke<int )
	{
		auto retval = STREAMING::STREAMVOL_CREATE_SPHERE(x, y, z, rad, p4, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STREAMING_STREAMVOL_CREATE_FRUSTUM( float p0, float p1, float p2, float p3, float p4, float p5, float p6, Any p7, Any p8) { return invoke<int )
	{
		auto retval = STREAMING::STREAMVOL_CREATE_FRUSTUM(p0, p1, p2, p3, p4, p5, p6, p7, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STREAMING_STREAMVOL_CREATE_LINE( float p0, float p1, float p2, float p3, float p4, float p5, Any p6) { return invoke<int )
	{
		auto retval = STREAMING::STREAMVOL_CREATE_LINE(p0, p1, p2, p3, p4, p5, invoke<int);
		return retval;
	}

	void LUA_NATIVE_STREAMING_STREAMVOL_DELETE( Any unused) { invoke<void )
	{
		STREAMING::STREAMVOL_DELETE(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_STREAMVOL_HAS_LOADED( Any unused) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::STREAMVOL_HAS_LOADED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_STREAMVOL_IS_VALID( Any unused) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::STREAMVOL_IS_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_STREAMVOL_ACTIVE(  )
	{
		auto retval = (bool)STREAMING::IS_STREAMVOL_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_STREAMING_NEW_LOAD_SCENE_START( float posX, float posY, float posZ, float offsetX, float offsetY, float offsetZ, float radius, int p7) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::NEW_LOAD_SCENE_START(posX, posY, posZ, offsetX, offsetY, offsetZ, radius, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_STREAMING_NEW_LOAD_SCENE_START_SPHERE( float x, float y, float z, float radius, Any p4) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::NEW_LOAD_SCENE_START_SPHERE(x, y, z, radius, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_NEW_LOAD_SCENE_STOP(  )
	{
		STREAMING::NEW_LOAD_SCENE_STOP();
	}

	bool LUA_NATIVE_STREAMING_IS_NEW_LOAD_SCENE_ACTIVE(  )
	{
		auto retval = (bool)STREAMING::IS_NEW_LOAD_SCENE_ACTIVE();
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_NEW_LOAD_SCENE_LOADED(  )
	{
		auto retval = (bool)STREAMING::IS_NEW_LOAD_SCENE_LOADED();
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_SAFE_TO_START_PLAYER_SWITCH(  )
	{
		auto retval = (bool)STREAMING::IS_SAFE_TO_START_PLAYER_SWITCH();
		return retval;
	}

	void LUA_NATIVE_STREAMING_START_PLAYER_SWITCH( int from, int to, int flags, int switchType) { invoke<void )
	{
		STREAMING::START_PLAYER_SWITCH(from, to, flags, invoke<void);
	}

	void LUA_NATIVE_STREAMING_STOP_PLAYER_SWITCH(  )
	{
		STREAMING::STOP_PLAYER_SWITCH();
	}

	bool LUA_NATIVE_STREAMING_IS_PLAYER_SWITCH_IN_PROGRESS(  )
	{
		auto retval = (bool)STREAMING::IS_PLAYER_SWITCH_IN_PROGRESS();
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SWITCH_TYPE(  )
	{
		auto retval = STREAMING::GET_PLAYER_SWITCH_TYPE();
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_IDEAL_PLAYER_SWITCH_TYPE( float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<int )
	{
		auto retval = STREAMING::GET_IDEAL_PLAYER_SWITCH_TYPE(x1, y1, z1, x2, y2, invoke<int);
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SWITCH_STATE(  )
	{
		auto retval = STREAMING::GET_PLAYER_SWITCH_STATE();
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SHORT_SWITCH_STATE(  )
	{
		auto retval = STREAMING::GET_PLAYER_SHORT_SWITCH_STATE();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_PLAYER_SHORT_SWITCH_STYLE( int p0) { invoke<void )
	{
		STREAMING::SET_PLAYER_SHORT_SWITCH_STYLE(invoke<void);
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SWITCH_JUMP_CUT_INDEX(  )
	{
		auto retval = STREAMING::GET_PLAYER_SWITCH_JUMP_CUT_INDEX();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_PLAYER_SWITCH_OUTRO( float cameraCoordX, float cameraCoordY, float cameraCoordZ, float camRotationX, float camRotationY, float camRotationZ, float camFov, float camFarClip, int rotationOrder) { invoke<void )
	{
		STREAMING::SET_PLAYER_SWITCH_OUTRO(cameraCoordX, cameraCoordY, cameraCoordZ, camRotationX, camRotationY, camRotationZ, camFov, camFarClip, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_PLAYER_SWITCH_ESTABLISHING_SHOT( const char* name) { invoke<void )
	{
		STREAMING::SET_PLAYER_SWITCH_ESTABLISHING_SHOT(invoke<void);
	}

	void LUA_NATIVE_STREAMING_ALLOW_PLAYER_SWITCH_PAN(  )
	{
		STREAMING::ALLOW_PLAYER_SWITCH_PAN();
	}

	void LUA_NATIVE_STREAMING_ALLOW_PLAYER_SWITCH_OUTRO(  )
	{
		STREAMING::ALLOW_PLAYER_SWITCH_OUTRO();
	}

	void LUA_NATIVE_STREAMING_ALLOW_PLAYER_SWITCH_ASCENT(  )
	{
		STREAMING::ALLOW_PLAYER_SWITCH_ASCENT();
	}

	void LUA_NATIVE_STREAMING_ALLOW_PLAYER_SWITCH_DESCENT(  )
	{
		STREAMING::ALLOW_PLAYER_SWITCH_DESCENT();
	}

	bool LUA_NATIVE_STREAMING_IS_SWITCH_READY_FOR_DESCENT(  )
	{
		auto retval = (bool)STREAMING::IS_SWITCH_READY_FOR_DESCENT();
		return retval;
	}

	void LUA_NATIVE_STREAMING_ENABLE_SWITCH_PAUSE_BEFORE_DESCENT(  )
	{
		STREAMING::ENABLE_SWITCH_PAUSE_BEFORE_DESCENT();
	}

	void LUA_NATIVE_STREAMING_DISABLE_SWITCH_OUTRO_FX(  )
	{
		STREAMING::DISABLE_SWITCH_OUTRO_FX();
	}

	void LUA_NATIVE_STREAMING_SWITCH_TO_MULTI_FIRSTPART( int ped, int flags, int switchType) { invoke<void )
	{
		STREAMING::SWITCH_TO_MULTI_FIRSTPART(ped, flags, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SWITCH_TO_MULTI_SECONDPART( int ped) { invoke<void )
	{
		STREAMING::SWITCH_TO_MULTI_SECONDPART(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_IS_SWITCH_TO_MULTI_FIRSTPART_FINISHED(  )
	{
		auto retval = (bool)STREAMING::IS_SWITCH_TO_MULTI_FIRSTPART_FINISHED();
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SWITCH_INTERP_OUT_DURATION(  )
	{
		auto retval = STREAMING::GET_PLAYER_SWITCH_INTERP_OUT_DURATION();
		return retval;
	}

	int LUA_NATIVE_STREAMING_GET_PLAYER_SWITCH_INTERP_OUT_CURRENT_TIME(  )
	{
		auto retval = STREAMING::GET_PLAYER_SWITCH_INTERP_OUT_CURRENT_TIME();
		return retval;
	}

	bool LUA_NATIVE_STREAMING_IS_SWITCH_SKIPPING_DESCENT(  )
	{
		auto retval = (bool)STREAMING::IS_SWITCH_SKIPPING_DESCENT();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_SCENE_STREAMING_TRACKS_CAM_POS_THIS_FRAME(  )
	{
		STREAMING::SET_SCENE_STREAMING_TRACKS_CAM_POS_THIS_FRAME();
	}

	float LUA_NATIVE_STREAMING_GET_LODSCALE(  )
	{
		auto retval = STREAMING::GET_LODSCALE();
		return retval;
	}

	void LUA_NATIVE_STREAMING_OVERRIDE_LODSCALE_THIS_FRAME( float scaling) { invoke<void )
	{
		STREAMING::OVERRIDE_LODSCALE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_STREAMING_REMAP_LODSCALE_RANGE_THIS_FRAME( float p0, float p1, float p2, float p3) { invoke<void )
	{
		STREAMING::REMAP_LODSCALE_RANGE_THIS_FRAME(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SUPPRESS_HD_MAP_STREAMING_THIS_FRAME(  )
	{
		STREAMING::SUPPRESS_HD_MAP_STREAMING_THIS_FRAME();
	}

	void LUA_NATIVE_STREAMING_SET_RENDER_HD_ONLY( bool toggle) { invoke<void )
	{
		STREAMING::SET_RENDER_HD_ONLY(invoke<void);
	}

	void LUA_NATIVE_STREAMING_FORCE_ALLOW_TIME_BASED_FADING_THIS_FRAME(  )
	{
		STREAMING::FORCE_ALLOW_TIME_BASED_FADING_THIS_FRAME();
	}

	void LUA_NATIVE_STREAMING_IPL_GROUP_SWAP_START( const char* iplName1, const char* iplName2) { invoke<void )
	{
		STREAMING::IPL_GROUP_SWAP_START(iplName1, invoke<void);
	}

	void LUA_NATIVE_STREAMING_IPL_GROUP_SWAP_CANCEL(  )
	{
		STREAMING::IPL_GROUP_SWAP_CANCEL();
	}

	bool LUA_NATIVE_STREAMING_IPL_GROUP_SWAP_IS_READY(  )
	{
		auto retval = (bool)STREAMING::IPL_GROUP_SWAP_IS_READY();
		return retval;
	}

	void LUA_NATIVE_STREAMING_IPL_GROUP_SWAP_FINISH(  )
	{
		STREAMING::IPL_GROUP_SWAP_FINISH();
	}

	bool LUA_NATIVE_STREAMING_IPL_GROUP_SWAP_IS_ACTIVE(  )
	{
		auto retval = (bool)STREAMING::IPL_GROUP_SWAP_IS_ACTIVE();
		return retval;
	}

	void LUA_NATIVE_STREAMING_PREFETCH_SRL( const char* srl) { invoke<void )
	{
		STREAMING::PREFETCH_SRL(invoke<void);
	}

	bool LUA_NATIVE_STREAMING_IS_SRL_LOADED(  )
	{
		auto retval = (bool)STREAMING::IS_SRL_LOADED();
		return retval;
	}

	void LUA_NATIVE_STREAMING_BEGIN_SRL(  )
	{
		STREAMING::BEGIN_SRL();
	}

	void LUA_NATIVE_STREAMING_END_SRL(  )
	{
		STREAMING::END_SRL();
	}

	void LUA_NATIVE_STREAMING_SET_SRL_TIME( float p0) { invoke<void )
	{
		STREAMING::SET_SRL_TIME(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_SRL_POST_CUTSCENE_CAMERA( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		STREAMING::SET_SRL_POST_CUTSCENE_CAMERA(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_SRL_READAHEAD_TIMES( Any p0, Any p1, Any p2, Any p3) { invoke<void )
	{
		STREAMING::SET_SRL_READAHEAD_TIMES(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_SRL_LONG_JUMP_MODE( bool p0) { invoke<void )
	{
		STREAMING::SET_SRL_LONG_JUMP_MODE(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_SRL_FORCE_PRESTREAM( Any p0) { invoke<void )
	{
		STREAMING::SET_SRL_FORCE_PRESTREAM(invoke<void);
	}

	void LUA_NATIVE_STREAMING_SET_HD_AREA( float x, float y, float z, float radius) { invoke<void )
	{
		STREAMING::SET_HD_AREA(x, y, z, invoke<void);
	}

	void LUA_NATIVE_STREAMING_CLEAR_HD_AREA(  )
	{
		STREAMING::CLEAR_HD_AREA();
	}

	void LUA_NATIVE_STREAMING_INIT_CREATOR_BUDGET(  )
	{
		STREAMING::INIT_CREATOR_BUDGET();
	}

	void LUA_NATIVE_STREAMING_SHUTDOWN_CREATOR_BUDGET(  )
	{
		STREAMING::SHUTDOWN_CREATOR_BUDGET();
	}

	bool LUA_NATIVE_STREAMING_ADD_MODEL_TO_CREATOR_BUDGET( unsigned modelHash) { return invoke<BOOL )
	{
		auto retval = (bool)STREAMING::ADD_MODEL_TO_CREATOR_BUDGET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_STREAMING_REMOVE_MODEL_FROM_CREATOR_BUDGET( unsigned modelHash) { invoke<void )
	{
		STREAMING::REMOVE_MODEL_FROM_CREATOR_BUDGET(invoke<void);
	}

	float LUA_NATIVE_STREAMING_GET_USED_CREATOR_BUDGET(  )
	{
		auto retval = STREAMING::GET_USED_CREATOR_BUDGET();
		return retval;
	}

	void LUA_NATIVE_STREAMING_SET_ISLAND_ENABLED( const char* name, bool toggle) { invoke<void )
	{
		STREAMING::SET_ISLAND_ENABLED(name, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PAUSE( int ped, int ms) { invoke<void )
	{
		TASK::TASK_PAUSE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_STAND_STILL( int ped, int time) { invoke<void )
	{
		TASK::TASK_STAND_STILL(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_JUMP( int ped, bool usePlayerLaunchForce, bool doSuperJump, bool useFullSuperJumpForce) { invoke<void )
	{
		TASK::TASK_JUMP(ped, usePlayerLaunchForce, doSuperJump, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COWER( int ped, int duration) { invoke<void )
	{
		TASK::TASK_COWER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_HANDS_UP( int ped, int duration, int facingPed, int timeToFacePed, int flags) { invoke<void )
	{
		TASK::TASK_HANDS_UP(ped, duration, facingPed, timeToFacePed, invoke<void);
	}

	void LUA_NATIVE_TASK_UPDATE_TASK_HANDS_UP_DURATION( int ped, int duration) { invoke<void )
	{
		TASK::UPDATE_TASK_HANDS_UP_DURATION(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_OPEN_VEHICLE_DOOR( int ped, int vehicle, int timeOut, int seat, float speed) { invoke<void )
	{
		TASK::TASK_OPEN_VEHICLE_DOOR(ped, vehicle, timeOut, seat, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_ENTER_VEHICLE( int ped, int vehicle, int timeout, int seat, float speed, int flag, const char* overrideEntryClipsetName) { invoke<void )
	{
		TASK::TASK_ENTER_VEHICLE(ped, vehicle, timeout, seat, speed, flag, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_LEAVE_VEHICLE( int ped, int vehicle, int flags) { invoke<void )
	{
		TASK::TASK_LEAVE_VEHICLE(ped, vehicle, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GET_OFF_BOAT( int ped, int boat) { invoke<void )
	{
		TASK::TASK_GET_OFF_BOAT(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SKY_DIVE( int ped, bool instant) { invoke<void )
	{
		TASK::TASK_SKY_DIVE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PARACHUTE( int ped, bool giveParachuteItem, bool instant) { invoke<void )
	{
		TASK::TASK_PARACHUTE(ped, giveParachuteItem, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PARACHUTE_TO_TARGET( int ped, float x, float y, float z) { invoke<void )
	{
		TASK::TASK_PARACHUTE_TO_TARGET(ped, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PARACHUTE_TASK_TARGET( int ped, float x, float y, float z) { invoke<void )
	{
		TASK::SET_PARACHUTE_TASK_TARGET(ped, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PARACHUTE_TASK_THRUST( int ped, float thrust) { invoke<void )
	{
		TASK::SET_PARACHUTE_TASK_THRUST(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_RAPPEL_FROM_HELI( int ped, float minHeightAboveGround) { invoke<void )
	{
		TASK::TASK_RAPPEL_FROM_HELI(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_DRIVE_TO_COORD( int ped, int vehicle, float x, float y, float z, float speed, Any p6, unsigned vehicleModel, int drivingMode, float stopRange, float straightLineDistance) { invoke<void )
	{
		TASK::TASK_VEHICLE_DRIVE_TO_COORD(ped, vehicle, x, y, z, speed, p6, vehicleModel, drivingMode, stopRange, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_DRIVE_TO_COORD_LONGRANGE( int ped, int vehicle, float x, float y, float z, float speed, int driveMode, float stopRange) { invoke<void )
	{
		TASK::TASK_VEHICLE_DRIVE_TO_COORD_LONGRANGE(ped, vehicle, x, y, z, speed, driveMode, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_DRIVE_WANDER( int ped, int vehicle, float speed, int drivingStyle) { invoke<void )
	{
		TASK::TASK_VEHICLE_DRIVE_WANDER(ped, vehicle, speed, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FOLLOW_TO_OFFSET_OF_ENTITY( int ped, int entity, float offsetX, float offsetY, float offsetZ, float movementSpeed, int timeout, float stoppingRange, bool persistFollowing) { invoke<void )
	{
		TASK::TASK_FOLLOW_TO_OFFSET_OF_ENTITY(ped, entity, offsetX, offsetY, offsetZ, movementSpeed, timeout, stoppingRange, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_STRAIGHT_TO_COORD( int ped, float x, float y, float z, float speed, int timeout, float targetHeading, float distanceToSlide) { invoke<void )
	{
		TASK::TASK_GO_STRAIGHT_TO_COORD(ped, x, y, z, speed, timeout, targetHeading, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_STRAIGHT_TO_COORD_RELATIVE_TO_ENTITY( int ped, int entity, float x, float y, float z, float moveBlendRatio, int time) { invoke<void )
	{
		TASK::TASK_GO_STRAIGHT_TO_COORD_RELATIVE_TO_ENTITY(ped, entity, x, y, z, moveBlendRatio, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_ACHIEVE_HEADING( int ped, float heading, int timeout) { invoke<void )
	{
		TASK::TASK_ACHIEVE_HEADING(ped, heading, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FLUSH_ROUTE(  )
	{
		TASK::TASK_FLUSH_ROUTE();
	}

	void LUA_NATIVE_TASK_TASK_EXTEND_ROUTE( float x, float y, float z) { invoke<void )
	{
		TASK::TASK_EXTEND_ROUTE(x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FOLLOW_POINT_ROUTE( int ped, float speed, int mode) { invoke<void )
	{
		TASK::TASK_FOLLOW_POINT_ROUTE(ped, speed, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_ENTITY( int entity, int target, int duration, float distance, float moveBlendRatio, float slowDownDistance, int flags) { invoke<void )
	{
		TASK::TASK_GO_TO_ENTITY(entity, target, duration, distance, moveBlendRatio, slowDownDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SMART_FLEE_COORD( int ped, float x, float y, float z, float distance, int time, bool preferPavements, bool quitIfOutOfRange) { invoke<void )
	{
		TASK::TASK_SMART_FLEE_COORD(ped, x, y, z, distance, time, preferPavements, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SMART_FLEE_PED( int ped, int fleeTarget, float safeDistance, int fleeTime, bool preferPavements, bool updateToNearestHatedPed) { invoke<void )
	{
		TASK::TASK_SMART_FLEE_PED(ped, fleeTarget, safeDistance, fleeTime, preferPavements, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_REACT_AND_FLEE_PED( int ped, int fleeTarget) { invoke<void )
	{
		TASK::TASK_REACT_AND_FLEE_PED(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SHOCKING_EVENT_REACT( int ped, int eventHandle) { invoke<void )
	{
		TASK::TASK_SHOCKING_EVENT_REACT(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_WANDER_IN_AREA( int ped, float x, float y, float z, float radius, float minimalLength, float timeBetweenWalks) { invoke<void )
	{
		TASK::TASK_WANDER_IN_AREA(ped, x, y, z, radius, minimalLength, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_WANDER_STANDARD( int ped, float heading, int flags) { invoke<void )
	{
		TASK::TASK_WANDER_STANDARD(ped, heading, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_WANDER_SPECIFIC( int ped, const char* conditionalAnimGroupStr, const char* conditionalAnimStr, float heading) { invoke<void )
	{
		TASK::TASK_WANDER_SPECIFIC(ped, conditionalAnimGroupStr, conditionalAnimStr, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_PARK( int ped, int vehicle, float x, float y, float z, float heading, int mode, float radius, bool keepEngineOn) { invoke<void )
	{
		TASK::TASK_VEHICLE_PARK(ped, vehicle, x, y, z, heading, mode, radius, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_STEALTH_KILL( int killer, int target, unsigned stealthKillActionResultHash, float desiredMoveBlendRatio, int stealthFlags) { invoke<void )
	{
		TASK::TASK_STEALTH_KILL(killer, target, stealthKillActionResultHash, desiredMoveBlendRatio, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANT_BOMB( int ped, float x, float y, float z, float heading) { invoke<void )
	{
		TASK::TASK_PLANT_BOMB(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FOLLOW_NAV_MESH_TO_COORD( int ped, float x, float y, float z, float moveBlendRatio, int time, float targetRadius, int flags, float targetHeading) { invoke<void )
	{
		TASK::TASK_FOLLOW_NAV_MESH_TO_COORD(ped, x, y, z, moveBlendRatio, time, targetRadius, flags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FOLLOW_NAV_MESH_TO_COORD_ADVANCED( int ped, float x, float y, float z, float moveBlendRatio, int time, float targetRadius, int flags, float slideToCoordHeading, float maxSlopeNavigable, float clampMaxSearchDistance, float targetHeading) { invoke<void )
	{
		TASK::TASK_FOLLOW_NAV_MESH_TO_COORD_ADVANCED(ped, x, y, z, moveBlendRatio, time, targetRadius, flags, slideToCoordHeading, maxSlopeNavigable, clampMaxSearchDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_CAN_USE_CLIMBOVERS( int ped, bool Toggle) { invoke<void )
	{
		TASK::SET_PED_PATH_CAN_USE_CLIMBOVERS(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_CAN_USE_LADDERS( int ped, bool Toggle) { invoke<void )
	{
		TASK::SET_PED_PATH_CAN_USE_LADDERS(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_CAN_DROP_FROM_HEIGHT( int ped, bool Toggle) { invoke<void )
	{
		TASK::SET_PED_PATH_CAN_DROP_FROM_HEIGHT(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_CLIMB_COST_MODIFIER( int ped, float modifier) { invoke<void )
	{
		TASK::SET_PED_PATH_CLIMB_COST_MODIFIER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_MAY_ENTER_WATER( int ped, bool mayEnterWater) { invoke<void )
	{
		TASK::SET_PED_PATH_MAY_ENTER_WATER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_PREFER_TO_AVOID_WATER( int ped, bool avoidWater) { invoke<void )
	{
		TASK::SET_PED_PATH_PREFER_TO_AVOID_WATER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_PATH_AVOID_FIRE( int ped, bool avoidFire) { invoke<void )
	{
		TASK::SET_PED_PATH_AVOID_FIRE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_GLOBAL_MIN_BIRD_FLIGHT_HEIGHT( float height) { invoke<void )
	{
		TASK::SET_GLOBAL_MIN_BIRD_FLIGHT_HEIGHT(invoke<void);
	}

	std::tuple<int, float, bool isPathReady) { return> LUA_NATIVE_TASK_GET_NAVMESH_ROUTE_DISTANCE_REMAINING( int ped, float distanceRemaining, bool isPathReady) { return invoke<int )
	{
		std::tuple<int, float, bool isPathReady) { return> return_values;
		std::get<0>(return_values) = TASK::GET_NAVMESH_ROUTE_DISTANCE_REMAINING(ped, &distanceRemaining, &invoke<int);
		std::get<1>(return_values) = distanceRemaining;
		std::get<2>(return_values) = invoke<int;

		return return_values;
	}

	int LUA_NATIVE_TASK_GET_NAVMESH_ROUTE_RESULT( int ped) { return invoke<int )
	{
		auto retval = TASK::GET_NAVMESH_ROUTE_RESULT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_CONTROLLED_VEHICLE_UNABLE_TO_GET_TO_ROAD( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_CONTROLLED_VEHICLE_UNABLE_TO_GET_TO_ROAD(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_ANY_MEANS( int ped, float x, float y, float z, float moveBlendRatio, int vehicle, bool useLongRangeVehiclePathing, int drivingFlags, float maxRangeToShootTargets) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_ANY_MEANS(ped, x, y, z, moveBlendRatio, vehicle, useLongRangeVehiclePathing, drivingFlags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_ANY_MEANS_EXTRA_PARAMS( int ped, float x, float y, float z, float moveBlendRatio, int vehicle, bool useLongRangeVehiclePathing, int drivingFlags, float maxRangeToShootTargets, float extraVehToTargetDistToPreferVehicle, float driveStraightLineDistance, int extraFlags, float warpTimerMS) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_ANY_MEANS_EXTRA_PARAMS(ped, x, y, z, moveBlendRatio, vehicle, useLongRangeVehiclePathing, drivingFlags, maxRangeToShootTargets, extraVehToTargetDistToPreferVehicle, driveStraightLineDistance, extraFlags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_ANY_MEANS_EXTRA_PARAMS_WITH_CRUISE_SPEED( int ped, float x, float y, float z, float moveBlendRatio, int vehicle, bool useLongRangeVehiclePathing, int drivingFlags, float maxRangeToShootTargets, float extraVehToTargetDistToPreferVehicle, float driveStraightLineDistance, int extraFlags, float cruiseSpeed, float targetArriveDist) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_ANY_MEANS_EXTRA_PARAMS_WITH_CRUISE_SPEED(ped, x, y, z, moveBlendRatio, vehicle, useLongRangeVehiclePathing, drivingFlags, maxRangeToShootTargets, extraVehToTargetDistToPreferVehicle, driveStraightLineDistance, extraFlags, cruiseSpeed, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLAY_ANIM( int ped, const char* animDictionary, const char* animationName, float blendInSpeed, float blendOutSpeed, int duration, int flag, float playbackRate, bool lockX, bool lockY, bool lockZ) { invoke<void )
	{
		TASK::TASK_PLAY_ANIM(ped, animDictionary, animationName, blendInSpeed, blendOutSpeed, duration, flag, playbackRate, lockX, lockY, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLAY_ANIM_ADVANCED( int ped, const char* animDict, const char* animName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float animEnterSpeed, float animExitSpeed, int duration, Any flag, float animTime, int rotOrder, int ikFlags) { invoke<void )
	{
		TASK::TASK_PLAY_ANIM_ADVANCED(ped, animDict, animName, posX, posY, posZ, rotX, rotY, rotZ, animEnterSpeed, animExitSpeed, duration, flag, animTime, rotOrder, invoke<void);
	}

	void LUA_NATIVE_TASK_STOP_ANIM_TASK( int entity, const char* animDictionary, const char* animationName, float blendDelta) { invoke<void )
	{
		TASK::STOP_ANIM_TASK(entity, animDictionary, animationName, invoke<void);
	}

	std::tuple<int, int, int> LUA_NATIVE_TASK_TASK_SCRIPTED_ANIMATION( int ped, int priorityLowData, int priorityMidData, int priorityHighData, float blendInDelta, float blendOutDelta) { invoke<void )
	{
		std::tuple<int, int, int> return_values;
		TASK::TASK_SCRIPTED_ANIMATION(ped, &priorityLowData, &priorityMidData, &priorityHighData, blendInDelta, invoke<void);
		std::get<0>(return_values) = priorityLowData;
		std::get<1>(return_values) = priorityMidData;
		std::get<2>(return_values) = priorityHighData;

		return return_values;
	}

	std::tuple<int, int, int> LUA_NATIVE_TASK_PLAY_ENTITY_SCRIPTED_ANIM( int entity, int priorityLowData, int priorityMidData, int priorityHighData, float blendInDelta, float blendOutDelta) { invoke<void )
	{
		std::tuple<int, int, int> return_values;
		TASK::PLAY_ENTITY_SCRIPTED_ANIM(entity, &priorityLowData, &priorityMidData, &priorityHighData, blendInDelta, invoke<void);
		std::get<0>(return_values) = priorityLowData;
		std::get<1>(return_values) = priorityMidData;
		std::get<2>(return_values) = priorityHighData;

		return return_values;
	}

	void LUA_NATIVE_TASK_STOP_ANIM_PLAYBACK( int entity, int priority, bool secondary) { invoke<void )
	{
		TASK::STOP_ANIM_PLAYBACK(entity, priority, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_ANIM_WEIGHT( int entity, float weight, int priority, int index, bool secondary) { invoke<void )
	{
		TASK::SET_ANIM_WEIGHT(entity, weight, priority, index, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_ANIM_PHASE( int entity, float phase, int priority, bool secondary) { invoke<void )
	{
		TASK::SET_ANIM_PHASE(entity, phase, priority, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_ANIM_RATE( int entity, float rate, int priority, bool secondary) { invoke<void )
	{
		TASK::SET_ANIM_RATE(entity, rate, priority, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_ANIM_LOOPED( int entity, bool looped, int priority, bool secondary) { invoke<void )
	{
		TASK::SET_ANIM_LOOPED(entity, looped, priority, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLAY_PHONE_GESTURE_ANIMATION( int ped, const char* animDict, const char* animation, const char* boneMaskType, float blendInDuration, float blendOutDuration, bool isLooping, bool holdLastFrame) { invoke<void )
	{
		TASK::TASK_PLAY_PHONE_GESTURE_ANIMATION(ped, animDict, animation, boneMaskType, blendInDuration, blendOutDuration, isLooping, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_STOP_PHONE_GESTURE_ANIMATION( int ped, float blendOutOverride) { invoke<void )
	{
		TASK::TASK_STOP_PHONE_GESTURE_ANIMATION(ped, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_PLAYING_PHONE_GESTURE_ANIM( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PLAYING_PHONE_GESTURE_ANIM(invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_TASK_GET_PHONE_GESTURE_ANIM_CURRENT_TIME( int ped) { return invoke<float )
	{
		auto retval = TASK::GET_PHONE_GESTURE_ANIM_CURRENT_TIME(invoke<float);
		return retval;
	}

	float LUA_NATIVE_TASK_GET_PHONE_GESTURE_ANIM_TOTAL_TIME( int ped) { return invoke<float )
	{
		auto retval = TASK::GET_PHONE_GESTURE_ANIM_TOTAL_TIME(invoke<float);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_PLAY_ANIM( int vehicle, const char* animationSet, const char* animationName) { invoke<void )
	{
		TASK::TASK_VEHICLE_PLAY_ANIM(vehicle, animationSet, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_LOOK_AT_COORD( int entity, float x, float y, float z, int duration, int flags, int priority) { invoke<void )
	{
		TASK::TASK_LOOK_AT_COORD(entity, x, y, z, duration, flags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_LOOK_AT_ENTITY( int ped, int lookAt, int duration, int flags, int priority) { invoke<void )
	{
		TASK::TASK_LOOK_AT_ENTITY(ped, lookAt, duration, flags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_CLEAR_LOOK_AT( int ped) { invoke<void )
	{
		TASK::TASK_CLEAR_LOOK_AT(invoke<void);
	}

	int taskSequenceId) { LUA_NATIVE_TASK_OPEN_SEQUENCE_TASK( int taskSequenceId) { invoke<void )
	{
		TASK::OPEN_SEQUENCE_TASK(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_TASK_CLOSE_SEQUENCE_TASK( int taskSequenceId) { invoke<void )
	{
		TASK::CLOSE_SEQUENCE_TASK(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PERFORM_SEQUENCE( int ped, int taskSequenceId) { invoke<void )
	{
		TASK::TASK_PERFORM_SEQUENCE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PERFORM_SEQUENCE_LOCALLY( int ped, int taskSequenceId) { invoke<void )
	{
		TASK::TASK_PERFORM_SEQUENCE_LOCALLY(ped, invoke<void);
	}

	int taskSequenceId) { LUA_NATIVE_TASK_CLEAR_SEQUENCE_TASK( int taskSequenceId) { invoke<void )
	{
		TASK::CLEAR_SEQUENCE_TASK(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_TASK_SET_SEQUENCE_TO_REPEAT( int taskSequenceId, bool repeat) { invoke<void )
	{
		TASK::SET_SEQUENCE_TO_REPEAT(taskSequenceId, invoke<void);
	}

	int LUA_NATIVE_TASK_GET_SEQUENCE_PROGRESS( int ped) { return invoke<int )
	{
		auto retval = TASK::GET_SEQUENCE_PROGRESS(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_TASK_GET_IS_TASK_ACTIVE( int ped, int taskIndex) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::GET_IS_TASK_ACTIVE(ped, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_TASK_GET_SCRIPT_TASK_STATUS( int ped, unsigned taskHash) { return invoke<int )
	{
		auto retval = TASK::GET_SCRIPT_TASK_STATUS(ped, invoke<int);
		return retval;
	}

	int LUA_NATIVE_TASK_GET_ACTIVE_VEHICLE_MISSION_TYPE( int vehicle) { return invoke<int )
	{
		auto retval = TASK::GET_ACTIVE_VEHICLE_MISSION_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_LEAVE_ANY_VEHICLE( int ped, int delayTime, int flags) { invoke<void )
	{
		TASK::TASK_LEAVE_ANY_VEHICLE(ped, delayTime, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_AIM_GUN_SCRIPTED( int ped, unsigned scriptTask, bool disableBlockingClip, bool instantBlendToAim) { invoke<void )
	{
		TASK::TASK_AIM_GUN_SCRIPTED(ped, scriptTask, disableBlockingClip, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_AIM_GUN_SCRIPTED_WITH_TARGET( int ped, int target, float x, float y, float z, int gunTaskType, bool disableBlockingClip, bool forceAim) { invoke<void )
	{
		TASK::TASK_AIM_GUN_SCRIPTED_WITH_TARGET(ped, target, x, y, z, gunTaskType, disableBlockingClip, invoke<void);
	}

	void LUA_NATIVE_TASK_UPDATE_TASK_AIM_GUN_SCRIPTED_TARGET( int ped, int target, float x, float y, float z, bool disableBlockingClip) { invoke<void )
	{
		TASK::UPDATE_TASK_AIM_GUN_SCRIPTED_TARGET(ped, target, x, y, z, invoke<void);
	}

	const char* LUA_NATIVE_TASK_GET_CLIP_SET_FOR_SCRIPTED_GUN_TASK( int gunTaskType) { return invoke<const char* )
	{
		auto retval = TASK::GET_CLIP_SET_FOR_SCRIPTED_GUN_TASK(char*);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_AIM_GUN_AT_ENTITY( int ped, int entity, int duration, bool instantBlendToAim) { invoke<void )
	{
		TASK::TASK_AIM_GUN_AT_ENTITY(ped, entity, duration, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_TURN_PED_TO_FACE_ENTITY( int ped, int entity, int duration) { invoke<void )
	{
		TASK::TASK_TURN_PED_TO_FACE_ENTITY(ped, entity, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_AIM_GUN_AT_COORD( int ped, float x, float y, float z, int time, bool instantBlendToAim, bool playAnimIntro) { invoke<void )
	{
		TASK::TASK_AIM_GUN_AT_COORD(ped, x, y, z, time, instantBlendToAim, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SHOOT_AT_COORD( int ped, float x, float y, float z, int duration, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_SHOOT_AT_COORD(ped, x, y, z, duration, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT( int ped, int vehicle, bool useAlternateShuffle) { invoke<void )
	{
		TASK::TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT(ped, vehicle, invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_PED_TASKS( int ped) { invoke<void )
	{
		TASK::CLEAR_PED_TASKS(invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_PED_SECONDARY_TASK( int ped) { invoke<void )
	{
		TASK::CLEAR_PED_SECONDARY_TASK(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_EVERYONE_LEAVE_VEHICLE( int vehicle) { invoke<void )
	{
		TASK::TASK_EVERYONE_LEAVE_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GOTO_ENTITY_OFFSET( int ped, int entity, int time, float seekRadius, float seekAngleDeg, float moveBlendRatio, int gotoEntityOffsetFlags) { invoke<void )
	{
		TASK::TASK_GOTO_ENTITY_OFFSET(ped, entity, time, seekRadius, seekAngleDeg, moveBlendRatio, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GOTO_ENTITY_OFFSET_XY( int ped, int entity, int duration, float targetRadius, float offsetX, float offsetY, float moveBlendRatio, int gotoEntityOffsetFlags) { invoke<void )
	{
		TASK::TASK_GOTO_ENTITY_OFFSET_XY(ped, entity, duration, targetRadius, offsetX, offsetY, moveBlendRatio, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_TURN_PED_TO_FACE_COORD( int ped, float x, float y, float z, int duration) { invoke<void )
	{
		TASK::TASK_TURN_PED_TO_FACE_COORD(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_TEMP_ACTION( int driver, int vehicle, int action, int time) { invoke<void )
	{
		TASK::TASK_VEHICLE_TEMP_ACTION(driver, vehicle, action, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_MISSION( int driver, int vehicle, int vehicleTarget, int missionType, float cruiseSpeed, int drivingStyle, float targetReached, float straightLineDistance, bool DriveAgainstTraffic) { invoke<void )
	{
		TASK::TASK_VEHICLE_MISSION(driver, vehicle, vehicleTarget, missionType, cruiseSpeed, drivingStyle, targetReached, straightLineDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_MISSION_PED_TARGET( int ped, int vehicle, int pedTarget, int missionType, float maxSpeed, int drivingStyle, float minDistance, float straightLineDistance, bool DriveAgainstTraffic) { invoke<void )
	{
		TASK::TASK_VEHICLE_MISSION_PED_TARGET(ped, vehicle, pedTarget, missionType, maxSpeed, drivingStyle, minDistance, straightLineDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_MISSION_COORS_TARGET( int ped, int vehicle, float x, float y, float z, int mission, float cruiseSpeed, int drivingStyle, float targetReached, float straightLineDistance, bool DriveAgainstTraffic) { invoke<void )
	{
		TASK::TASK_VEHICLE_MISSION_COORS_TARGET(ped, vehicle, x, y, z, mission, cruiseSpeed, drivingStyle, targetReached, straightLineDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_ESCORT( int ped, int vehicle, int targetVehicle, int mode, float speed, int drivingStyle, float minDistance, int minHeightAboveTerrain, float noRoadsDistance) { invoke<void )
	{
		TASK::TASK_VEHICLE_ESCORT(ped, vehicle, targetVehicle, mode, speed, drivingStyle, minDistance, minHeightAboveTerrain, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_FOLLOW( int driver, int vehicle, int targetEntity, float speed, int drivingStyle, int minDistance) { invoke<void )
	{
		TASK::TASK_VEHICLE_FOLLOW(driver, vehicle, targetEntity, speed, drivingStyle, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_CHASE( int driver, int targetEnt) { invoke<void )
	{
		TASK::TASK_VEHICLE_CHASE(driver, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_HELI_PROTECT( int pilot, int vehicle, int entityToFollow, float targetSpeed, int drivingFlags, float radius, int altitude, int heliFlags) { invoke<void )
	{
		TASK::TASK_VEHICLE_HELI_PROTECT(pilot, vehicle, entityToFollow, targetSpeed, drivingFlags, radius, altitude, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_VEHICLE_CHASE_BEHAVIOR_FLAG( int ped, int flag, bool set) { invoke<void )
	{
		TASK::SET_TASK_VEHICLE_CHASE_BEHAVIOR_FLAG(ped, flag, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_VEHICLE_CHASE_IDEAL_PURSUIT_DISTANCE( int ped, float distance) { invoke<void )
	{
		TASK::SET_TASK_VEHICLE_CHASE_IDEAL_PURSUIT_DISTANCE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_HELI_CHASE( int pilot, int entityToFollow, float x, float y, float z) { invoke<void )
	{
		TASK::TASK_HELI_CHASE(pilot, entityToFollow, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANE_CHASE( int pilot, int entityToFollow, float x, float y, float z) { invoke<void )
	{
		TASK::TASK_PLANE_CHASE(pilot, entityToFollow, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANE_LAND( int pilot, int plane, float runwayStartX, float runwayStartY, float runwayStartZ, float runwayEndX, float runwayEndY, float runwayEndZ) { invoke<void )
	{
		TASK::TASK_PLANE_LAND(pilot, plane, runwayStartX, runwayStartY, runwayStartZ, runwayEndX, runwayEndY, invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_DEFAULT_PRIMARY_TASK( int ped) { invoke<void )
	{
		TASK::CLEAR_DEFAULT_PRIMARY_TASK(invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_PRIMARY_VEHICLE_TASK( int vehicle) { invoke<void )
	{
		TASK::CLEAR_PRIMARY_VEHICLE_TASK(invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_VEHICLE_CRASH_TASK( int vehicle) { invoke<void )
	{
		TASK::CLEAR_VEHICLE_CRASH_TASK(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANE_GOTO_PRECISE_VTOL( int ped, int vehicle, float x, float y, float z, int flightHeight, int minHeightAboveTerrain, bool useDesiredOrientation, float desiredOrientation, bool autopilot) { invoke<void )
	{
		TASK::TASK_PLANE_GOTO_PRECISE_VTOL(ped, vehicle, x, y, z, flightHeight, minHeightAboveTerrain, useDesiredOrientation, desiredOrientation, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SUBMARINE_GOTO_AND_STOP( int ped, int submarine, float x, float y, float z, bool autopilot) { invoke<void )
	{
		TASK::TASK_SUBMARINE_GOTO_AND_STOP(ped, submarine, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_HELI_MISSION( int pilot, int aircraft, int targetVehicle, int targetPed, float destinationX, float destinationY, float destinationZ, int missionFlag, float maxSpeed, float radius, float targetHeading, int maxHeight, int minHeight, float slowDownDistance, int behaviorFlags) { invoke<void )
	{
		TASK::TASK_HELI_MISSION(pilot, aircraft, targetVehicle, targetPed, destinationX, destinationY, destinationZ, missionFlag, maxSpeed, radius, targetHeading, maxHeight, minHeight, slowDownDistance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_HELI_ESCORT_HELI( int pilot, int heli1, int heli2, float offsetX, float offsetY, float offsetZ) { invoke<void )
	{
		TASK::TASK_HELI_ESCORT_HELI(pilot, heli1, heli2, offsetX, offsetY, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANE_MISSION( int pilot, int aircraft, int targetVehicle, int targetPed, float destinationX, float destinationY, float destinationZ, int missionFlag, float angularDrag, float targetReached, float targetHeading, float maxZ, float minZ, bool precise) { invoke<void )
	{
		TASK::TASK_PLANE_MISSION(pilot, aircraft, targetVehicle, targetPed, destinationX, destinationY, destinationZ, missionFlag, angularDrag, targetReached, targetHeading, maxZ, minZ, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PLANE_TAXI( int pilot, int aircraft, float x, float y, float z, float cruiseSpeed, float targetReached) { invoke<void )
	{
		TASK::TASK_PLANE_TAXI(pilot, aircraft, x, y, z, cruiseSpeed, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_BOAT_MISSION( int pedDriver, int vehicle, int targetVehicle, int targetPed, float x, float y, float z, int mission, float maxSpeed, int drivingStyle, float targetReached, Any boatFlags) { invoke<void )
	{
		TASK::TASK_BOAT_MISSION(pedDriver, vehicle, targetVehicle, targetPed, x, y, z, mission, maxSpeed, drivingStyle, targetReached, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_DRIVE_BY( int driverPed, int targetPed, int targetVehicle, float targetX, float targetY, float targetZ, float distanceToShoot, int pedAccuracy, bool pushUnderneathDrivingTaskIfDriving, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_DRIVE_BY(driverPed, targetPed, targetVehicle, targetX, targetY, targetZ, distanceToShoot, pedAccuracy, pushUnderneathDrivingTaskIfDriving, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_DRIVEBY_TASK_TARGET( int shootingPed, int targetPed, int targetVehicle, float x, float y, float z) { invoke<void )
	{
		TASK::SET_DRIVEBY_TASK_TARGET(shootingPed, targetPed, targetVehicle, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_CLEAR_DRIVEBY_TASK_UNDERNEATH_DRIVING_TASK( int ped) { invoke<void )
	{
		TASK::CLEAR_DRIVEBY_TASK_UNDERNEATH_DRIVING_TASK(invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_DRIVEBY_TASK_UNDERNEATH_DRIVING_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_DRIVEBY_TASK_UNDERNEATH_DRIVING_TASK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_CONTROL_MOUNTED_WEAPON( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::CONTROL_MOUNTED_WEAPON(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_SET_MOUNTED_WEAPON_TARGET( int shootingPed, int targetPed, int targetVehicle, float x, float y, float z, int taskMode, bool ignoreTargetVehDeadCheck) { invoke<void )
	{
		TASK::SET_MOUNTED_WEAPON_TARGET(shootingPed, targetPed, targetVehicle, x, y, z, taskMode, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_MOUNTED_WEAPON_TASK_UNDERNEATH_DRIVING_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_MOUNTED_WEAPON_TASK_UNDERNEATH_DRIVING_TASK(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_USE_MOBILE_PHONE( int ped, bool usePhone, int desiredPhoneMode) { invoke<void )
	{
		TASK::TASK_USE_MOBILE_PHONE(ped, usePhone, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_USE_MOBILE_PHONE_TIMED( int ped, int duration) { invoke<void )
	{
		TASK::TASK_USE_MOBILE_PHONE_TIMED(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_CHAT_TO_PED( int ped, int target, int flags, float goToLocationX, float goToLocationY, float goToLocationZ, float headingDegs, float idleTime) { invoke<void )
	{
		TASK::TASK_CHAT_TO_PED(ped, target, flags, goToLocationX, goToLocationY, goToLocationZ, headingDegs, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_WARP_PED_INTO_VEHICLE( int ped, int vehicle, int seat) { invoke<void )
	{
		TASK::TASK_WARP_PED_INTO_VEHICLE(ped, vehicle, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SHOOT_AT_ENTITY( int entity, int target, int duration, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_SHOOT_AT_ENTITY(entity, target, duration, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_CLIMB( int ped, bool usePlayerLaunchForce) { invoke<void )
	{
		TASK::TASK_CLIMB(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_CLIMB_LADDER( int ped, bool fast) { invoke<void )
	{
		TASK::TASK_CLIMB_LADDER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_RAPPEL_DOWN_WALL_USING_CLIPSET_OVERRIDE( int ped, float x1, float y1, float z1, float x2, float y2, float z2, float minZ, int ropeHandle, const char* clipSet, Any p10) { invoke<void )
	{
		TASK::TASK_RAPPEL_DOWN_WALL_USING_CLIPSET_OVERRIDE(ped, x1, y1, z1, x2, y2, z2, minZ, ropeHandle, clipSet, invoke<void);
	}

	int LUA_NATIVE_TASK_GET_TASK_RAPPEL_DOWN_WALL_STATE( int ped) { return invoke<int )
	{
		auto retval = TASK::GET_TASK_RAPPEL_DOWN_WALL_STATE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_TASK_CLEAR_PED_TASKS_IMMEDIATELY( int ped) { invoke<void )
	{
		TASK::CLEAR_PED_TASKS_IMMEDIATELY(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PERFORM_SEQUENCE_FROM_PROGRESS( int ped, int taskIndex, int progress1, int progress2) { invoke<void )
	{
		TASK::TASK_PERFORM_SEQUENCE_FROM_PROGRESS(ped, taskIndex, progress1, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_NEXT_DESIRED_MOVE_STATE( float nextMoveState) { invoke<void )
	{
		TASK::SET_NEXT_DESIRED_MOVE_STATE(invoke<void);
	}

	void LUA_NATIVE_TASK_SET_PED_DESIRED_MOVE_BLEND_RATIO( int ped, float newMoveBlendRatio) { invoke<void )
	{
		TASK::SET_PED_DESIRED_MOVE_BLEND_RATIO(ped, invoke<void);
	}

	float LUA_NATIVE_TASK_GET_PED_DESIRED_MOVE_BLEND_RATIO( int ped) { return invoke<float )
	{
		auto retval = TASK::GET_PED_DESIRED_MOVE_BLEND_RATIO(invoke<float);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_GOTO_ENTITY_AIMING( int ped, int target, float distanceToStopAt, float StartAimingDist) { invoke<void )
	{
		TASK::TASK_GOTO_ENTITY_AIMING(ped, target, distanceToStopAt, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SET_DECISION_MAKER( int ped, unsigned decisionMakerId) { invoke<void )
	{
		TASK::TASK_SET_DECISION_MAKER(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SET_SPHERE_DEFENSIVE_AREA( int ped, float x, float y, float z, float radius) { invoke<void )
	{
		TASK::TASK_SET_SPHERE_DEFENSIVE_AREA(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_CLEAR_DEFENSIVE_AREA( int ped) { invoke<void )
	{
		TASK::TASK_CLEAR_DEFENSIVE_AREA(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PED_SLIDE_TO_COORD( int ped, float x, float y, float z, float heading, float speed) { invoke<void )
	{
		TASK::TASK_PED_SLIDE_TO_COORD(ped, x, y, z, heading, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PED_SLIDE_TO_COORD_HDG_RATE( int ped, float x, float y, float z, float heading, float speed, float headingChangeRate) { invoke<void )
	{
		TASK::TASK_PED_SLIDE_TO_COORD_HDG_RATE(ped, x, y, z, heading, speed, invoke<void);
	}

	int LUA_NATIVE_TASK_ADD_COVER_POINT( float x, float y, float z, float direction, int usage, int height, int arc, bool isPriority) { return invoke<int )
	{
		auto retval = TASK::ADD_COVER_POINT(x, y, z, direction, usage, height, arc, invoke<int);
		return retval;
	}

	void LUA_NATIVE_TASK_REMOVE_COVER_POINT( int coverpoint) { invoke<void )
	{
		TASK::REMOVE_COVER_POINT(invoke<void);
	}

	bool LUA_NATIVE_TASK_DOES_SCRIPTED_COVER_POINT_EXIST_AT_COORDS( float x, float y, float z) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::DOES_SCRIPTED_COVER_POINT_EXIST_AT_COORDS(x, y, invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_TASK_GET_SCRIPTED_COVER_POINT_COORDS( int coverpoint) { return invoke<Vector3 )
	{
		auto retval = TASK::GET_SCRIPTED_COVER_POINT_COORDS(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_TASK_ADD_SCRIPTED_COVER_AREA( float x, float y, float z, float radius) { invoke<void )
	{
		TASK::ADD_SCRIPTED_COVER_AREA(x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COMBAT_PED( int ped, int targetPed, int combatFlags, int threatResponseFlags) { invoke<void )
	{
		TASK::TASK_COMBAT_PED(ped, targetPed, combatFlags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COMBAT_PED_TIMED( int ped, int target, int time, int flags) { invoke<void )
	{
		TASK::TASK_COMBAT_PED_TIMED(ped, target, time, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SEEK_COVER_FROM_POS( int ped, float x, float y, float z, int duration, bool allowPeekingAndFiring) { invoke<void )
	{
		TASK::TASK_SEEK_COVER_FROM_POS(ped, x, y, z, duration, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SEEK_COVER_FROM_PED( int ped, int target, int duration, bool allowPeekingAndFiring) { invoke<void )
	{
		TASK::TASK_SEEK_COVER_FROM_PED(ped, target, duration, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SEEK_COVER_TO_COVER_POINT( int ped, int coverpoint, float x, float y, float z, int time, bool allowPeekingAndFiring) { invoke<void )
	{
		TASK::TASK_SEEK_COVER_TO_COVER_POINT(ped, coverpoint, x, y, z, time, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SEEK_COVER_TO_COORDS( int ped, float x1, float y1, float z1, float x2, float y2, float z2, int timeout, bool shortRoute) { invoke<void )
	{
		TASK::TASK_SEEK_COVER_TO_COORDS(ped, x1, y1, z1, x2, y2, z2, timeout, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PUT_PED_DIRECTLY_INTO_COVER( int ped, float x, float y, float z, int time, bool allowPeekingAndFiring, float blendInDuration, bool forceInitialFacingDirection, bool forceFaceLeft, int identifier, bool doEntry) { invoke<void )
	{
		TASK::TASK_PUT_PED_DIRECTLY_INTO_COVER(ped, x, y, z, time, allowPeekingAndFiring, blendInDuration, forceInitialFacingDirection, forceFaceLeft, identifier, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_WARP_PED_DIRECTLY_INTO_COVER( int ped, int time, bool allowPeekingAndFiring, bool forceInitialFacingDirection, bool forceFaceLeft, int identifier) { invoke<void )
	{
		TASK::TASK_WARP_PED_DIRECTLY_INTO_COVER(ped, time, allowPeekingAndFiring, forceInitialFacingDirection, forceFaceLeft, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_EXIT_COVER( int ped, int exitType, float x, float y, float z) { invoke<void )
	{
		TASK::TASK_EXIT_COVER(ped, exitType, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_PUT_PED_DIRECTLY_INTO_MELEE( int ped, int meleeTarget, float blendInDuration, float timeInMelee, float strafePhaseSync, int aiCombatFlags) { invoke<void )
	{
		TASK::TASK_PUT_PED_DIRECTLY_INTO_MELEE(ped, meleeTarget, blendInDuration, timeInMelee, strafePhaseSync, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_TOGGLE_DUCK( int ped, int toggleType) { invoke<void )
	{
		TASK::TASK_TOGGLE_DUCK(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GUARD_CURRENT_POSITION( int ped, float maxPatrolProximity, float defensiveAreaRadius, bool setDefensiveArea) { invoke<void )
	{
		TASK::TASK_GUARD_CURRENT_POSITION(ped, maxPatrolProximity, defensiveAreaRadius, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GUARD_ASSIGNED_DEFENSIVE_AREA( int ped, float x, float y, float z, float heading, float maxPatrolProximity, int timer) { invoke<void )
	{
		TASK::TASK_GUARD_ASSIGNED_DEFENSIVE_AREA(ped, x, y, z, heading, maxPatrolProximity, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GUARD_SPHERE_DEFENSIVE_AREA( int ped, float defendPositionX, float defendPositionY, float defendPositionZ, float heading, float maxPatrolProximity, int time, float x, float y, float z, float defensiveAreaRadius) { invoke<void )
	{
		TASK::TASK_GUARD_SPHERE_DEFENSIVE_AREA(ped, defendPositionX, defendPositionY, defendPositionZ, heading, maxPatrolProximity, time, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_STAND_GUARD( int ped, float x, float y, float z, float heading, const char* scenarioName) { invoke<void )
	{
		TASK::TASK_STAND_GUARD(ped, x, y, z, heading, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_DRIVE_TASK_CRUISE_SPEED( int driver, float cruiseSpeed) { invoke<void )
	{
		TASK::SET_DRIVE_TASK_CRUISE_SPEED(driver, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_DRIVE_TASK_MAX_CRUISE_SPEED( int ped, float speed) { invoke<void )
	{
		TASK::SET_DRIVE_TASK_MAX_CRUISE_SPEED(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_DRIVE_TASK_DRIVING_STYLE( int ped, int drivingStyle) { invoke<void )
	{
		TASK::SET_DRIVE_TASK_DRIVING_STYLE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_ADD_COVER_BLOCKING_AREA( float startX, float startY, float startZ, float endX, float endY, float endZ, bool blockObjects, bool blockVehicles, bool blockMap, bool blockPlayer) { invoke<void )
	{
		TASK::ADD_COVER_BLOCKING_AREA(startX, startY, startZ, endX, endY, endZ, blockObjects, blockVehicles, blockMap, invoke<void);
	}

	void LUA_NATIVE_TASK_REMOVE_ALL_COVER_BLOCKING_AREAS(  )
	{
		TASK::REMOVE_ALL_COVER_BLOCKING_AREAS();
	}

	void LUA_NATIVE_TASK_REMOVE_COVER_BLOCKING_AREAS_AT_POSITION( float x, float y, float z) { invoke<void )
	{
		TASK::REMOVE_COVER_BLOCKING_AREAS_AT_POSITION(x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_REMOVE_SPECIFIC_COVER_BLOCKING_AREAS( float startX, float startY, float startZ, float endX, float endY, float endZ, bool blockObjects, bool blockVehicles, bool blockMap, bool blockPlayer) { invoke<void )
	{
		TASK::REMOVE_SPECIFIC_COVER_BLOCKING_AREAS(startX, startY, startZ, endX, endY, endZ, blockObjects, blockVehicles, blockMap, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_START_SCENARIO_IN_PLACE( int ped, const char* scenarioName, int unkDelay, bool playEnterAnim) { invoke<void )
	{
		TASK::TASK_START_SCENARIO_IN_PLACE(ped, scenarioName, unkDelay, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_START_SCENARIO_AT_POSITION( int ped, const char* scenarioName, float x, float y, float z, float heading, int duration, bool sittingScenario, bool teleport) { invoke<void )
	{
		TASK::TASK_START_SCENARIO_AT_POSITION(ped, scenarioName, x, y, z, heading, duration, sittingScenario, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_USE_NEAREST_SCENARIO_TO_COORD( int ped, float x, float y, float z, float distance, int duration) { invoke<void )
	{
		TASK::TASK_USE_NEAREST_SCENARIO_TO_COORD(ped, x, y, z, distance, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_USE_NEAREST_SCENARIO_TO_COORD_WARP( int ped, float x, float y, float z, float radius, int timeToLeave) { invoke<void )
	{
		TASK::TASK_USE_NEAREST_SCENARIO_TO_COORD_WARP(ped, x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_USE_NEAREST_SCENARIO_CHAIN_TO_COORD( int ped, float x, float y, float z, float maxRange, int timeToLeave) { invoke<void )
	{
		TASK::TASK_USE_NEAREST_SCENARIO_CHAIN_TO_COORD(ped, x, y, z, maxRange, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_USE_NEAREST_SCENARIO_CHAIN_TO_COORD_WARP( int ped, float x, float y, float z, float radius, int timeToLeave) { invoke<void )
	{
		TASK::TASK_USE_NEAREST_SCENARIO_CHAIN_TO_COORD_WARP(ped, x, y, z, radius, invoke<void);
	}

	bool LUA_NATIVE_TASK_DOES_SCENARIO_EXIST_IN_AREA( float x, float y, float z, float radius, bool mustBeFree) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::DOES_SCENARIO_EXIST_IN_AREA(x, y, z, radius, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_DOES_SCENARIO_OF_TYPE_EXIST_IN_AREA( float x, float y, float z, const char* scenarioName, float radius, bool mustBeFree) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::DOES_SCENARIO_OF_TYPE_EXIST_IN_AREA(x, y, z, scenarioName, radius, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_SCENARIO_OCCUPIED( float x, float y, float z, float maxRange, bool onlyUsersActuallyAtScenario) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_SCENARIO_OCCUPIED(x, y, z, maxRange, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_PED_HAS_USE_SCENARIO_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::PED_HAS_USE_SCENARIO_TASK(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_PLAY_ANIM_ON_RUNNING_SCENARIO( int ped, const char* animDict, const char* animName) { invoke<void )
	{
		TASK::PLAY_ANIM_ON_RUNNING_SCENARIO(ped, animDict, invoke<void);
	}

	bool LUA_NATIVE_TASK_DOES_SCENARIO_GROUP_EXIST( const char* scenarioGroup) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::DOES_SCENARIO_GROUP_EXIST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_SCENARIO_GROUP_ENABLED( const char* scenarioGroup) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_SCENARIO_GROUP_ENABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_SET_SCENARIO_GROUP_ENABLED( const char* scenarioGroup, bool enabled) { invoke<void )
	{
		TASK::SET_SCENARIO_GROUP_ENABLED(scenarioGroup, invoke<void);
	}

	void LUA_NATIVE_TASK_RESET_SCENARIO_GROUPS_ENABLED(  )
	{
		TASK::RESET_SCENARIO_GROUPS_ENABLED();
	}

	void LUA_NATIVE_TASK_SET_EXCLUSIVE_SCENARIO_GROUP( const char* scenarioGroup) { invoke<void )
	{
		TASK::SET_EXCLUSIVE_SCENARIO_GROUP(invoke<void);
	}

	void LUA_NATIVE_TASK_RESET_EXCLUSIVE_SCENARIO_GROUP(  )
	{
		TASK::RESET_EXCLUSIVE_SCENARIO_GROUP();
	}

	bool LUA_NATIVE_TASK_IS_SCENARIO_TYPE_ENABLED( const char* scenarioType) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_SCENARIO_TYPE_ENABLED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_SET_SCENARIO_TYPE_ENABLED( const char* scenarioType, bool toggle) { invoke<void )
	{
		TASK::SET_SCENARIO_TYPE_ENABLED(scenarioType, invoke<void);
	}

	void LUA_NATIVE_TASK_RESET_SCENARIO_TYPES_ENABLED(  )
	{
		TASK::RESET_SCENARIO_TYPES_ENABLED();
	}

	bool LUA_NATIVE_TASK_IS_PED_ACTIVE_IN_SCENARIO( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_ACTIVE_IN_SCENARIO(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_PLAYING_BASE_CLIP_IN_SCENARIO( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_PLAYING_BASE_CLIP_IN_SCENARIO(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_SET_PED_CAN_PLAY_AMBIENT_IDLES( int ped, bool blockIdleClips, bool removeIdleClipIfPlaying) { invoke<void )
	{
		TASK::SET_PED_CAN_PLAY_AMBIENT_IDLES(ped, blockIdleClips, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COMBAT_HATED_TARGETS_IN_AREA( int ped, float x, float y, float z, float radius, int combatFlags) { invoke<void )
	{
		TASK::TASK_COMBAT_HATED_TARGETS_IN_AREA(ped, x, y, z, radius, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COMBAT_HATED_TARGETS_AROUND_PED( int ped, float radius, int combatFlags) { invoke<void )
	{
		TASK::TASK_COMBAT_HATED_TARGETS_AROUND_PED(ped, radius, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_COMBAT_HATED_TARGETS_AROUND_PED_TIMED( int ped, float radius, int time, int combatFlags) { invoke<void )
	{
		TASK::TASK_COMBAT_HATED_TARGETS_AROUND_PED_TIMED(ped, radius, time, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_THROW_PROJECTILE( int ped, float x, float y, float z, int ignoreCollisionEntityIndex, bool createInvincibleProjectile) { invoke<void )
	{
		TASK::TASK_THROW_PROJECTILE(ped, x, y, z, ignoreCollisionEntityIndex, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SWAP_WEAPON( int ped, bool drawWeapon) { invoke<void )
	{
		TASK::TASK_SWAP_WEAPON(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_RELOAD_WEAPON( int ped, bool drawWeapon) { invoke<void )
	{
		TASK::TASK_RELOAD_WEAPON(ped, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_PED_GETTING_UP( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_GETTING_UP(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_WRITHE( int ped, int target, int minFireLoops, int startState, bool forceShootOnGround, int shootFromGroundTimer) { invoke<void )
	{
		TASK::TASK_WRITHE(ped, target, minFireLoops, startState, forceShootOnGround, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_PED_IN_WRITHE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_IN_WRITHE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_OPEN_PATROL_ROUTE( const char* patrolRoute) { invoke<void )
	{
		TASK::OPEN_PATROL_ROUTE(invoke<void);
	}

	void LUA_NATIVE_TASK_CLOSE_PATROL_ROUTE(  )
	{
		TASK::CLOSE_PATROL_ROUTE();
	}

	void LUA_NATIVE_TASK_ADD_PATROL_ROUTE_NODE( int nodeId, const char* nodeType, float posX, float posY, float posZ, float headingX, float headingY, float headingZ, int duration) { invoke<void )
	{
		TASK::ADD_PATROL_ROUTE_NODE(nodeId, nodeType, posX, posY, posZ, headingX, headingY, headingZ, invoke<void);
	}

	void LUA_NATIVE_TASK_ADD_PATROL_ROUTE_LINK( int nodeId1, int nodeId2) { invoke<void )
	{
		TASK::ADD_PATROL_ROUTE_LINK(nodeId1, invoke<void);
	}

	void LUA_NATIVE_TASK_CREATE_PATROL_ROUTE(  )
	{
		TASK::CREATE_PATROL_ROUTE();
	}

	void LUA_NATIVE_TASK_DELETE_PATROL_ROUTE( const char* patrolRoute) { invoke<void )
	{
		TASK::DELETE_PATROL_ROUTE(invoke<void);
	}

	std::tuple<bool, int, int nodeId) { return> LUA_NATIVE_TASK_GET_PATROL_TASK_INFO( int ped, int timeLeftAtNode, int nodeId) { return invoke<BOOL )
	{
		std::tuple<bool, int, int nodeId) { return> return_values;
		std::get<0>(return_values) = (bool)TASK::GET_PATROL_TASK_INFO(ped, &timeLeftAtNode, &invoke<BOOL);
		std::get<1>(return_values) = timeLeftAtNode;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_TASK_TASK_PATROL( int ped, const char* patrolRouteName, int alertState, bool canChatToPeds, bool useHeadLookAt) { invoke<void )
	{
		TASK::TASK_PATROL(ped, patrolRouteName, alertState, canChatToPeds, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_STAY_IN_COVER( int ped) { invoke<void )
	{
		TASK::TASK_STAY_IN_COVER(invoke<void);
	}

	void LUA_NATIVE_TASK_ADD_VEHICLE_SUBTASK_ATTACK_COORD( int ped, float x, float y, float z) { invoke<void )
	{
		TASK::ADD_VEHICLE_SUBTASK_ATTACK_COORD(ped, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_ADD_VEHICLE_SUBTASK_ATTACK_PED( int ped, int target) { invoke<void )
	{
		TASK::ADD_VEHICLE_SUBTASK_ATTACK_PED(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_SHOOT_AT_PED( int ped, int target, float fireTolerance) { invoke<void )
	{
		TASK::TASK_VEHICLE_SHOOT_AT_PED(ped, target, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_AIM_AT_PED( int ped, int target) { invoke<void )
	{
		TASK::TASK_VEHICLE_AIM_AT_PED(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_SHOOT_AT_COORD( int ped, float x, float y, float z, float fireTolerance) { invoke<void )
	{
		TASK::TASK_VEHICLE_SHOOT_AT_COORD(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_AIM_AT_COORD( int ped, float x, float y, float z) { invoke<void )
	{
		TASK::TASK_VEHICLE_AIM_AT_COORD(ped, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_GOTO_NAVMESH( int ped, int vehicle, float x, float y, float z, float speed, int behaviorFlag, float stoppingRange) { invoke<void )
	{
		TASK::TASK_VEHICLE_GOTO_NAVMESH(ped, vehicle, x, y, z, speed, behaviorFlag, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_WHILE_AIMING_AT_COORD( int ped, float x, float y, float z, float aimAtX, float aimAtY, float aimAtZ, float moveBlendRatio, bool shoot, float targetRadius, float slowDistance, bool useNavMesh, int navFlags, bool instantBlendToAim, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_WHILE_AIMING_AT_COORD(ped, x, y, z, aimAtX, aimAtY, aimAtZ, moveBlendRatio, shoot, targetRadius, slowDistance, useNavMesh, navFlags, instantBlendToAim, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_WHILE_AIMING_AT_ENTITY( int ped, float x, float y, float z, int aimAtID, float moveBlendRatio, bool shoot, float targetRadius, float slowDistance, bool useNavMesh, int navFlags, bool instantBlendToAim, unsigned firingPattern, int time) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_WHILE_AIMING_AT_ENTITY(ped, x, y, z, aimAtID, moveBlendRatio, shoot, targetRadius, slowDistance, useNavMesh, navFlags, instantBlendToAim, firingPattern, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_COORD_AND_AIM_AT_HATED_ENTITIES_NEAR_COORD( int pedHandle, float goToLocationX, float goToLocationY, float goToLocationZ, float focusLocationX, float focusLocationY, float focusLocationZ, float speed, bool shootAtEnemies, float distanceToStopAt, float noRoadsDistance, bool useNavMesh, int navFlags, int taskFlags, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_GO_TO_COORD_AND_AIM_AT_HATED_ENTITIES_NEAR_COORD(pedHandle, goToLocationX, goToLocationY, goToLocationZ, focusLocationX, focusLocationY, focusLocationZ, speed, shootAtEnemies, distanceToStopAt, noRoadsDistance, useNavMesh, navFlags, taskFlags, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_ENTITY_WHILE_AIMING_AT_COORD( int ped, int entity, float aimX, float aimY, float aimZ, float moveBlendRatio, bool shoot, float targetRadius, float slowDistance, bool useNavMesh, bool instantBlendToAim, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_GO_TO_ENTITY_WHILE_AIMING_AT_COORD(ped, entity, aimX, aimY, aimZ, moveBlendRatio, shoot, targetRadius, slowDistance, useNavMesh, instantBlendToAim, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_GO_TO_ENTITY_WHILE_AIMING_AT_ENTITY( int ped, int entityToWalkTo, int entityToAimAt, float speed, bool shootatEntity, float targetRadius, float slowDistance, bool useNavMesh, bool instantBlendToAim, unsigned firingPattern) { invoke<void )
	{
		TASK::TASK_GO_TO_ENTITY_WHILE_AIMING_AT_ENTITY(ped, entityToWalkTo, entityToAimAt, speed, shootatEntity, targetRadius, slowDistance, useNavMesh, instantBlendToAim, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_HIGH_FALL_TASK( int ped, int minTime, int maxTime, int entryType) { invoke<void )
	{
		TASK::SET_HIGH_FALL_TASK(ped, minTime, maxTime, invoke<void);
	}

	void LUA_NATIVE_TASK_REQUEST_WAYPOINT_RECORDING( const char* name) { invoke<void )
	{
		TASK::REQUEST_WAYPOINT_RECORDING(invoke<void);
	}

	bool LUA_NATIVE_TASK_GET_IS_WAYPOINT_RECORDING_LOADED( const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::GET_IS_WAYPOINT_RECORDING_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_REMOVE_WAYPOINT_RECORDING( const char* name) { invoke<void )
	{
		TASK::REMOVE_WAYPOINT_RECORDING(invoke<void);
	}

	std::tuple<bool, int points) { return> LUA_NATIVE_TASK_WAYPOINT_RECORDING_GET_NUM_POINTS( const char* name, int points) { return invoke<BOOL )
	{
		std::tuple<bool, int points) { return> return_values;
		std::get<0>(return_values) = (bool)TASK::WAYPOINT_RECORDING_GET_NUM_POINTS(name, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Vector3 coord) { return> LUA_NATIVE_TASK_WAYPOINT_RECORDING_GET_COORD( const char* name, int point, Vector3 coord) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 coord) { return> return_values;
		std::get<0>(return_values) = (bool)TASK::WAYPOINT_RECORDING_GET_COORD(name, point, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	float LUA_NATIVE_TASK_WAYPOINT_RECORDING_GET_SPEED_AT_POINT( const char* name, int point) { return invoke<float )
	{
		auto retval = TASK::WAYPOINT_RECORDING_GET_SPEED_AT_POINT(name, invoke<float);
		return retval;
	}

	std::tuple<bool, int point) { return> LUA_NATIVE_TASK_WAYPOINT_RECORDING_GET_CLOSEST_WAYPOINT( const char* name, float x, float y, float z, int point) { return invoke<BOOL )
	{
		std::tuple<bool, int point) { return> return_values;
		std::get<0>(return_values) = (bool)TASK::WAYPOINT_RECORDING_GET_CLOSEST_WAYPOINT(name, x, y, z, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_TASK_TASK_FOLLOW_WAYPOINT_RECORDING( int ped, const char* name, int p2, int p3, int p4) { invoke<void )
	{
		TASK::TASK_FOLLOW_WAYPOINT_RECORDING(ped, name, p2, p3, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_WAYPOINT_PLAYBACK_GOING_ON_FOR_PED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_WAYPOINT_PLAYBACK_GOING_ON_FOR_PED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_TASK_GET_PED_WAYPOINT_PROGRESS( int ped) { return invoke<int )
	{
		auto retval = TASK::GET_PED_WAYPOINT_PROGRESS(invoke<int);
		return retval;
	}

	float LUA_NATIVE_TASK_GET_PED_WAYPOINT_DISTANCE( Any p0) { return invoke<float )
	{
		auto retval = TASK::GET_PED_WAYPOINT_DISTANCE(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_TASK_SET_PED_WAYPOINT_ROUTE_OFFSET( int ped, float x, float y, float z) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::SET_PED_WAYPOINT_ROUTE_OFFSET(ped, x, y, invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_TASK_GET_WAYPOINT_DISTANCE_ALONG_ROUTE( const char* name, int point) { return invoke<float )
	{
		auto retval = TASK::GET_WAYPOINT_DISTANCE_ALONG_ROUTE(name, invoke<float);
		return retval;
	}

	bool LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_GET_IS_PAUSED( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::WAYPOINT_PLAYBACK_GET_IS_PAUSED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_PAUSE( Any p0, bool p1, bool p2) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_PAUSE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_RESUME( Any p0, bool p1, Any p2, Any p3) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_RESUME(p0, p1, p2, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_OVERRIDE_SPEED( Any p0, float p1, bool p2) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_OVERRIDE_SPEED(p0, p1, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_USE_DEFAULT_SPEED( Any p0) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_USE_DEFAULT_SPEED(invoke<void);
	}

	void LUA_NATIVE_TASK_USE_WAYPOINT_RECORDING_AS_ASSISTED_MOVEMENT_ROUTE( const char* name, bool p1, float p2, float p3) { invoke<void )
	{
		TASK::USE_WAYPOINT_RECORDING_AS_ASSISTED_MOVEMENT_ROUTE(name, p1, p2, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_START_AIMING_AT_PED( int ped, int target, bool p2) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_START_AIMING_AT_PED(ped, target, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_START_AIMING_AT_COORD( int ped, float x, float y, float z, bool p4) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_START_AIMING_AT_COORD(ped, x, y, z, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_START_SHOOTING_AT_PED( int ped, int ped2, bool p2, bool p3) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_START_SHOOTING_AT_PED(ped, ped2, p2, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_START_SHOOTING_AT_COORD( int ped, float x, float y, float z, bool p4, unsigned firingPattern) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_START_SHOOTING_AT_COORD(ped, x, y, z, p4, invoke<void);
	}

	void LUA_NATIVE_TASK_WAYPOINT_PLAYBACK_STOP_AIMING_OR_SHOOTING( int ped) { invoke<void )
	{
		TASK::WAYPOINT_PLAYBACK_STOP_AIMING_OR_SHOOTING(invoke<void);
	}

	void LUA_NATIVE_TASK_ASSISTED_MOVEMENT_REQUEST_ROUTE( const char* route) { invoke<void )
	{
		TASK::ASSISTED_MOVEMENT_REQUEST_ROUTE(invoke<void);
	}

	void LUA_NATIVE_TASK_ASSISTED_MOVEMENT_REMOVE_ROUTE( const char* route) { invoke<void )
	{
		TASK::ASSISTED_MOVEMENT_REMOVE_ROUTE(invoke<void);
	}

	bool LUA_NATIVE_TASK_ASSISTED_MOVEMENT_IS_ROUTE_LOADED( const char* route) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::ASSISTED_MOVEMENT_IS_ROUTE_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_ASSISTED_MOVEMENT_SET_ROUTE_PROPERTIES( const char* route, int props) { invoke<void )
	{
		TASK::ASSISTED_MOVEMENT_SET_ROUTE_PROPERTIES(route, invoke<void);
	}

	void LUA_NATIVE_TASK_ASSISTED_MOVEMENT_OVERRIDE_LOAD_DISTANCE_THIS_FRAME( float dist) { invoke<void )
	{
		TASK::ASSISTED_MOVEMENT_OVERRIDE_LOAD_DISTANCE_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_VEHICLE_FOLLOW_WAYPOINT_RECORDING( int ped, int vehicle, const char* WPRecording, int p3, int p4, int p5, int p6, float p7, bool p8, float p9) { invoke<void )
	{
		TASK::TASK_VEHICLE_FOLLOW_WAYPOINT_RECORDING(ped, vehicle, WPRecording, p3, p4, p5, p6, p7, p8, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_WAYPOINT_PLAYBACK_GOING_ON_FOR_VEHICLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_WAYPOINT_PLAYBACK_GOING_ON_FOR_VEHICLE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_TASK_GET_VEHICLE_WAYPOINT_PROGRESS( int vehicle) { return invoke<int )
	{
		auto retval = TASK::GET_VEHICLE_WAYPOINT_PROGRESS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_TASK_GET_VEHICLE_WAYPOINT_TARGET_POINT( int vehicle) { return invoke<int )
	{
		auto retval = TASK::GET_VEHICLE_WAYPOINT_TARGET_POINT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_TASK_VEHICLE_WAYPOINT_PLAYBACK_PAUSE( int vehicle) { invoke<void )
	{
		TASK::VEHICLE_WAYPOINT_PLAYBACK_PAUSE(invoke<void);
	}

	void LUA_NATIVE_TASK_VEHICLE_WAYPOINT_PLAYBACK_RESUME( int vehicle) { invoke<void )
	{
		TASK::VEHICLE_WAYPOINT_PLAYBACK_RESUME(invoke<void);
	}

	void LUA_NATIVE_TASK_VEHICLE_WAYPOINT_PLAYBACK_USE_DEFAULT_SPEED( int vehicle) { invoke<void )
	{
		TASK::VEHICLE_WAYPOINT_PLAYBACK_USE_DEFAULT_SPEED(invoke<void);
	}

	void LUA_NATIVE_TASK_VEHICLE_WAYPOINT_PLAYBACK_OVERRIDE_SPEED( int vehicle, float speed) { invoke<void )
	{
		TASK::VEHICLE_WAYPOINT_PLAYBACK_OVERRIDE_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS( int ped, bool toggle) { invoke<void )
	{
		TASK::TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_FORCE_MOTION_STATE( int ped, unsigned state, bool forceRestart) { invoke<void )
	{
		TASK::TASK_FORCE_MOTION_STATE(ped, state, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_MOVE_NETWORK_BY_NAME( int ped, const char* task, float multiplier, bool allowOverrideCloneUpdate, const char* animDict, int flags) { invoke<void )
	{
		TASK::TASK_MOVE_NETWORK_BY_NAME(ped, task, multiplier, allowOverrideCloneUpdate, animDict, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_MOVE_NETWORK_ADVANCED_BY_NAME( int ped, const char* network, float x, float y, float z, float rotX, float rotY, float rotZ, int rotOrder, float blendDuration, bool allowOverrideCloneUpdate, const char* animDict, int flags) { invoke<void )
	{
		TASK::TASK_MOVE_NETWORK_ADVANCED_BY_NAME(ped, network, x, y, z, rotX, rotY, rotZ, rotOrder, blendDuration, allowOverrideCloneUpdate, animDict, invoke<void);
	}

	int LUA_NATIVE_TASK_TASK_MOVE_NETWORK_BY_NAME_WITH_INIT_PARAMS( int ped, const char* network, int initialParameters, float blendDuration, bool allowOverrideCloneUpdate, const char* animDict, int flags) { invoke<void )
	{
		TASK::TASK_MOVE_NETWORK_BY_NAME_WITH_INIT_PARAMS(ped, network, &initialParameters, blendDuration, allowOverrideCloneUpdate, animDict, invoke<void);
		return initialParameters;
	}

	int LUA_NATIVE_TASK_TASK_MOVE_NETWORK_ADVANCED_BY_NAME_WITH_INIT_PARAMS( int ped, const char* network, int initialParameters, float x, float y, float z, float rotX, float rotY, float rotZ, int rotOrder, float blendDuration, bool allowOverrideCloneUpdate, const char* dictionary, int flags) { invoke<void )
	{
		TASK::TASK_MOVE_NETWORK_ADVANCED_BY_NAME_WITH_INIT_PARAMS(ped, network, &initialParameters, x, y, z, rotX, rotY, rotZ, rotOrder, blendDuration, allowOverrideCloneUpdate, dictionary, invoke<void);
		return initialParameters;
	}

	bool LUA_NATIVE_TASK_IS_TASK_MOVE_NETWORK_ACTIVE( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_TASK_MOVE_NETWORK_ACTIVE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_TASK_MOVE_NETWORK_READY_FOR_TRANSITION( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_TASK_MOVE_NETWORK_READY_FOR_TRANSITION(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_REQUEST_TASK_MOVE_NETWORK_STATE_TRANSITION( int ped, const char* name) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::REQUEST_TASK_MOVE_NETWORK_STATE_TRANSITION(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_SET_EXPECTED_CLONE_NEXT_TASK_MOVE_NETWORK_STATE( int ped, const char* state) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::SET_EXPECTED_CLONE_NEXT_TASK_MOVE_NETWORK_STATE(ped, invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_TASK_GET_TASK_MOVE_NETWORK_STATE( int ped) { return invoke<const char* )
	{
		auto retval = TASK::GET_TASK_MOVE_NETWORK_STATE(char*);
		return retval;
	}

	void LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_ANIM_SET( int ped, unsigned clipSet, unsigned variableClipSet) { invoke<void )
	{
		TASK::SET_TASK_MOVE_NETWORK_ANIM_SET(ped, clipSet, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_SIGNAL_FLOAT( int ped, const char* signalName, float value) { invoke<void )
	{
		TASK::SET_TASK_MOVE_NETWORK_SIGNAL_FLOAT(ped, signalName, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_SIGNAL_LOCAL_FLOAT( int ped, const char* signalName, float value) { invoke<void )
	{
		TASK::SET_TASK_MOVE_NETWORK_SIGNAL_LOCAL_FLOAT(ped, signalName, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_SIGNAL_FLOAT_LERP_RATE( int ped, const char* signalName, float value) { invoke<void )
	{
		TASK::SET_TASK_MOVE_NETWORK_SIGNAL_FLOAT_LERP_RATE(ped, signalName, invoke<void);
	}

	void LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_SIGNAL_BOOL( int ped, const char* signalName, bool value) { invoke<void )
	{
		TASK::SET_TASK_MOVE_NETWORK_SIGNAL_BOOL(ped, signalName, invoke<void);
	}

	float LUA_NATIVE_TASK_GET_TASK_MOVE_NETWORK_SIGNAL_FLOAT( int ped, const char* signalName) { return invoke<float )
	{
		auto retval = TASK::GET_TASK_MOVE_NETWORK_SIGNAL_FLOAT(ped, invoke<float);
		return retval;
	}

	bool LUA_NATIVE_TASK_GET_TASK_MOVE_NETWORK_SIGNAL_BOOL( int ped, const char* signalName) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::GET_TASK_MOVE_NETWORK_SIGNAL_BOOL(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_GET_TASK_MOVE_NETWORK_EVENT( int ped, const char* eventName) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::GET_TASK_MOVE_NETWORK_EVENT(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_SET_TASK_MOVE_NETWORK_ENABLE_COLLISION_ON_NETWORK_CLONE_WHEN_FIXED( int ped, bool enable) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::SET_TASK_MOVE_NETWORK_ENABLE_COLLISION_ON_NETWORK_CLONE_WHEN_FIXED(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_MOVE_BLEND_RATIO_STILL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_MOVE_BLEND_RATIO_STILL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_MOVE_BLEND_RATIO_WALKING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_MOVE_BLEND_RATIO_WALKING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_MOVE_BLEND_RATIO_RUNNING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_MOVE_BLEND_RATIO_RUNNING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_MOVE_BLEND_RATIO_SPRINTING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_MOVE_BLEND_RATIO_SPRINTING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_STILL( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_STILL(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_WALKING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_WALKING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_RUNNING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_RUNNING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_SPRINTING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_SPRINTING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_STRAFING( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_STRAFING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_TASK_SYNCHRONIZED_SCENE( int ped, int scene, const char* animDictionary, const char* animationName, float blendIn, float blendOut, int flags, int ragdollBlockingFlags, float moverBlendDelta, int ikFlags) { invoke<void )
	{
		TASK::TASK_SYNCHRONIZED_SCENE(ped, scene, animDictionary, animationName, blendIn, blendOut, flags, ragdollBlockingFlags, moverBlendDelta, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_AGITATED_ACTION_CONFRONT_RESPONSE( int ped, int ped2) { invoke<void )
	{
		TASK::TASK_AGITATED_ACTION_CONFRONT_RESPONSE(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SWEEP_AIM_ENTITY( int ped, const char* animDict, const char* lowAnimName, const char* medAnimName, const char* hiAnimName, int runtime, int targetEntity, float turnRate, float blendInDuration) { invoke<void )
	{
		TASK::TASK_SWEEP_AIM_ENTITY(ped, animDict, lowAnimName, medAnimName, hiAnimName, runtime, targetEntity, turnRate, invoke<void);
	}

	void LUA_NATIVE_TASK_UPDATE_TASK_SWEEP_AIM_ENTITY( int ped, int entity) { invoke<void )
	{
		TASK::UPDATE_TASK_SWEEP_AIM_ENTITY(ped, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_SWEEP_AIM_POSITION( int ped, const char* animDict, const char* lowAnimName, const char* medAnimName, const char* hiAnimName, int runtime, float x, float y, float z, float turnRate, float blendInDuration) { invoke<void )
	{
		TASK::TASK_SWEEP_AIM_POSITION(ped, animDict, lowAnimName, medAnimName, hiAnimName, runtime, x, y, z, turnRate, invoke<void);
	}

	void LUA_NATIVE_TASK_UPDATE_TASK_SWEEP_AIM_POSITION( int ped, float x, float y, float z) { invoke<void )
	{
		TASK::UPDATE_TASK_SWEEP_AIM_POSITION(ped, x, y, invoke<void);
	}

	void LUA_NATIVE_TASK_TASK_ARREST_PED( int ped, int target) { invoke<void )
	{
		TASK::TASK_ARREST_PED(ped, invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_PED_RUNNING_ARREST_TASK( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_RUNNING_ARREST_TASK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_TASK_IS_PED_BEING_ARRESTED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_BEING_ARRESTED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_TASK_UNCUFF_PED( int ped) { invoke<void )
	{
		TASK::UNCUFF_PED(invoke<void);
	}

	bool LUA_NATIVE_TASK_IS_PED_CUFFED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)TASK::IS_PED_CUFFED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_CREATE_VEHICLE( unsigned modelHash, float x, float y, float z, float heading, bool isNetwork, bool bScriptHostVeh, bool p7) { return invoke<int )
	{
		auto retval = VEHICLE::CREATE_VEHICLE(modelHash, x, y, z, heading, isNetwork, bScriptHostVeh, invoke<int);
		return retval;
	}

	int vehicle) { LUA_NATIVE_VEHICLE_DELETE_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::DELETE_VEHICLE(&invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ALLOW_HOMING_MISSLE_LOCKON( int vehicle, bool toggle, bool p2) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ALLOW_HOMING_MISSLE_LOCKON(vehicle, toggle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ALLOW_HOMING_MISSLE_LOCKON_SYNCED( int vehicle, bool canBeLockedOn, bool p2) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ALLOW_HOMING_MISSLE_LOCKON_SYNCED(vehicle, canBeLockedOn, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ALLOW_NO_PASSENGERS_LOCKON( int veh, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ALLOW_NO_PASSENGERS_LOCKON(veh, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_HOMING_LOCKON_STATE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_HOMING_LOCKON_STATE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_HOMING_LOCKEDONTO_STATE( Any p0) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_HOMING_LOCKEDONTO_STATE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HOMING_LOCKEDONTO_STATE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HOMING_LOCKEDONTO_STATE(p0, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_MODEL( int vehicle, unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_MODEL(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_DOES_SCRIPT_VEHICLE_GENERATOR_EXIST( int vehicleGenerator) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_SCRIPT_VEHICLE_GENERATOR_EXIST(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_CREATE_SCRIPT_VEHICLE_GENERATOR( float x, float y, float z, float heading, float p4, float p5, unsigned modelHash, int p7, int p8, int p9, int p10, bool p11, bool p12, bool p13, bool p14, bool p15, int p16) { return invoke<int )
	{
		auto retval = VEHICLE::CREATE_SCRIPT_VEHICLE_GENERATOR(x, y, z, heading, p4, p5, modelHash, p7, p8, p9, p10, p11, p12, p13, p14, p15, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_DELETE_SCRIPT_VEHICLE_GENERATOR( int vehicleGenerator) { invoke<void )
	{
		VEHICLE::DELETE_SCRIPT_VEHICLE_GENERATOR(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SCRIPT_VEHICLE_GENERATOR( int vehicleGenerator, bool enabled) { invoke<void )
	{
		VEHICLE::SET_SCRIPT_VEHICLE_GENERATOR(vehicleGenerator, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ALL_VEHICLE_GENERATORS_ACTIVE_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, bool toggle, bool p7) { invoke<void )
	{
		VEHICLE::SET_ALL_VEHICLE_GENERATORS_ACTIVE_IN_AREA(x1, y1, z1, x2, y2, z2, toggle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ALL_VEHICLE_GENERATORS_ACTIVE(  )
	{
		VEHICLE::SET_ALL_VEHICLE_GENERATORS_ACTIVE();
	}

	void LUA_NATIVE_VEHICLE_SET_ALL_LOW_PRIORITY_VEHICLE_GENERATORS_ACTIVE( bool active) { invoke<void )
	{
		VEHICLE::SET_ALL_LOW_PRIORITY_VEHICLE_GENERATORS_ACTIVE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_GENERATOR_AREA_OF_INTEREST( float x, float y, float z, float radius) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_GENERATOR_AREA_OF_INTEREST(x, y, z, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_GENERATOR_AREA_OF_INTEREST(  )
	{
		VEHICLE::CLEAR_VEHICLE_GENERATOR_AREA_OF_INTEREST();
	}

	bool LUA_NATIVE_VEHICLE_SET_VEHICLE_ON_GROUND_PROPERLY( int vehicle, float p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_VEHICLE_ON_GROUND_PROPERLY(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_SET_VEHICLE_USE_CUTSCENE_WHEEL_COMPRESSION( int p0, bool p1, bool p2, bool p3) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_VEHICLE_USE_CUTSCENE_WHEEL_COMPRESSION(p0, p1, p2, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_STUCK_ON_ROOF( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_STUCK_ON_ROOF(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_ADD_VEHICLE_UPSIDEDOWN_CHECK( int vehicle) { invoke<void )
	{
		VEHICLE::ADD_VEHICLE_UPSIDEDOWN_CHECK(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_UPSIDEDOWN_CHECK( int vehicle) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_UPSIDEDOWN_CHECK(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_STOPPED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_STOPPED(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_NUMBER_OF_PASSENGERS( int vehicle, bool includeDriver, bool includeDeadOccupants) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_NUMBER_OF_PASSENGERS(vehicle, includeDriver, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_NUMBER_OF_SEATS( unsigned modelHash) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_NUMBER_OF_SEATS(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_SEAT_WARP_ONLY( int vehicle, int seatIndex) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_SEAT_WARP_ONLY(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_TURRET_SEAT( int vehicle, int seatIndex) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_TURRET_SEAT(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_DOES_VEHICLE_ALLOW_RAPPEL( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_VEHICLE_ALLOW_RAPPEL(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME( float multiplier) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_RANDOM_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME( float multiplier) { invoke<void )
	{
		VEHICLE::SET_RANDOM_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PARKED_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME( float multiplier) { invoke<void )
	{
		VEHICLE::SET_PARKED_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_RANDOM_TRAINS_THIS_FRAME( bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_RANDOM_TRAINS_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_AMBIENT_VEHICLE_RANGE_MULTIPLIER_THIS_FRAME( float value) { invoke<void )
	{
		VEHICLE::SET_AMBIENT_VEHICLE_RANGE_MULTIPLIER_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FAR_DRAW_VEHICLES( bool toggle) { invoke<void )
	{
		VEHICLE::SET_FAR_DRAW_VEHICLES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_NUMBER_OF_PARKED_VEHICLES( int value) { invoke<void )
	{
		VEHICLE::SET_NUMBER_OF_PARKED_VEHICLES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED( int vehicle, int doorLockStatus) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_INDIVIDUAL_DOORS_LOCKED( int vehicle, int doorId, int doorLockStatus) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_INDIVIDUAL_DOORS_LOCKED(vehicle, doorId, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HAS_MUTED_SIRENS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HAS_MUTED_SIRENS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED_FOR_PLAYER( int vehicle, int player, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_PLAYER(vehicle, player, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_DOORS_LOCKED_FOR_PLAYER( int vehicle, int player) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_DOORS_LOCKED_FOR_PLAYER(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED_FOR_ALL_PLAYERS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_ALL_PLAYERS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED_FOR_NON_SCRIPT_PLAYERS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_NON_SCRIPT_PLAYERS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED_FOR_TEAM( int vehicle, int team, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_TEAM(vehicle, team, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_LOCKED_FOR_ALL_TEAMS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_ALL_TEAMS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DONT_TERMINATE_TASK_WHEN_ACHIEVED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DONT_TERMINATE_TASK_WHEN_ACHIEVED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_EXPLODE_VEHICLE( int vehicle, bool isAudible, bool isInvisible) { invoke<void )
	{
		VEHICLE::EXPLODE_VEHICLE(vehicle, isAudible, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_OUT_OF_CONTROL( int vehicle, bool killDriver, bool explodeOnImpact) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_OUT_OF_CONTROL(vehicle, killDriver, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TIMED_EXPLOSION( int vehicle, int ped, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TIMED_EXPLOSION(vehicle, ped, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ADD_VEHICLE_PHONE_EXPLOSIVE_DEVICE( int vehicle) { invoke<void )
	{
		VEHICLE::ADD_VEHICLE_PHONE_EXPLOSIVE_DEVICE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_PHONE_EXPLOSIVE_DEVICE(  )
	{
		VEHICLE::CLEAR_VEHICLE_PHONE_EXPLOSIVE_DEVICE();
	}

	bool LUA_NATIVE_VEHICLE_HAS_VEHICLE_PHONE_EXPLOSIVE_DEVICE(  )
	{
		auto retval = (bool)VEHICLE::HAS_VEHICLE_PHONE_EXPLOSIVE_DEVICE();
		return retval;
	}

	void LUA_NATIVE_VEHICLE_DETONATE_VEHICLE_PHONE_EXPLOSIVE_DEVICE(  )
	{
		VEHICLE::DETONATE_VEHICLE_PHONE_EXPLOSIVE_DEVICE();
	}

	bool LUA_NATIVE_VEHICLE_HAVE_VEHICLE_REAR_DOORS_BEEN_BLOWN_OPEN_BY_STICKYBOMB( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAVE_VEHICLE_REAR_DOORS_BEEN_BLOWN_OPEN_BY_STICKYBOMB(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_TAXI_LIGHTS( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_TAXI_LIGHTS(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_TAXI_LIGHT_ON( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_TAXI_LIGHT_ON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_IN_GARAGE_AREA( const char* garageName, int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_IN_GARAGE_AREA(garageName, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_COLOURS( int vehicle, int colorPrimary, int colorSecondary) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_COLOURS(vehicle, colorPrimary, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FULLBEAM( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FULLBEAM(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IS_RACING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IS_RACING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CUSTOM_PRIMARY_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CUSTOM_PRIMARY_COLOUR(vehicle, r, g, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_CUSTOM_PRIMARY_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		VEHICLE::GET_VEHICLE_CUSTOM_PRIMARY_COLOUR(vehicle, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_CUSTOM_PRIMARY_COLOUR( int vehicle) { invoke<void )
	{
		VEHICLE::CLEAR_VEHICLE_CUSTOM_PRIMARY_COLOUR(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_VEHICLE_PRIMARY_COLOUR_CUSTOM( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_VEHICLE_PRIMARY_COLOUR_CUSTOM(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CUSTOM_SECONDARY_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CUSTOM_SECONDARY_COLOUR(vehicle, r, g, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_CUSTOM_SECONDARY_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		VEHICLE::GET_VEHICLE_CUSTOM_SECONDARY_COLOUR(vehicle, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_CUSTOM_SECONDARY_COLOUR( int vehicle) { invoke<void )
	{
		VEHICLE::CLEAR_VEHICLE_CUSTOM_SECONDARY_COLOUR(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_VEHICLE_SECONDARY_COLOUR_CUSTOM( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_VEHICLE_SECONDARY_COLOUR_CUSTOM(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ENVEFF_SCALE( int vehicle, float fade) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ENVEFF_SCALE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_ENVEFF_SCALE( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_ENVEFF_SCALE(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_CAN_RESPRAY_VEHICLE( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_CAN_RESPRAY_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_GOON_BOSS_VEHICLE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_GOON_BOSS_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_OPEN_REAR_DOORS_ON_EXPLOSION( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_OPEN_REAR_DOORS_ON_EXPLOSION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_FORCE_SUBMARINE_SURFACE_MODE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::FORCE_SUBMARINE_SURFACE_MODE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_FORCE_SUBMARINE_NEURTAL_BUOYANCY( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::FORCE_SUBMARINE_NEURTAL_BUOYANCY(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SUBMARINE_CRUSH_DEPTHS( int vehicle, bool p1, float depth1, float depth2, float depth3) { invoke<void )
	{
		VEHICLE::SET_SUBMARINE_CRUSH_DEPTHS(vehicle, p1, depth1, depth2, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_SUBMARINE_IS_UNDER_DESIGN_DEPTH( int submarine) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_SUBMARINE_IS_UNDER_DESIGN_DEPTH(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_SUBMARINE_NUMBER_OF_AIR_LEAKS( int submarine) { return invoke<int )
	{
		auto retval = VEHICLE::GET_SUBMARINE_NUMBER_OF_AIR_LEAKS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_IGNORE_LAND_PROBES( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_BOAT_IGNORE_LAND_PROBES(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BOUNDS_AFFECT_WATER_PROBES_( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_BOUNDS_AFFECT_WATER_PROBES_(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_ANCHOR( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_BOAT_ANCHOR(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_CAN_ANCHOR_BOAT_HERE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::CAN_ANCHOR_BOAT_HERE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_CAN_ANCHOR_BOAT_HERE_IGNORE_PLAYERS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::CAN_ANCHOR_BOAT_HERE_IGNORE_PLAYERS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_REMAINS_ANCHORED_WHILE_PLAYER_IS_DRIVER( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_BOAT_REMAINS_ANCHORED_WHILE_PLAYER_IS_DRIVER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FORCE_LOW_LOD_ANCHOR_MODE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_FORCE_LOW_LOD_ANCHOR_MODE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_LOW_LOD_ANCHOR_DISTANCE( int vehicle, float value) { invoke<void )
	{
		VEHICLE::SET_BOAT_LOW_LOD_ANCHOR_DISTANCE(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_BOAT_ANCHORED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_BOAT_ANCHORED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_SINKS_WHEN_WRECKED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_BOAT_SINKS_WHEN_WRECKED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_WRECKED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_BOAT_WRECKED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_SIREN( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_SIREN(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_SIREN_ON( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_SIREN_ON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_SIREN_AUDIO_ON( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_SIREN_AUDIO_ON(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STRONG( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STRONG(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_STUCK_CHECK( int vehicle) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_STUCK_CHECK(invoke<void);
	}

	std::tuple<int, int colorSecondary) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_COLOURS( int vehicle, int colorPrimary, int colorSecondary) { invoke<void )
	{
		std::tuple<int, int colorSecondary) {> return_values;
		VEHICLE::GET_VEHICLE_COLOURS(vehicle, &colorPrimary, &invoke<void);
		std::get<0>(return_values) = colorPrimary;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_SEAT_FREE( int vehicle, int seatIndex, bool isTaskRunning) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_SEAT_FREE(vehicle, seatIndex, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_PED_IN_VEHICLE_SEAT( int vehicle, int seatIndex, bool p2) { return invoke<int )
	{
		auto retval = VEHICLE::GET_PED_IN_VEHICLE_SEAT(vehicle, seatIndex, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_LAST_PED_IN_VEHICLE_SEAT( int vehicle, int seatIndex) { return invoke<int )
	{
		auto retval = VEHICLE::GET_LAST_PED_IN_VEHICLE_SEAT(vehicle, invoke<int);
		return retval;
	}

	std::tuple<bool, bool, bool highbeamsOn) { return> LUA_NATIVE_VEHICLE_GET_VEHICLE_LIGHTS_STATE( int vehicle, bool lightsOn, bool highbeamsOn) { return invoke<BOOL )
	{
		std::tuple<bool, bool, bool highbeamsOn) { return> return_values;
		std::get<0>(return_values) = (bool)VEHICLE::GET_VEHICLE_LIGHTS_STATE(vehicle, (BOOL*)&lightsOn, &invoke<BOOL);
		std::get<1>(return_values) = lightsOn;
		std::get<2>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_TYRE_BURST( int vehicle, int wheelID, bool completely) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_TYRE_BURST(vehicle, wheelID, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FORWARD_SPEED( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FORWARD_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FORWARD_SPEED_XY( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FORWARD_SPEED_XY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_BRING_VEHICLE_TO_HALT( int vehicle, float distance, int duration, bool p3) { invoke<void )
	{
		VEHICLE::BRING_VEHICLE_TO_HALT(vehicle, distance, duration, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STEER_FOR_BUILDINGS( int vehicle, Any p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STEER_FOR_BUILDINGS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAUSES_SWERVING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAUSES_SWERVING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_IGNORE_PLANES_SMALL_PITCH_CHANGE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_IGNORE_PLANES_SMALL_PITCH_CHANGE(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_STOP_BRINGING_VEHICLE_TO_HALT( int vehicle) { invoke<void )
	{
		VEHICLE::STOP_BRINGING_VEHICLE_TO_HALT(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_BEING_BROUGHT_TO_HALT( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_BEING_BROUGHT_TO_HALT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_LOWER_FORKLIFT_FORKS( int forklift) { invoke<void )
	{
		VEHICLE::LOWER_FORKLIFT_FORKS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FORKLIFT_FORK_HEIGHT( int vehicle, float height) { invoke<void )
	{
		VEHICLE::SET_FORKLIFT_FORK_HEIGHT(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_ENTITY_ATTACHED_TO_HANDLER_FRAME( int vehicle, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ENTITY_ATTACHED_TO_HANDLER_FRAME(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_ANY_ENTITY_ATTACHED_TO_HANDLER_FRAME( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ANY_ENTITY_ATTACHED_TO_HANDLER_FRAME(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_FIND_HANDLER_VEHICLE_CONTAINER_IS_ATTACHED_TO( int entity) { return invoke<int )
	{
		auto retval = VEHICLE::FIND_HANDLER_VEHICLE_CONTAINER_IS_ATTACHED_TO(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_HANDLER_FRAME_LINED_UP_WITH_CONTAINER( int vehicle, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_HANDLER_FRAME_LINED_UP_WITH_CONTAINER(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_ATTACH_CONTAINER_TO_HANDLER_FRAME_WHEN_LINED_UP( int vehicle, int entity) { invoke<void )
	{
		VEHICLE::ATTACH_CONTAINER_TO_HANDLER_FRAME_WHEN_LINED_UP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DETACH_CONTAINER_FROM_HANDLER_FRAME( int vehicle) { invoke<void )
	{
		VEHICLE::DETACH_CONTAINER_FROM_HANDLER_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DISABLE_HEIGHT_MAP_AVOIDANCE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DISABLE_HEIGHT_MAP_AVOIDANCE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BOAT_DISABLE_AVOIDANCE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_BOAT_DISABLE_AVOIDANCE(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_HELI_LANDING_AREA_BLOCKED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_HELI_LANDING_AREA_BLOCKED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_SHORT_SLOWDOWN_FOR_LANDING( int vehicle) { invoke<void )
	{
		VEHICLE::SET_SHORT_SLOWDOWN_FOR_LANDING(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_TURBULENCE_SCALAR( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_HELI_TURBULENCE_SCALAR(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CAR_BOOT_OPEN( int vehicle) { invoke<void )
	{
		VEHICLE::SET_CAR_BOOT_OPEN(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TYRE_BURST( int vehicle, int index, bool onRim, float p3) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TYRE_BURST(vehicle, index, onRim, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOORS_SHUT( int vehicle, bool closeInstantly) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOORS_SHUT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TYRES_CAN_BURST( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TYRES_CAN_BURST(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_TYRES_CAN_BURST( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_TYRES_CAN_BURST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WHEELS_CAN_BREAK( int vehicle, bool enabled) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WHEELS_CAN_BREAK(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_OPEN( int vehicle, int doorId, bool loose, bool openInstantly) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_OPEN(vehicle, doorId, loose, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_AUTO_LOCK( int vehicle, int doorId, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_AUTO_LOCK(vehicle, doorId, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FLEEING_VEHICLES_USE_SWITCHED_OFF_NODES( Any p0) { invoke<void )
	{
		VEHICLE::SET_FLEEING_VEHICLES_USE_SWITCHED_OFF_NODES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_WINDOW( int vehicle, int windowIndex) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_WINDOW(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ROLL_DOWN_WINDOWS( int vehicle) { invoke<void )
	{
		VEHICLE::ROLL_DOWN_WINDOWS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ROLL_DOWN_WINDOW( int vehicle, int windowIndex) { invoke<void )
	{
		VEHICLE::ROLL_DOWN_WINDOW(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ROLL_UP_WINDOW( int vehicle, int windowIndex) { invoke<void )
	{
		VEHICLE::ROLL_UP_WINDOW(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SMASH_VEHICLE_WINDOW( int vehicle, int windowIndex) { invoke<void )
	{
		VEHICLE::SMASH_VEHICLE_WINDOW(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_FIX_VEHICLE_WINDOW( int vehicle, int windowIndex) { invoke<void )
	{
		VEHICLE::FIX_VEHICLE_WINDOW(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_POP_OUT_VEHICLE_WINDSCREEN( int vehicle) { invoke<void )
	{
		VEHICLE::POP_OUT_VEHICLE_WINDSCREEN(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_POP_OFF_VEHICLE_ROOF_WITH_IMPULSE( int vehicle, float x, float y, float z) { invoke<void )
	{
		VEHICLE::POP_OFF_VEHICLE_ROOF_WITH_IMPULSE(vehicle, x, y, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LIGHTS( int vehicle, int state) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LIGHTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USE_PLAYER_LIGHT_SETTINGS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USE_PLAYER_LIGHT_SETTINGS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HEADLIGHT_SHADOWS( int vehicle, int p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HEADLIGHT_SHADOWS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ALARM( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ALARM(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_START_VEHICLE_ALARM( int vehicle) { invoke<void )
	{
		VEHICLE::START_VEHICLE_ALARM(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_ALARM_ACTIVATED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_ALARM_ACTIVATED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_INTERIORLIGHT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_INTERIORLIGHT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FORCE_INTERIORLIGHT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FORCE_INTERIORLIGHT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LIGHT_MULTIPLIER( int vehicle, float multiplier) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LIGHT_MULTIPLIER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ATTACH_VEHICLE_TO_TRAILER( int vehicle, int trailer, float radius) { invoke<void )
	{
		VEHICLE::ATTACH_VEHICLE_TO_TRAILER(vehicle, trailer, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ATTACH_VEHICLE_ON_TO_TRAILER( int vehicle, int trailer, float offsetX, float offsetY, float offsetZ, float coordsX, float coordsY, float coordsZ, float rotationX, float rotationY, float rotationZ, float disableCollisions) { invoke<void )
	{
		VEHICLE::ATTACH_VEHICLE_ON_TO_TRAILER(vehicle, trailer, offsetX, offsetY, offsetZ, coordsX, coordsY, coordsZ, rotationX, rotationY, rotationZ, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_STABILISE_ENTITY_ATTACHED_TO_HELI( int vehicle, int entity, float p2) { invoke<void )
	{
		VEHICLE::STABILISE_ENTITY_ATTACHED_TO_HELI(vehicle, entity, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DETACH_VEHICLE_FROM_TRAILER( int vehicle) { invoke<void )
	{
		VEHICLE::DETACH_VEHICLE_FROM_TRAILER(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_ATTACHED_TO_TRAILER( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_ATTACHED_TO_TRAILER(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_TRAILER_INVERSE_MASS_SCALE( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_TRAILER_INVERSE_MASS_SCALE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRAILER_LEGS_RAISED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_TRAILER_LEGS_RAISED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRAILER_LEGS_LOWERED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_TRAILER_LEGS_LOWERED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TYRE_FIXED( int vehicle, int tyreIndex) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TYRE_FIXED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NUMBER_PLATE_TEXT( int vehicle, const char* plateText) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NUMBER_PLATE_TEXT(vehicle, invoke<void);
	}

	const char* LUA_NATIVE_VEHICLE_GET_VEHICLE_NUMBER_PLATE_TEXT( int vehicle) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_VEHICLE_NUMBER_PLATE_TEXT(char*);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_NUMBER_OF_VEHICLE_NUMBER_PLATES(  )
	{
		auto retval = VEHICLE::GET_NUMBER_OF_VEHICLE_NUMBER_PLATES();
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NUMBER_PLATE_TEXT_INDEX( int vehicle, int plateIndex) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NUMBER_PLATE_TEXT_INDEX(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_NUMBER_PLATE_TEXT_INDEX( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_NUMBER_PLATE_TEXT_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_RANDOM_TRAINS( bool toggle) { invoke<void )
	{
		VEHICLE::SET_RANDOM_TRAINS(invoke<void);
	}

	int LUA_NATIVE_VEHICLE_CREATE_MISSION_TRAIN( int variation, float x, float y, float z, bool direction, Any p5, Any p6) { return invoke<int )
	{
		auto retval = VEHICLE::CREATE_MISSION_TRAIN(variation, x, y, z, direction, p5, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SWITCH_TRAIN_TRACK( int trackId, bool state) { invoke<void )
	{
		VEHICLE::SWITCH_TRAIN_TRACK(trackId, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRAIN_TRACK_SPAWN_FREQUENCY( int trackIndex, int frequency) { invoke<void )
	{
		VEHICLE::SET_TRAIN_TRACK_SPAWN_FREQUENCY(trackIndex, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ALLOW_TRAIN_TO_BE_REMOVED_BY_POPULATION( Any p0) { invoke<void )
	{
		VEHICLE::ALLOW_TRAIN_TO_BE_REMOVED_BY_POPULATION(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DELETE_ALL_TRAINS(  )
	{
		VEHICLE::DELETE_ALL_TRAINS();
	}

	void LUA_NATIVE_VEHICLE_SET_TRAIN_SPEED( int train, float speed) { invoke<void )
	{
		VEHICLE::SET_TRAIN_SPEED(train, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRAIN_CRUISE_SPEED( int train, float speed) { invoke<void )
	{
		VEHICLE::SET_TRAIN_CRUISE_SPEED(train, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_RANDOM_BOATS( bool toggle) { invoke<void )
	{
		VEHICLE::SET_RANDOM_BOATS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_RANDOM_BOATS_MP( bool toggle) { invoke<void )
	{
		VEHICLE::SET_RANDOM_BOATS_MP(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_GARBAGE_TRUCKS( bool toggle) { invoke<void )
	{
		VEHICLE::SET_GARBAGE_TRUCKS(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_VEHICLE_HAVE_STUCK_VEHICLE_CHECK( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_VEHICLE_HAVE_STUCK_VEHICLE_CHECK(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_RECORDING_ID( int recording, const char* script) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_RECORDING_ID(recording, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REQUEST_VEHICLE_RECORDING( int recording, const char* script) { invoke<void )
	{
		VEHICLE::REQUEST_VEHICLE_RECORDING(recording, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_HAS_VEHICLE_RECORDING_BEEN_LOADED( int recording, const char* script) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAS_VEHICLE_RECORDING_BEEN_LOADED(recording, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_RECORDING( int recording, const char* script) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_RECORDING(recording, invoke<void);
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_POSITION_OF_VEHICLE_RECORDING_ID_AT_TIME( int id, float time) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_POSITION_OF_VEHICLE_RECORDING_ID_AT_TIME(id, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_POSITION_OF_VEHICLE_RECORDING_AT_TIME( int recording, float time, const char* script) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_POSITION_OF_VEHICLE_RECORDING_AT_TIME(recording, time, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_ROTATION_OF_VEHICLE_RECORDING_ID_AT_TIME( int id, float time) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_ROTATION_OF_VEHICLE_RECORDING_ID_AT_TIME(id, invoke<Vector3);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_ROTATION_OF_VEHICLE_RECORDING_AT_TIME( int recording, float time, const char* script) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_ROTATION_OF_VEHICLE_RECORDING_AT_TIME(recording, time, invoke<Vector3);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_TOTAL_DURATION_OF_VEHICLE_RECORDING_ID( int id) { return invoke<float )
	{
		auto retval = VEHICLE::GET_TOTAL_DURATION_OF_VEHICLE_RECORDING_ID(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_TOTAL_DURATION_OF_VEHICLE_RECORDING( int recording, const char* script) { return invoke<float )
	{
		auto retval = VEHICLE::GET_TOTAL_DURATION_OF_VEHICLE_RECORDING(recording, invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_POSITION_IN_RECORDING( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_POSITION_IN_RECORDING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_TIME_POSITION_IN_RECORDING( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_TIME_POSITION_IN_RECORDING(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_START_PLAYBACK_RECORDED_VEHICLE( int vehicle, int recording, const char* script, bool p3) { invoke<void )
	{
		VEHICLE::START_PLAYBACK_RECORDED_VEHICLE(vehicle, recording, script, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_START_PLAYBACK_RECORDED_VEHICLE_WITH_FLAGS( int vehicle, int recording, const char* script, int flags, int time, int drivingStyle) { invoke<void )
	{
		VEHICLE::START_PLAYBACK_RECORDED_VEHICLE_WITH_FLAGS(vehicle, recording, script, flags, time, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_FORCE_PLAYBACK_RECORDED_VEHICLE_UPDATE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::FORCE_PLAYBACK_RECORDED_VEHICLE_UPDATE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_STOP_PLAYBACK_RECORDED_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::STOP_PLAYBACK_RECORDED_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_PAUSE_PLAYBACK_RECORDED_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::PAUSE_PLAYBACK_RECORDED_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_UNPAUSE_PLAYBACK_RECORDED_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::UNPAUSE_PLAYBACK_RECORDED_VEHICLE(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_PLAYBACK_GOING_ON_FOR_VEHICLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_PLAYBACK_GOING_ON_FOR_VEHICLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_PLAYBACK_USING_AI_GOING_ON_FOR_VEHICLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_PLAYBACK_USING_AI_GOING_ON_FOR_VEHICLE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_CURRENT_PLAYBACK_FOR_VEHICLE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_CURRENT_PLAYBACK_FOR_VEHICLE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SKIP_TO_END_AND_STOP_PLAYBACK_RECORDED_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::SKIP_TO_END_AND_STOP_PLAYBACK_RECORDED_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLAYBACK_SPEED( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_PLAYBACK_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_START_PLAYBACK_RECORDED_VEHICLE_USING_AI( int vehicle, int recording, const char* script, float speed, int drivingStyle) { invoke<void )
	{
		VEHICLE::START_PLAYBACK_RECORDED_VEHICLE_USING_AI(vehicle, recording, script, speed, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SKIP_TIME_IN_PLAYBACK_RECORDED_VEHICLE( int vehicle, float time) { invoke<void )
	{
		VEHICLE::SKIP_TIME_IN_PLAYBACK_RECORDED_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLAYBACK_TO_USE_AI( int vehicle, int drivingStyle) { invoke<void )
	{
		VEHICLE::SET_PLAYBACK_TO_USE_AI(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER( int vehicle, int time, int drivingStyle, bool p3) { invoke<void )
	{
		VEHICLE::SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER(vehicle, time, drivingStyle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ADDITIONAL_ROTATION_FOR_RECORDED_VEHICLE_PLAYBACK( int vehicle, float x, float y, float z, Any p4) { invoke<void )
	{
		VEHICLE::SET_ADDITIONAL_ROTATION_FOR_RECORDED_VEHICLE_PLAYBACK(vehicle, x, y, z, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_POSITION_OFFSET_FOR_RECORDED_VEHICLE_PLAYBACK( int vehicle, float x, float y, float z) { invoke<void )
	{
		VEHICLE::SET_POSITION_OFFSET_FOR_RECORDED_VEHICLE_PLAYBACK(vehicle, x, y, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_GLOBAL_POSITION_OFFSET_FOR_RECORDED_VEHICLE_PLAYBACK( int vehicle, float x, float y, float z) { invoke<void )
	{
		VEHICLE::SET_GLOBAL_POSITION_OFFSET_FOR_RECORDED_VEHICLE_PLAYBACK(vehicle, x, y, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SHOULD_LERP_FROM_AI_TO_FULL_RECORDING( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_SHOULD_LERP_FROM_AI_TO_FULL_RECORDING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_EXPLODE_VEHICLE_IN_CUTSCENE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::EXPLODE_VEHICLE_IN_CUTSCENE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ADD_VEHICLE_STUCK_CHECK_WITH_WARP( Any p0, float p1, Any p2, bool p3, bool p4, bool p5, Any p6) { invoke<void )
	{
		VEHICLE::ADD_VEHICLE_STUCK_CHECK_WITH_WARP(p0, p1, p2, p3, p4, p5, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MODEL_IS_SUPPRESSED( unsigned model, bool suppressed) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MODEL_IS_SUPPRESSED(model, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_RANDOM_VEHICLE_IN_SPHERE( float x, float y, float z, float radius, unsigned modelHash, int flags) { return invoke<int )
	{
		auto retval = VEHICLE::GET_RANDOM_VEHICLE_IN_SPHERE(x, y, z, radius, modelHash, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_RANDOM_VEHICLE_FRONT_BUMPER_IN_SPHERE( float p0, float p1, float p2, float p3, int p4, int p5, int p6) { return invoke<int )
	{
		auto retval = VEHICLE::GET_RANDOM_VEHICLE_FRONT_BUMPER_IN_SPHERE(p0, p1, p2, p3, p4, p5, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_RANDOM_VEHICLE_BACK_BUMPER_IN_SPHERE( float p0, float p1, float p2, float p3, int p4, int p5, int p6) { return invoke<int )
	{
		auto retval = VEHICLE::GET_RANDOM_VEHICLE_BACK_BUMPER_IN_SPHERE(p0, p1, p2, p3, p4, p5, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_CLOSEST_VEHICLE( float x, float y, float z, float radius, unsigned modelHash, int flags) { return invoke<int )
	{
		auto retval = VEHICLE::GET_CLOSEST_VEHICLE(x, y, z, radius, modelHash, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_TRAIN_CARRIAGE( int train, int trailerNumber) { return invoke<int )
	{
		auto retval = VEHICLE::GET_TRAIN_CARRIAGE(train, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_MISSION_TRAIN( int train) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_MISSION_TRAIN(invoke<BOOL);
		return retval;
	}

	int train) { LUA_NATIVE_VEHICLE_DELETE_MISSION_TRAIN( int train) { invoke<void )
	{
		VEHICLE::DELETE_MISSION_TRAIN(&invoke<void);
		return invoke<void;
	}

	int LUA_NATIVE_VEHICLE_SET_MISSION_TRAIN_AS_NO_LONGER_NEEDED( int train, bool p1) { invoke<void )
	{
		VEHICLE::SET_MISSION_TRAIN_AS_NO_LONGER_NEEDED(&train, invoke<void);
		return train;
	}

	void LUA_NATIVE_VEHICLE_SET_MISSION_TRAIN_COORDS( int train, float x, float y, float z) { invoke<void )
	{
		VEHICLE::SET_MISSION_TRAIN_COORDS(train, x, y, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_BOAT( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_BOAT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_JETSKI( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_JETSKI(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_PLANE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_PLANE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_HELI( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_HELI(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_CAR( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_CAR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_TRAIN( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_TRAIN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_BIKE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_BIKE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_BICYCLE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_BICYCLE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_A_QUADBIKE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_A_QUADBIKE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_AN_AMPHIBIOUS_CAR( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_AN_AMPHIBIOUS_CAR(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_THIS_MODEL_AN_AMPHIBIOUS_QUADBIKE( unsigned model) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_THIS_MODEL_AN_AMPHIBIOUS_QUADBIKE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_BLADES_FULL_SPEED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_HELI_BLADES_FULL_SPEED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_BLADES_SPEED( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_HELI_BLADES_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_FORCE_SUB_THROTTLE_FOR_TIME( int vehicle, float p1, float p2) { invoke<void )
	{
		VEHICLE::FORCE_SUB_THROTTLE_FOR_TIME(vehicle, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_BE_TARGETTED( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_BE_TARGETTED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DONT_ALLOW_PLAYER_TO_ENTER_VEHICLE_IF_LOCKED_FOR_PLAYER( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_DONT_ALLOW_PLAYER_TO_ENTER_VEHICLE_IF_LOCKED_FOR_PLAYER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_BE_VISIBLY_DAMAGED( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_BE_VISIBLY_DAMAGED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HAS_UNBREAKABLE_LIGHTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HAS_UNBREAKABLE_LIGHTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_RESPECTS_LOCKS_WHEN_HAS_DRIVER( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_RESPECTS_LOCKS_WHEN_HAS_DRIVER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_EJECT_PASSENGERS_IF_LOCKED( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_EJECT_PASSENGERS_IF_LOCKED(p0, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_DIRT_LEVEL( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_DIRT_LEVEL(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DIRT_LEVEL( int vehicle, float dirtLevel) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DIRT_LEVEL(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_DOES_VEHICLE_HAVE_DAMAGE_DECALS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_DOES_VEHICLE_HAVE_DAMAGE_DECALS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_DOOR_FULLY_OPEN( int vehicle, int doorId) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_DOOR_FULLY_OPEN(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ENGINE_ON( int vehicle, bool value, bool instantly, bool disableAutoStart) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ENGINE_ON(vehicle, value, instantly, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_UNDRIVEABLE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_UNDRIVEABLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_PROVIDES_COVER( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_PROVIDES_COVER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_CONTROL( int vehicle, int doorId, int speed, float angle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_CONTROL(vehicle, doorId, speed, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_LATCHED( int vehicle, int doorId, bool p2, bool p3, bool p4) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_LATCHED(vehicle, doorId, p2, p3, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_DOOR_ANGLE_RATIO( int vehicle, int doorId) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_DOOR_ANGLE_RATIO(vehicle, invoke<float);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_PED_USING_VEHICLE_DOOR( int vehicle, int doord) { return invoke<int )
	{
		auto retval = VEHICLE::GET_PED_USING_VEHICLE_DOOR(vehicle, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_SHUT( int vehicle, int doorId, bool closeInstantly) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_SHUT(vehicle, doorId, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DOOR_BROKEN( int vehicle, int doorId, bool deleteDoor) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DOOR_BROKEN(vehicle, doorId, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_BREAK( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_BREAK(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_VEHICLE_HAVE_ROOF( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_VEHICLE_HAVE_ROOF(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_REMOVE_AGGRESSIVE_CARJACK_MISSION( Any p0) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_REMOVE_AGGRESSIVE_CARJACK_MISSION(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_AVOID_PLAYER_VEHICLE_RIOT_VAN_MISSION( Any p0) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_AVOID_PLAYER_VEHICLE_RIOT_VAN_MISSION(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARJACK_MISSION_REMOVAL_PARAMETERS( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_CARJACK_MISSION_REMOVAL_PARAMETERS(p0, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_BIG_VEHICLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_BIG_VEHICLE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_NUMBER_OF_VEHICLE_COLOURS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_NUMBER_OF_VEHICLE_COLOURS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_COLOUR_COMBINATION( int vehicle, int colorCombination) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_COLOUR_COMBINATION(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_COLOUR_COMBINATION( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_COLOUR_COMBINATION(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_XENON_LIGHT_COLOR_INDEX( int vehicle, int colorIndex) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_XENON_LIGHT_COLOR_INDEX(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_XENON_LIGHT_COLOR_INDEX( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_XENON_LIGHT_COLOR_INDEX(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IS_CONSIDERED_BY_PLAYER( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IS_CONSIDERED_BY_PLAYER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WILL_FORCE_OTHER_VEHICLES_TO_STOP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WILL_FORCE_OTHER_VEHICLES_TO_STOP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ACT_AS_IF_HAS_SIREN_ON( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ACT_AS_IF_HAS_SIREN_ON(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USE_MORE_RESTRICTIVE_SPAWN_CHECKS( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USE_MORE_RESTRICTIVE_SPAWN_CHECKS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MAY_BE_USED_BY_GOTO_POINT_ANY_MEANS( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MAY_BE_USED_BY_GOTO_POINT_ANY_MEANS(vehicle, invoke<void);
	}

	std::tuple<unsigned, int successIndicator) {> LUA_NATIVE_VEHICLE_GET_RANDOM_VEHICLE_MODEL_IN_MEMORY( bool p0, unsigned modelHash, int successIndicator) { invoke<void )
	{
		std::tuple<unsigned, int successIndicator) {> return_values;
		VEHICLE::GET_RANDOM_VEHICLE_MODEL_IN_MEMORY(p0, &modelHash, &invoke<void);
		std::get<0>(return_values) = modelHash;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_DOOR_LOCK_STATUS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_DOOR_LOCK_STATUS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_INDIVIDUAL_DOOR_LOCK_STATUS( int vehicle, int doorId) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_INDIVIDUAL_DOOR_LOCK_STATUS(vehicle, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_DOOR_DAMAGED( int veh, int doorID) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_DOOR_DAMAGED(veh, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DOOR_ALLOWED_TO_BE_BROKEN_OFF( int vehicle, int doorId, bool isBreakable) { invoke<void )
	{
		VEHICLE::SET_DOOR_ALLOWED_TO_BE_BROKEN_OFF(vehicle, doorId, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_BUMPER_BOUNCING( int vehicle, bool frontBumper) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_BUMPER_BOUNCING(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_BUMPER_BROKEN_OFF( int vehicle, bool frontBumper) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_BUMPER_BROKEN_OFF(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_COP_VEHICLE_IN_AREA_3D( float x1, float x2, float y1, float y2, float z1, float z2) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_COP_VEHICLE_IN_AREA_3D(x1, x2, y1, y2, z1, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_ON_ALL_WHEELS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_ON_ALL_WHEELS(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_VALUE( unsigned vehicleModel) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_VALUE(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_VEHICLE_GET_VEHICLE_LAYOUT_HASH( int vehicle) { return invoke<unsigned )
	{
		auto retval = VEHICLE::GET_VEHICLE_LAYOUT_HASH(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_VEHICLE_GET_IN_VEHICLE_CLIPSET_HASH_FOR_SEAT( int vehicle, int p1) { return invoke<unsigned )
	{
		auto retval = VEHICLE::GET_IN_VEHICLE_CLIPSET_HASH_FOR_SEAT(vehicle, invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_RENDER_TRAIN_AS_DERAILED( int train, bool toggle) { invoke<void )
	{
		VEHICLE::SET_RENDER_TRAIN_AS_DERAILED(train, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXTRA_COLOURS( int vehicle, int pearlescentColor, int wheelColor) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXTRA_COLOURS(vehicle, pearlescentColor, invoke<void);
	}

	std::tuple<int, int wheelColor) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_EXTRA_COLOURS( int vehicle, int pearlescentColor, int wheelColor) { invoke<void )
	{
		std::tuple<int, int wheelColor) {> return_values;
		VEHICLE::GET_VEHICLE_EXTRA_COLOURS(vehicle, &pearlescentColor, &invoke<void);
		std::get<0>(return_values) = pearlescentColor;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXTRA_COLOUR_5( int vehicle, int color) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXTRA_COLOUR_5(vehicle, invoke<void);
	}

	int color) { LUA_NATIVE_VEHICLE_GET_VEHICLE_EXTRA_COLOUR_5( int vehicle, int color) { invoke<void )
	{
		VEHICLE::GET_VEHICLE_EXTRA_COLOUR_5(vehicle, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXTRA_COLOUR_6( int vehicle, int color) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXTRA_COLOUR_6(vehicle, invoke<void);
	}

	int color) { LUA_NATIVE_VEHICLE_GET_VEHICLE_EXTRA_COLOUR_6( int vehicle, int color) { invoke<void )
	{
		VEHICLE::GET_VEHICLE_EXTRA_COLOUR_6(vehicle, &invoke<void);
		return invoke<void;
	}

	void LUA_NATIVE_VEHICLE_STOP_ALL_GARAGE_ACTIVITY(  )
	{
		VEHICLE::STOP_ALL_GARAGE_ACTIVITY();
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FIXED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FIXED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DEFORMATION_FIXED( int vehicle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DEFORMATION_FIXED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_ENGINE_MISSFIRE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_ENGINE_MISSFIRE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_LEAK_OIL( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_LEAK_OIL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_LEAK_PETROL( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_LEAK_PETROL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_VEHICLE_PETROL_TANK_FIRES( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_VEHICLE_PETROL_TANK_FIRES(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_VEHICLE_PETROL_TANK_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_VEHICLE_PETROL_TANK_DAMAGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_VEHICLE_ENGINE_FIRES( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_VEHICLE_ENGINE_FIRES(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LIMIT_SPEED_WHEN_PLAYER_INACTIVE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LIMIT_SPEED_WHEN_PLAYER_INACTIVE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STOP_INSTANTLY_WHEN_PLAYER_INACTIVE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STOP_INSTANTLY_WHEN_PLAYER_INACTIVE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_PRETEND_OCCUPANTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_PRETEND_OCCUPANTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLES_FROM_GENERATORS_IN_AREA( float x1, float y1, float z1, float x2, float y2, float z2, Any p6) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLES_FROM_GENERATORS_IN_AREA(x1, y1, z1, x2, y2, z2, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STEER_BIAS( int vehicle, float value) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STEER_BIAS(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_EXTRA_TURNED_ON( int vehicle, int extraId) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_EXTRA_TURNED_ON(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXTRA( int vehicle, int extraId, bool disable) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXTRA(vehicle, extraId, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_EXTRA_EXIST( int vehicle, int extraId) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_EXTRA_EXIST(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_EXTRA_BROKEN_OFF( int vehicle, int extraId) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_EXTRA_BROKEN_OFF(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_CONVERTIBLE_ROOF( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_CONVERTIBLE_ROOF(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_LOWER_CONVERTIBLE_ROOF( int vehicle, bool instantlyLower) { invoke<void )
	{
		VEHICLE::LOWER_CONVERTIBLE_ROOF(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_RAISE_CONVERTIBLE_ROOF( int vehicle, bool instantlyRaise) { invoke<void )
	{
		VEHICLE::RAISE_CONVERTIBLE_ROOF(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_CONVERTIBLE_ROOF_STATE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_CONVERTIBLE_ROOF_STATE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_A_CONVERTIBLE( int vehicle, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_A_CONVERTIBLE(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_TRANSFORM_TO_SUBMARINE( int vehicle, bool noAnimation) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::TRANSFORM_TO_SUBMARINE(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_TRANSFORM_TO_CAR( int vehicle, bool noAnimation) { invoke<void )
	{
		VEHICLE::TRANSFORM_TO_CAR(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_IN_SUBMARINE_MODE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_IN_SUBMARINE_MODE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_STOPPED_AT_TRAFFIC_LIGHTS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_STOPPED_AT_TRAFFIC_LIGHTS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DAMAGE( int vehicle, float xOffset, float yOffset, float zOffset, float damage, float radius, bool focusOnModel) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DAMAGE(vehicle, xOffset, yOffset, zOffset, damage, radius, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_OCCUPANTS_TAKE_EXPLOSIVE_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_OCCUPANTS_TAKE_EXPLOSIVE_DAMAGE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_ENGINE_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_ENGINE_HEALTH(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ENGINE_HEALTH( int vehicle, float health) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ENGINE_HEALTH(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLANE_ENGINE_HEALTH( int vehicle, float health) { invoke<void )
	{
		VEHICLE::SET_PLANE_ENGINE_HEALTH(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_PETROL_TANK_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_PETROL_TANK_HEALTH(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_PETROL_TANK_HEALTH( int vehicle, float health) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_PETROL_TANK_HEALTH(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_STUCK_TIMER_UP( int vehicle, int p1, int ms) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_STUCK_TIMER_UP(vehicle, p1, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_RESET_VEHICLE_STUCK_TIMER( int vehicle, int nullAttributes) { invoke<void )
	{
		VEHICLE::RESET_VEHICLE_STUCK_TIMER(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_DRIVEABLE( int vehicle, bool isOnFireCheck) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_DRIVEABLE(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HAS_BEEN_OWNED_BY_PLAYER( int vehicle, bool owned) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HAS_BEEN_OWNED_BY_PLAYER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NEEDS_TO_BE_HOTWIRED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NEEDS_TO_BE_HOTWIRED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BLIP_THROTTLE_RANDOMLY( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BLIP_THROTTLE_RANDOMLY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_POLICE_FOCUS_WILL_TRACK_VEHICLE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_POLICE_FOCUS_WILL_TRACK_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_START_VEHICLE_HORN( int vehicle, int duration, unsigned mode, bool forever) { invoke<void )
	{
		VEHICLE::START_VEHICLE_HORN(vehicle, duration, mode, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IN_CAR_MOD_SHOP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IN_CAR_MOD_SHOP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HAS_STRONG_AXLES( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HAS_STRONG_AXLES(vehicle, invoke<void);
	}

	const char* LUA_NATIVE_VEHICLE_GET_DISPLAY_NAME_FROM_VEHICLE_MODEL( unsigned modelHash) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_DISPLAY_NAME_FROM_VEHICLE_MODEL(char*);
		return retval;
	}

	const char* LUA_NATIVE_VEHICLE_GET_MAKE_NAME_FROM_VEHICLE_MODEL( unsigned modelHash) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_MAKE_NAME_FROM_VEHICLE_MODEL(char*);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_VEHICLE_DEFORMATION_AT_POS( int vehicle, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_VEHICLE_DEFORMATION_AT_POS(vehicle, offsetX, offsetY, invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LIVERY( int vehicle, int livery) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LIVERY(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_LIVERY( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_LIVERY(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_LIVERY_COUNT( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_LIVERY_COUNT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LIVERY2( int vehicle, int livery) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LIVERY2(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_LIVERY2( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_LIVERY2(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_LIVERY2_COUNT( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_LIVERY2_COUNT(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_WINDOW_INTACT( int vehicle, int windowIndex) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_WINDOW_INTACT(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_ARE_ALL_VEHICLE_WINDOWS_INTACT( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_ALL_VEHICLE_WINDOWS_INTACT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_ARE_ANY_VEHICLE_SEATS_FREE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_ANY_VEHICLE_SEATS_FREE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_RESET_VEHICLE_WHEELS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::RESET_VEHICLE_WHEELS(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_HELI_PART_BROKEN( int vehicle, bool p1, bool p2, bool p3) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_HELI_PART_BROKEN(vehicle, p1, p2, invoke<BOOL);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_HELI_MAIN_ROTOR_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_HELI_MAIN_ROTOR_HEALTH(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_HELI_TAIL_ROTOR_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_HELI_TAIL_ROTOR_HEALTH(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_HELI_TAIL_BOOM_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_HELI_TAIL_BOOM_HEALTH(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_MAIN_ROTOR_HEALTH( int vehicle, float health) { invoke<void )
	{
		VEHICLE::SET_HELI_MAIN_ROTOR_HEALTH(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_TAIL_ROTOR_HEALTH( int vehicle, float health) { invoke<void )
	{
		VEHICLE::SET_HELI_TAIL_ROTOR_HEALTH(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_SET_HELI_TAIL_BOOM_CAN_BREAK_OFF( int vehicle, bool toggle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_HELI_TAIL_BOOM_CAN_BREAK_OFF(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NAME_DEBUG( int vehicle, const char* name) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NAME_DEBUG(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXPLODES_ON_HIGH_EXPLOSION_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXPLODES_ON_HIGH_EXPLOSION_DAMAGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXPLODES_ON_EXPLOSION_DAMAGE_AT_ZERO_BODY_HEALTH( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXPLODES_ON_EXPLOSION_DAMAGE_AT_ZERO_BODY_HEALTH(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ALLOW_VEHICLE_EXPLODES_ON_CONTACT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_ALLOW_VEHICLE_EXPLODES_ON_CONTACT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DISABLE_TOWING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DISABLE_TOWING(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_HAS_LANDING_GEAR( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_HAS_LANDING_GEAR(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_CONTROL_LANDING_GEAR( int vehicle, int state) { invoke<void )
	{
		VEHICLE::CONTROL_LANDING_GEAR(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_LANDING_GEAR_STATE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_LANDING_GEAR_STATE(invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_ANY_VEHICLE_NEAR_POINT( float x, float y, float z, float radius) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ANY_VEHICLE_NEAR_POINT(x, y, z, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REQUEST_VEHICLE_HIGH_DETAIL_MODEL( int vehicle) { invoke<void )
	{
		VEHICLE::REQUEST_VEHICLE_HIGH_DETAIL_MODEL(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_HIGH_DETAIL_MODEL( int vehicle) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_HIGH_DETAIL_MODEL(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_HIGH_DETAIL( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_HIGH_DETAIL(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REQUEST_VEHICLE_ASSET( unsigned vehicleHash, int vehicleAsset) { invoke<void )
	{
		VEHICLE::REQUEST_VEHICLE_ASSET(vehicleHash, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_HAS_VEHICLE_ASSET_LOADED( int vehicleAsset) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAS_VEHICLE_ASSET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_ASSET( int vehicleAsset) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_ASSET(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TOW_TRUCK_ARM_POSITION( int vehicle, float position) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TOW_TRUCK_ARM_POSITION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ATTACH_VEHICLE_TO_TOW_TRUCK( int towTruck, int vehicle, bool rear, float hookOffsetX, float hookOffsetY, float hookOffsetZ) { invoke<void )
	{
		VEHICLE::ATTACH_VEHICLE_TO_TOW_TRUCK(towTruck, vehicle, rear, hookOffsetX, hookOffsetY, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DETACH_VEHICLE_FROM_TOW_TRUCK( int towTruck, int vehicle) { invoke<void )
	{
		VEHICLE::DETACH_VEHICLE_FROM_TOW_TRUCK(towTruck, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DETACH_VEHICLE_FROM_ANY_TOW_TRUCK( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DETACH_VEHICLE_FROM_ANY_TOW_TRUCK(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_ATTACHED_TO_TOW_TRUCK( int towTruck, int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_ATTACHED_TO_TOW_TRUCK(towTruck, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_ENTITY_ATTACHED_TO_TOW_TRUCK( int towTruck) { return invoke<int )
	{
		auto retval = VEHICLE::GET_ENTITY_ATTACHED_TO_TOW_TRUCK(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_SET_VEHICLE_AUTOMATICALLY_ATTACHES( int vehicle, bool p1, Any p2) { return invoke<int )
	{
		auto retval = VEHICLE::SET_VEHICLE_AUTOMATICALLY_ATTACHES(vehicle, p1, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BULLDOZER_ARM_POSITION( int vehicle, float position, bool p2) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BULLDOZER_ARM_POSITION(vehicle, position, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TANK_TURRET_POSITION( int vehicle, float position, bool p2) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TANK_TURRET_POSITION(vehicle, position, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TURRET_TARGET( int vehicle, bool p1, float x, float y, float z, bool p5) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TURRET_TARGET(vehicle, p1, x, y, z, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TANK_STATIONARY( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TANK_STATIONARY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TURRET_SPEED_THIS_FRAME( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TURRET_SPEED_THIS_FRAME(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DISABLE_VEHICLE_TURRET_MOVEMENT_THIS_FRAME( int vehicle) { invoke<void )
	{
		VEHICLE::DISABLE_VEHICLE_TURRET_MOVEMENT_THIS_FRAME(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FLIGHT_NOZZLE_POSITION( int vehicle, float angleRatio) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FLIGHT_NOZZLE_POSITION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FLIGHT_NOZZLE_POSITION_IMMEDIATE( int vehicle, float angle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FLIGHT_NOZZLE_POSITION_IMMEDIATE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_FLIGHT_NOZZLE_POSITION( int plane) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_FLIGHT_NOZZLE_POSITION(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_VERTICAL_FLIGHT_MODE_TRANSITION( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_VERTICAL_FLIGHT_MODE_TRANSITION(vehicle, invoke<void);
	}

	std::tuple<bool, Vector3, Vector3> LUA_NATIVE_VEHICLE_GENERATE_VEHICLE_CREATION_POS_FROM_PATHS( Vector3 outVec, Any p1, Vector3 outVec1, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3, Vector3> return_values;
		std::get<0>(return_values) = (bool)VEHICLE::GENERATE_VEHICLE_CREATION_POS_FROM_PATHS(&outVec, p1, &outVec1, p3, p4, p5, p6, p7, invoke<BOOL);
		std::get<1>(return_values) = outVec;
		std::get<2>(return_values) = outVec1;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BURNOUT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BURNOUT(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_IN_BURNOUT( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_IN_BURNOUT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_REDUCE_GRIP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_REDUCE_GRIP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_REDUCE_GRIP_LEVEL( int vehicle, int val) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_REDUCE_GRIP_LEVEL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_INDICATOR_LIGHTS( int vehicle, int turnSignal, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_INDICATOR_LIGHTS(vehicle, turnSignal, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BRAKE_LIGHTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BRAKE_LIGHTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TAIL_LIGHTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TAIL_LIGHTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HANDBRAKE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HANDBRAKE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BRAKE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BRAKE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_INSTANTLY_FILL_VEHICLE_POPULATION(  )
	{
		VEHICLE::INSTANTLY_FILL_VEHICLE_POPULATION();
	}

	bool LUA_NATIVE_VEHICLE_HAS_INSTANT_FILL_VEHICLE_POPULATION_FINISHED(  )
	{
		auto retval = (bool)VEHICLE::HAS_INSTANT_FILL_VEHICLE_POPULATION_FINISHED();
		return retval;
	}

	void LUA_NATIVE_VEHICLE_NETWORK_ENABLE_EMPTY_CROWDING_VEHICLES_REMOVAL( bool toggle) { invoke<void )
	{
		VEHICLE::NETWORK_ENABLE_EMPTY_CROWDING_VEHICLES_REMOVAL(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_NETWORK_CAP_EMPTY_CROWDING_VEHICLES_REMOVAL( int p0) { invoke<void )
	{
		VEHICLE::NETWORK_CAP_EMPTY_CROWDING_VEHICLES_REMOVAL(invoke<void);
	}

	std::tuple<bool, int trailer) { return> LUA_NATIVE_VEHICLE_GET_VEHICLE_TRAILER_VEHICLE( int vehicle, int trailer) { return invoke<BOOL )
	{
		std::tuple<bool, int trailer) { return> return_values;
		std::get<0>(return_values) = (bool)VEHICLE::GET_VEHICLE_TRAILER_VEHICLE(vehicle, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_TRAILER_PARENT_VEHICLE_( int trailer) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_TRAILER_PARENT_VEHICLE_(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USES_LARGE_REAR_RAMP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USES_LARGE_REAR_RAMP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_RUDDER_BROKEN( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_RUDDER_BROKEN(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CONVERTIBLE_ROOF_LATCH_STATE( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_CONVERTIBLE_ROOF_LATCH_STATE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_ESTIMATED_MAX_SPEED( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_ESTIMATED_MAX_SPEED(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MAX_BRAKING( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MAX_BRAKING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MAX_TRACTION( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MAX_TRACTION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_ACCELERATION( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_ACCELERATION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_ESTIMATED_MAX_SPEED( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_ESTIMATED_MAX_SPEED(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_MAX_BRAKING( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_MAX_BRAKING(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_MAX_BRAKING_MAX_MODS( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_MAX_BRAKING_MAX_MODS(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_MAX_TRACTION( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_MAX_TRACTION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_ACCELERATION( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_ACCELERATION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_MODEL_ACCELERATION_MAX_MODS( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_MODEL_ACCELERATION_MAX_MODS(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_FLYING_VEHICLE_MODEL_AGILITY( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_FLYING_VEHICLE_MODEL_AGILITY(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_BOAT_VEHICLE_MODEL_AGILITY( unsigned modelHash) { return invoke<float )
	{
		auto retval = VEHICLE::GET_BOAT_VEHICLE_MODEL_AGILITY(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_ESTIMATED_MAX_SPEED( int vehicleClass) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_ESTIMATED_MAX_SPEED(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_MAX_TRACTION( int vehicleClass) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_MAX_TRACTION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_MAX_AGILITY( int vehicleClass) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_MAX_AGILITY(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_MAX_ACCELERATION( int vehicleClass) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_MAX_ACCELERATION(invoke<float);
		return retval;
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_MAX_BRAKING( int vehicleClass) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_MAX_BRAKING(invoke<float);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_ADD_ROAD_NODE_SPEED_ZONE( float x, float y, float z, float radius, float speed, bool p5) { return invoke<int )
	{
		auto retval = VEHICLE::ADD_ROAD_NODE_SPEED_ZONE(x, y, z, radius, speed, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_REMOVE_ROAD_NODE_SPEED_ZONE( int speedzone) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::REMOVE_ROAD_NODE_SPEED_ZONE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_OPEN_BOMB_BAY_DOORS( int vehicle) { invoke<void )
	{
		VEHICLE::OPEN_BOMB_BAY_DOORS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_CLOSE_BOMB_BAY_DOORS( int vehicle) { invoke<void )
	{
		VEHICLE::CLOSE_BOMB_BAY_DOORS(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_ARE_BOMB_BAY_DOORS_OPEN( int aircraft) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_ARE_BOMB_BAY_DOORS_OPEN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_SEARCHLIGHT_ON( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_SEARCHLIGHT_ON(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_SEARCHLIGHT( int heli, bool toggle, bool canBeUsedByAI) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_SEARCHLIGHT(heli, toggle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_VEHICLE_HAVE_SEARCHLIGHT( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_VEHICLE_HAVE_SEARCHLIGHT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_ENTRY_POINT_FOR_SEAT_CLEAR( int ped, int vehicle, int seatIndex, bool side, bool onEnter) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ENTRY_POINT_FOR_SEAT_CLEAR(ped, vehicle, seatIndex, side, invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_ENTRY_POINT_POSITION( int vehicle, int doorId) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_ENTRY_POINT_POSITION(vehicle, invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_CAN_SHUFFLE_SEAT( int vehicle, int seatIndex) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::CAN_SHUFFLE_SEAT(vehicle, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_NUM_MOD_KITS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_NUM_MOD_KITS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MOD_KIT( int vehicle, int modKit) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MOD_KIT(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_KIT( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_KIT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_KIT_TYPE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_KIT_TYPE(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_WHEEL_TYPE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_WHEEL_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WHEEL_TYPE( int vehicle, int WheelType) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WHEEL_TYPE(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_NUM_MOD_COLORS( int paintType, bool p1) { return invoke<int )
	{
		auto retval = VEHICLE::GET_NUM_MOD_COLORS(paintType, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MOD_COLOR_1( int vehicle, int paintType, int color, int pearlescentColor) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MOD_COLOR_1(vehicle, paintType, color, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MOD_COLOR_2( int vehicle, int paintType, int color) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MOD_COLOR_2(vehicle, paintType, invoke<void);
	}

	std::tuple<int, int, int pearlescentColor) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_COLOR_1( int vehicle, int paintType, int color, int pearlescentColor) { invoke<void )
	{
		std::tuple<int, int, int pearlescentColor) {> return_values;
		VEHICLE::GET_VEHICLE_MOD_COLOR_1(vehicle, &paintType, &color, &invoke<void);
		std::get<0>(return_values) = paintType;
		std::get<1>(return_values) = color;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	std::tuple<int, int color) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_COLOR_2( int vehicle, int paintType, int color) { invoke<void )
	{
		std::tuple<int, int color) {> return_values;
		VEHICLE::GET_VEHICLE_MOD_COLOR_2(vehicle, &paintType, &invoke<void);
		std::get<0>(return_values) = paintType;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	const char* LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_COLOR_1_NAME( int vehicle, bool p1) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_COLOR_1_NAME(vehicle, char*);
		return retval;
	}

	const char* LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_COLOR_2_NAME( int vehicle) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_COLOR_2_NAME(char*);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_HAVE_VEHICLE_MODS_STREAMED_IN( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAVE_VEHICLE_MODS_STREAMED_IN(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_MOD_GEN9_EXCLUSIVE( int vehicle, int modType, int modIndex) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_MOD_GEN9_EXCLUSIVE(vehicle, modType, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MOD( int vehicle, int modType, int modIndex, bool customTires) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MOD(vehicle, modType, modIndex, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD( int vehicle, int modType) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD(vehicle, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_VARIATION( int vehicle, int modType) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_VARIATION(vehicle, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_NUM_VEHICLE_MODS( int vehicle, int modType) { return invoke<int )
	{
		auto retval = VEHICLE::GET_NUM_VEHICLE_MODS(vehicle, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_MOD( int vehicle, int modType) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_MOD(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_TOGGLE_VEHICLE_MOD( int vehicle, int modType, bool toggle) { invoke<void )
	{
		VEHICLE::TOGGLE_VEHICLE_MOD(vehicle, modType, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_TOGGLE_MOD_ON( int vehicle, int modType) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_TOGGLE_MOD_ON(vehicle, invoke<BOOL);
		return retval;
	}

	const char* LUA_NATIVE_VEHICLE_GET_MOD_TEXT_LABEL( int vehicle, int modType, int modValue) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_MOD_TEXT_LABEL(vehicle, modType, char*);
		return retval;
	}

	const char* LUA_NATIVE_VEHICLE_GET_MOD_SLOT_NAME( int vehicle, int modType) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_MOD_SLOT_NAME(vehicle, char*);
		return retval;
	}

	const char* LUA_NATIVE_VEHICLE_GET_LIVERY_NAME( int vehicle, int liveryIndex) { return invoke<const char* )
	{
		auto retval = VEHICLE::GET_LIVERY_NAME(vehicle, char*);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_MODIFIER_VALUE( int vehicle, int modType, int modIndex) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_MODIFIER_VALUE(vehicle, modType, invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_VEHICLE_GET_VEHICLE_MOD_IDENTIFIER_HASH( int vehicle, int modType, int modIndex) { return invoke<unsigned )
	{
		auto retval = VEHICLE::GET_VEHICLE_MOD_IDENTIFIER_HASH(vehicle, modType, invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_PRELOAD_VEHICLE_MOD( int vehicle, int modType, int modIndex) { invoke<void )
	{
		VEHICLE::PRELOAD_VEHICLE_MOD(vehicle, modType, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_HAS_PRELOAD_MODS_FINISHED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAS_PRELOAD_MODS_FINISHED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_RELEASE_PRELOAD_MODS( int vehicle) { invoke<void )
	{
		VEHICLE::RELEASE_PRELOAD_MODS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_TYRE_SMOKE_COLOR( int vehicle, int r, int g, int b) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_TYRE_SMOKE_COLOR(vehicle, r, g, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_TYRE_SMOKE_COLOR( int vehicle, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		VEHICLE::GET_VEHICLE_TYRE_SMOKE_COLOR(vehicle, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WINDOW_TINT( int vehicle, int tint) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WINDOW_TINT(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_WINDOW_TINT( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_WINDOW_TINT(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_NUM_VEHICLE_WINDOW_TINTS(  )
	{
		auto retval = VEHICLE::GET_NUM_VEHICLE_WINDOW_TINTS();
		return retval;
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_COLOR( int vehicle, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		VEHICLE::GET_VEHICLE_COLOR(vehicle, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_COLOURS_WHICH_CAN_BE_SET( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_COLOURS_WHICH_CAN_BE_SET(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_VEHICLE_GET_VEHICLE_CAUSE_OF_DESTRUCTION( int vehicle) { return invoke<unsigned )
	{
		auto retval = VEHICLE::GET_VEHICLE_CAUSE_OF_DESTRUCTION(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_OVERRIDE_PLANE_DAMAGE_THREHSOLD( int vehicle, float health) { invoke<void )
	{
		VEHICLE::OVERRIDE_PLANE_DAMAGE_THREHSOLD(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_LEFT_VEHICLE_HEADLIGHT_DAMAGED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_LEFT_VEHICLE_HEADLIGHT_DAMAGED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_RIGHT_VEHICLE_HEADLIGHT_DAMAGED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_RIGHT_VEHICLE_HEADLIGHT_DAMAGED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_BOTH_VEHICLE_HEADLIGHTS_DAMAGED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_BOTH_VEHICLE_HEADLIGHTS_DAMAGED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_MODIFY_VEHICLE_TOP_SPEED( int vehicle, float value) { invoke<void )
	{
		VEHICLE::MODIFY_VEHICLE_TOP_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_MAX_SPEED( int vehicle, float speed) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_MAX_SPEED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STAYS_FROZEN_WHEN_CLEANED_UP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STAYS_FROZEN_WHEN_CLEANED_UP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ACT_AS_IF_HIGH_SPEED_FOR_FRAG_SMASHING( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ACT_AS_IF_HIGH_SPEED_FOR_FRAG_SMASHING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PEDS_CAN_FALL_OFF_THIS_VEHICLE_FROM_LARGE_FALL_DAMAGE( int vehicle, bool toggle, float p2) { invoke<void )
	{
		VEHICLE::SET_PEDS_CAN_FALL_OFF_THIS_VEHICLE_FROM_LARGE_FALL_DAMAGE(vehicle, toggle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_ADD_VEHICLE_COMBAT_ANGLED_AVOIDANCE_AREA( float p0, float p1, float p2, float p3, float p4, float p5, float p6) { return invoke<int )
	{
		auto retval = VEHICLE::ADD_VEHICLE_COMBAT_ANGLED_AVOIDANCE_AREA(p0, p1, p2, p3, p4, p5, invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_REMOVE_VEHICLE_COMBAT_AVOIDANCE_AREA( int p0) { invoke<void )
	{
		VEHICLE::REMOVE_VEHICLE_COMBAT_AVOIDANCE_AREA(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_ANY_PED_RAPPELLING_FROM_HELI( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ANY_PED_RAPPELLING_FROM_HELI(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CHEAT_POWER_INCREASE( int vehicle, float value) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CHEAT_POWER_INCREASE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_INFLUENCES_WANTED_LEVEL( Any p0, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_INFLUENCES_WANTED_LEVEL(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IS_WANTED( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IS_WANTED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SWING_BOAT_BOOM_TO_RATIO( int vehicle, float ratio) { invoke<void )
	{
		VEHICLE::SWING_BOAT_BOOM_TO_RATIO(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SWING_BOAT_BOOM_FREELY( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SWING_BOAT_BOOM_FREELY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ALLOW_BOAT_BOOM_TO_ANIMATE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::ALLOW_BOAT_BOOM_TO_ANIMATE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_BOAT_BOOM_POSITION_RATIO( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_BOAT_BOOM_POSITION_RATIO(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_DISABLE_PLANE_AILERON( int vehicle, bool p1, bool p2) { invoke<void )
	{
		VEHICLE::DISABLE_PLANE_AILERON(vehicle, p1, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_VEHICLE_ENGINE_RUNNING( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_VEHICLE_ENGINE_RUNNING(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USE_ALTERNATE_HANDLING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USE_ALTERNATE_HANDLING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BIKE_ON_STAND( int vehicle, float x, float y) { invoke<void )
	{
		VEHICLE::SET_BIKE_ON_STAND(vehicle, x, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NOT_STEALABLE_AMBIENTLY( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NOT_STEALABLE_AMBIENTLY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_LOCK_DOORS_WHEN_NO_LONGER_NEEDED( int vehicle) { invoke<void )
	{
		VEHICLE::LOCK_DOORS_WHEN_NO_LONGER_NEEDED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_LAST_DRIVEN_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::SET_LAST_DRIVEN_VEHICLE(invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_LAST_DRIVEN_VEHICLE(  )
	{
		auto retval = VEHICLE::GET_LAST_DRIVEN_VEHICLE();
		return retval;
	}

	void LUA_NATIVE_VEHICLE_CLEAR_LAST_DRIVEN_VEHICLE(  )
	{
		VEHICLE::CLEAR_LAST_DRIVEN_VEHICLE();
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HAS_BEEN_DRIVEN_FLAG( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HAS_BEEN_DRIVEN_FLAG(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TASK_VEHICLE_GOTO_PLANE_MIN_HEIGHT_ABOVE_TERRAIN( int plane, int height) { invoke<void )
	{
		VEHICLE::SET_TASK_VEHICLE_GOTO_PLANE_MIN_HEIGHT_ABOVE_TERRAIN(plane, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_LOD_MULTIPLIER( int vehicle, float multiplier) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_LOD_MULTIPLIER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_SAVE_IN_GARAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_SAVE_IN_GARAGE(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_NUM_OF_BROKEN_OFF_PARTS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_NUM_OF_BROKEN_OFF_PARTS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_NUM_OF_BROKEN_LOOSEN_PARTS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_NUM_OF_BROKEN_LOOSEN_PARTS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_FORCE_VEHICLE_ENGINE_DAMAGE_BY_BULLET( Any p0, bool p1) { invoke<void )
	{
		VEHICLE::SET_FORCE_VEHICLE_ENGINE_DAMAGE_BY_BULLET(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_GENERATES_ENGINE_SHOCKING_EVENTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_GENERATES_ENGINE_SHOCKING_EVENTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_COPY_VEHICLE_DAMAGES( int sourceVehicle, int targetVehicle) { invoke<void )
	{
		VEHICLE::COPY_VEHICLE_DAMAGES(sourceVehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DISABLE_VEHICLE_EXPLOSION_BREAK_OFF_PARTS(  )
	{
		VEHICLE::DISABLE_VEHICLE_EXPLOSION_BREAK_OFF_PARTS();
	}

	void LUA_NATIVE_VEHICLE_SET_LIGHTS_CUTOFF_DISTANCE_TWEAK( float distance) { invoke<void )
	{
		VEHICLE::SET_LIGHTS_CUTOFF_DISTANCE_TWEAK(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_SHOOT_AT_TARGET( int driver, int entity, float xTarget, float yTarget, float zTarget) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_SHOOT_AT_TARGET(driver, entity, xTarget, yTarget, invoke<void);
	}

	std::tuple<bool, int entity) { return> LUA_NATIVE_VEHICLE_GET_VEHICLE_LOCK_ON_TARGET( int vehicle, int entity) { return invoke<BOOL )
	{
		std::tuple<bool, int entity) { return> return_values;
		std::get<0>(return_values) = (bool)VEHICLE::GET_VEHICLE_LOCK_ON_TARGET(vehicle, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_FORCE_HD_VEHICLE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_FORCE_HD_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CUSTOM_PATH_NODE_STREAMING_RADIUS( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CUSTOM_PATH_NODE_STREAMING_RADIUS(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_PLATE_TYPE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_PLATE_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_TRACK_VEHICLE_VISIBILITY( int vehicle) { invoke<void )
	{
		VEHICLE::TRACK_VEHICLE_VISIBILITY(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_VISIBLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_VISIBLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_GRAVITY( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_GRAVITY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ENABLE_VEHICLE_SLIPSTREAMING( bool toggle) { invoke<void )
	{
		VEHICLE::SET_ENABLE_VEHICLE_SLIPSTREAMING(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_SLIPSTREAMING_SHOULD_TIME_OUT( bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_SLIPSTREAMING_SHOULD_TIME_OUT(invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_CURRENT_TIME_IN_SLIP_STREAM( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_CURRENT_TIME_IN_SLIP_STREAM(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_PRODUCING_SLIP_STREAM( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_PRODUCING_SLIP_STREAM(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_INACTIVE_DURING_PLAYBACK( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_INACTIVE_DURING_PLAYBACK(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ACTIVE_DURING_PLAYBACK( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ACTIVE_DURING_PLAYBACK(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_SPRAYABLE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_SPRAYABLE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ENGINE_CAN_DEGRADE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ENGINE_CAN_DEGRADE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DISABLE_VEHCILE_DYNAMIC_AMBIENT_SCALES( int vehicle, int p1, int p2) { invoke<void )
	{
		VEHICLE::DISABLE_VEHCILE_DYNAMIC_AMBIENT_SCALES(vehicle, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ENABLE_VEHICLE_DYNAMIC_AMBIENT_SCALES( int vehicle) { invoke<void )
	{
		VEHICLE::ENABLE_VEHICLE_DYNAMIC_AMBIENT_SCALES(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_PLANE_LANDING_GEAR_INTACT( int plane) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_PLANE_LANDING_GEAR_INTACT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_ARE_PLANE_PROPELLERS_INTACT( int plane) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_PLANE_PROPELLERS_INTACT(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_SET_PLANE_PROPELLER_HEALTH( int plane, float health) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_PLANE_PROPELLER_HEALTH(plane, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_DEFORM_WHEELS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_DEFORM_WHEELS(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_STOLEN( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_STOLEN(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IS_STOLEN( int vehicle, bool isStolen) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IS_STOLEN(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLANE_TURBULENCE_MULTIPLIER( int vehicle, float multiplier) { invoke<void )
	{
		VEHICLE::SET_PLANE_TURBULENCE_MULTIPLIER(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_ARE_WINGS_OF_PLANE_INTACT( int plane) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_WINGS_OF_PLANE_INTACT(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_ALLOW_AMBIENT_VEHICLES_TO_AVOID_ADVERSE_CONDITIONS( int vehicle) { invoke<void )
	{
		VEHICLE::ALLOW_AMBIENT_VEHICLES_TO_AVOID_ADVERSE_CONDITIONS(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DETACH_VEHICLE_FROM_CARGOBOB( int vehicle, int cargobob) { invoke<void )
	{
		VEHICLE::DETACH_VEHICLE_FROM_CARGOBOB(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DETACH_VEHICLE_FROM_ANY_CARGOBOB( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DETACH_VEHICLE_FROM_ANY_CARGOBOB(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_DETACH_ENTITY_FROM_CARGOBOB( int cargobob, int entity) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DETACH_ENTITY_FROM_CARGOBOB(cargobob, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_ATTACHED_TO_CARGOBOB( int cargobob, int vehicleAttached) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_ATTACHED_TO_CARGOBOB(cargobob, invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_ATTACHED_TO_CARGOBOB( int cargobob) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_ATTACHED_TO_CARGOBOB(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_ENTITY_ATTACHED_TO_CARGOBOB( Any p0) { return invoke<int )
	{
		auto retval = VEHICLE::GET_ENTITY_ATTACHED_TO_CARGOBOB(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_ATTACH_VEHICLE_TO_CARGOBOB( int vehicle, int cargobob, int p2, float x, float y, float z) { invoke<void )
	{
		VEHICLE::ATTACH_VEHICLE_TO_CARGOBOB(vehicle, cargobob, p2, x, y, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_ATTACH_ENTITY_TO_CARGOBOB( Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<void )
	{
		VEHICLE::ATTACH_ENTITY_TO_CARGOBOB(p0, p1, p2, p3, p4, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_FORCE_DONT_DETACH_VEHICLE( int cargobob, bool toggle) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_FORCE_DONT_DETACH_VEHICLE(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_EXCLUDE_FROM_PICKUP_ENTITY( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_EXCLUDE_FROM_PICKUP_ENTITY(p0, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_CAN_CARGOBOB_PICK_UP_ENTITY( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::CAN_CARGOBOB_PICK_UP_ENTITY(p0, invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_GET_ATTACHED_PICK_UP_HOOK_POSITION( int cargobob) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::GET_ATTACHED_PICK_UP_HOOK_POSITION(invoke<Vector3);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_DOES_CARGOBOB_HAVE_PICK_UP_ROPE( int cargobob) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_CARGOBOB_HAVE_PICK_UP_ROPE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_CREATE_PICK_UP_ROPE_FOR_CARGOBOB( int cargobob, int state) { invoke<void )
	{
		VEHICLE::CREATE_PICK_UP_ROPE_FOR_CARGOBOB(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REMOVE_PICK_UP_ROPE_FOR_CARGOBOB( int cargobob) { invoke<void )
	{
		VEHICLE::REMOVE_PICK_UP_ROPE_FOR_CARGOBOB(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PICKUP_ROPE_LENGTH_FOR_CARGOBOB( int cargobob, float length1, float length2, bool p3) { invoke<void )
	{
		VEHICLE::SET_PICKUP_ROPE_LENGTH_FOR_CARGOBOB(cargobob, length1, length2, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PICKUP_ROPE_LENGTH_WITHOUT_CREATING_ROPE_FOR_CARGOBOB( Any p0, Any p1, Any p2) { invoke<void )
	{
		VEHICLE::SET_PICKUP_ROPE_LENGTH_WITHOUT_CREATING_ROPE_FOR_CARGOBOB(p0, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_ROPE_DAMPING_MULTIPLIER( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_ROPE_DAMPING_MULTIPLIER(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_ROPE_TYPE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_ROPE_TYPE(p0, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_CARGOBOB_HAVE_PICKUP_MAGNET( int cargobob) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_CARGOBOB_HAVE_PICKUP_MAGNET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_ACTIVE( int cargobob, bool isActive) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_ACTIVE(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_STRENGTH( int cargobob, float strength) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_STRENGTH(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_FALLOFF( int cargobob, float p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_FALLOFF(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_REDUCED_STRENGTH( int cargobob, float p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_REDUCED_STRENGTH(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_REDUCED_FALLOFF( int cargobob, float p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_REDUCED_FALLOFF(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_PULL_STRENGTH( int cargobob, float p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_PULL_STRENGTH(cargobob, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_PULL_ROPE_LENGTH( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_PULL_ROPE_LENGTH(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_SET_TARGETED_MODE( int vehicle, int cargobob) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_SET_TARGETED_MODE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_SET_AMBIENT_MODE( int vehicle, bool p1, bool p2) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_SET_AMBIENT_MODE(vehicle, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_PICKUP_MAGNET_ENSURE_PICKUP_ENTITY_UPRIGHT( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_PICKUP_MAGNET_ENSURE_PICKUP_ENTITY_UPRIGHT(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_DOES_VEHICLE_HAVE_WEAPONS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::DOES_VEHICLE_HAVE_WEAPONS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WILL_TELL_OTHERS_TO_HURRY( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WILL_TELL_OTHERS_TO_HURRY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_DISABLE_VEHICLE_WEAPON( bool disabled, unsigned weaponHash, int vehicle, int owner) { invoke<void )
	{
		VEHICLE::DISABLE_VEHICLE_WEAPON(disabled, weaponHash, vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_WEAPON_DISABLED( unsigned weaponHash, int vehicle, int owner) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_WEAPON_DISABLED(weaponHash, vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USED_FOR_PILOT_SCHOOL( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USED_FOR_PILOT_SCHOOL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_ACTIVE_FOR_PED_NAVIGATION( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_ACTIVE_FOR_PED_NAVIGATION(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS(invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_CLASS_FROM_NAME( unsigned modelHash) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_CLASS_FROM_NAME(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_PLAYERS_LAST_VEHICLE( int vehicle) { invoke<void )
	{
		VEHICLE::SET_PLAYERS_LAST_VEHICLE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CAN_BE_USED_BY_FLEEING_PEDS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CAN_BE_USED_BY_FLEEING_PEDS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_AIRCRAFT_PILOT_SKILL_NOISE_SCALAR( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_AIRCRAFT_PILOT_SKILL_NOISE_SCALAR(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DROPS_MONEY_WHEN_BLOWN_UP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DROPS_MONEY_WHEN_BLOWN_UP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_KEEP_ENGINE_ON_WHEN_ABANDONED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_KEEP_ENGINE_ON_WHEN_ABANDONED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_IMPATIENCE_TIMER( int vehicle, Any p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_IMPATIENCE_TIMER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_HANDLING_OVERRIDE( int vehicle, unsigned hash) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_HANDLING_OVERRIDE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXTENDED_REMOVAL_RANGE( int vehicle, int range) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXTENDED_REMOVAL_RANGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_STEERING_BIAS_SCALAR( Any p0, float p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_STEERING_BIAS_SCALAR(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_CONTROL_LAGGING_RATE_SCALAR( int helicopter, float multiplier) { invoke<void )
	{
		VEHICLE::SET_HELI_CONTROL_LAGGING_RATE_SCALAR(helicopter, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FRICTION_OVERRIDE( int vehicle, float friction) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FRICTION_OVERRIDE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WHEELS_CAN_BREAK_OFF_WHEN_BLOW_UP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WHEELS_CAN_BREAK_OFF_WHEN_BLOW_UP(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_ARE_PLANE_CONTROL_PANELS_INTACT( int vehicle, bool p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_PLANE_CONTROL_PANELS_INTACT(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_CEILING_HEIGHT( int vehicle, float height) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_CEILING_HEIGHT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NO_EXPLOSION_DAMAGE_FROM_DRIVER( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NO_EXPLOSION_DAMAGE_FROM_DRIVER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_ROUTE_HISTORY( int vehicle) { invoke<void )
	{
		VEHICLE::CLEAR_VEHICLE_ROUTE_HISTORY(invoke<void);
	}

	int LUA_NATIVE_VEHICLE_DOES_VEHICLE_EXIST_WITH_DECORATOR( const char* decorator) { return invoke<int )
	{
		auto retval = VEHICLE::DOES_VEHICLE_EXIST_WITH_DECORATOR(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_AI_CAN_USE_EXCLUSIVE_SEATS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_AI_CAN_USE_EXCLUSIVE_SEATS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_EXCLUSIVE_DRIVER( int vehicle, int ped, int index) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_EXCLUSIVE_DRIVER(vehicle, ped, invoke<void);
	}

	std::tuple<bool, int outIndex) { return> LUA_NATIVE_VEHICLE_IS_PED_EXCLUSIVE_DRIVER_OF_VEHICLE( int ped, int vehicle, int outIndex) { return invoke<BOOL )
	{
		std::tuple<bool, int outIndex) { return> return_values;
		std::get<0>(return_values) = (bool)VEHICLE::IS_PED_EXCLUSIVE_DRIVER_OF_VEHICLE(ped, vehicle, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_DISABLE_INDIVIDUAL_PLANE_PROPELLER( int vehicle, int propeller) { invoke<void )
	{
		VEHICLE::DISABLE_INDIVIDUAL_PLANE_PROPELLER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_FORCE_AFTERBURNER( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_FORCE_AFTERBURNER(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DONT_PROCESS_VEHICLE_GLASS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DONT_PROCESS_VEHICLE_GLASS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_WANTED_CONES_RESPONSE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_WANTED_CONES_RESPONSE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_USE_DESIRED_Z_CRUISE_SPEED_FOR_LANDING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_USE_DESIRED_Z_CRUISE_SPEED_FOR_LANDING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ARRIVE_DISTANCE_OVERRIDE_FOR_VEHICLE_PERSUIT_ATTACK( int vehicle, float p1) { invoke<void )
	{
		VEHICLE::SET_ARRIVE_DISTANCE_OVERRIDE_FOR_VEHICLE_PERSUIT_ATTACK(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_READY_FOR_CLEANUP( Any p0) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_READY_FOR_CLEANUP(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISTANT_CARS_ENABLED( bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISTANT_CARS_ENABLED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NEON_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NEON_COLOUR(vehicle, r, g, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NEON_INDEX_COLOUR( int vehicle, int index) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NEON_INDEX_COLOUR(vehicle, invoke<void);
	}

	std::tuple<int, int, int b) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_NEON_COLOUR( int vehicle, int r, int g, int b) { invoke<void )
	{
		std::tuple<int, int, int b) {> return_values;
		VEHICLE::GET_VEHICLE_NEON_COLOUR(vehicle, &r, &g, &invoke<void);
		std::get<0>(return_values) = r;
		std::get<1>(return_values) = g;
		std::get<2>(return_values) = invoke<void;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_NEON_ENABLED( int vehicle, int index, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_NEON_ENABLED(vehicle, index, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_NEON_ENABLED( int vehicle, int index) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_NEON_ENABLED(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_AMBIENT_VEHICLE_NEON_ENABLED( bool p0) { invoke<void )
	{
		VEHICLE::SET_AMBIENT_VEHICLE_NEON_ENABLED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SUPPRESS_NEONS_ON_VEHICLE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SUPPRESS_NEONS_ON_VEHICLE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_SUPERDUMMY( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_DISABLE_SUPERDUMMY(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_REQUEST_VEHICLE_DIAL( int vehicle) { invoke<void )
	{
		VEHICLE::REQUEST_VEHICLE_DIAL(invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_BODY_HEALTH( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_BODY_HEALTH(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BODY_HEALTH( int vehicle, float value) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BODY_HEALTH(vehicle, invoke<void);
	}

	std::tuple<Vector3, Vector3 out2) {> LUA_NATIVE_VEHICLE_GET_VEHICLE_SIZE( int vehicle, Vector3 out1, Vector3 out2) { invoke<void )
	{
		std::tuple<Vector3, Vector3 out2) {> return_values;
		VEHICLE::GET_VEHICLE_SIZE(vehicle, &out1, &invoke<void);
		std::get<0>(return_values) = out1;
		std::get<1>(return_values) = invoke<void;

		return return_values;
	}

	float LUA_NATIVE_VEHICLE_GET_FAKE_SUSPENSION_LOWERING_AMOUNT( int vehicle) { return invoke<float )
	{
		auto retval = VEHICLE::GET_FAKE_SUSPENSION_LOWERING_AMOUNT(invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_CAR_HIGH_SPEED_BUMP_SEVERITY_MULTIPLIER( float multiplier) { invoke<void )
	{
		VEHICLE::SET_CAR_HIGH_SPEED_BUMP_SEVERITY_MULTIPLIER(invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_NUMBER_OF_VEHICLE_DOORS( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_NUMBER_OF_VEHICLE_DOORS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_HYDRAULICS_CONTROL( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_HYDRAULICS_CONTROL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CAN_ADJUST_GROUND_CLEARANCE( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_CAN_ADJUST_GROUND_CLEARANCE(vehicle, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_VEHICLE_HEALTH_PERCENTAGE( int vehicle, float maxEngineHealth, float maxPetrolTankHealth, float maxBodyHealth, float maxMainRotorHealth, float maxTailRotorHealth, float maxUnkHealth) { return invoke<float )
	{
		auto retval = VEHICLE::GET_VEHICLE_HEALTH_PERCENTAGE(vehicle, maxEngineHealth, maxPetrolTankHealth, maxBodyHealth, maxMainRotorHealth, maxTailRotorHealth, invoke<float);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_IS_MERCENARY( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_IS_MERCENARY(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BROKEN_PARTS_DONT_AFFECT_AI_HANDLING( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BROKEN_PARTS_DONT_AFFECT_AI_HANDLING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_KERS_ALLOWED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_KERS_ALLOWED(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_HAS_KERS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_HAS_KERS(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_PLANE_RESIST_TO_EXPLOSION( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_PLANE_RESIST_TO_EXPLOSION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_RESIST_TO_EXPLOSION( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_HELI_RESIST_TO_EXPLOSION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_BMX_EXTRA_TRICK_FORCES( Any p0) { invoke<void )
	{
		VEHICLE::SET_DISABLE_BMX_EXTRA_TRICK_FORCES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HYDRAULIC_SUSPENSION_RAISE_FACTOR( int vehicle, int wheelId, float value) { invoke<void )
	{
		VEHICLE::SET_HYDRAULIC_SUSPENSION_RAISE_FACTOR(vehicle, wheelId, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_HYDRAULIC_SUSPENSION_RAISE_FACTOR( int vehicle, int wheelId) { return invoke<float )
	{
		auto retval = VEHICLE::GET_HYDRAULIC_SUSPENSION_RAISE_FACTOR(vehicle, invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_CAN_USE_HYDRAULICS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_CAN_USE_HYDRAULICS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HYDRAULIC_VEHICLE_STATE( int vehicle, int state) { invoke<void )
	{
		VEHICLE::SET_HYDRAULIC_VEHICLE_STATE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HYDRAULIC_WHEEL_STATE( int vehicle, int wheelId, int state, float value, Any p4) { invoke<void )
	{
		VEHICLE::SET_HYDRAULIC_WHEEL_STATE(vehicle, wheelId, state, value, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_HAS_VEHICLE_PETROLTANK_SET_ON_FIRE_BY_ENTITY( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::HAS_VEHICLE_PETROLTANK_SET_ON_FIRE_BY_ENTITY(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_CLEAR_VEHICLE_PETROLTANK_FIRE_CULPRIT( int vehicle) { invoke<void )
	{
		VEHICLE::CLEAR_VEHICLE_PETROLTANK_FIRE_CULPRIT(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BOBBLEHEAD_VELOCITY( float x, float y, float p2) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BOBBLEHEAD_VELOCITY(x, y, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_IS_DUMMY( Any p0) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_IS_DUMMY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_SET_VEHICLE_DAMAGE_SCALE( int vehicle, float p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_VEHICLE_DAMAGE_SCALE(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_SET_VEHICLE_WEAPON_DAMAGE_SCALE( int vehicle, float multiplier) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_VEHICLE_WEAPON_DAMAGE_SCALE(vehicle, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_SET_DISABLE_DAMAGE_WITH_PICKED_UP_ENTITY( Any p0, Any p1) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::SET_DISABLE_DAMAGE_WITH_PICKED_UP_ENTITY(p0, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USES_MP_PLAYER_DAMAGE_MULTIPLIER( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USES_MP_PLAYER_DAMAGE_MULTIPLIER(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_BIKE_EASY_TO_LAND( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_BIKE_EASY_TO_LAND(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_INVERT_VEHICLE_CONTROLS( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_INVERT_VEHICLE_CONTROLS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SPEED_BOOST_EFFECT_DISABLED( bool disabled) { invoke<void )
	{
		VEHICLE::SET_SPEED_BOOST_EFFECT_DISABLED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SLOW_DOWN_EFFECT_DISABLED( bool disabled) { invoke<void )
	{
		VEHICLE::SET_SLOW_DOWN_EFFECT_DISABLED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FORMATION_LEADER( int vehicle, float x, float y, float z, float p4) { invoke<void )
	{
		VEHICLE::SET_FORMATION_LEADER(vehicle, x, y, z, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_RESET_FORMATION_LEADER(  )
	{
		VEHICLE::RESET_FORMATION_LEADER();
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_BOAT_CAPSIZED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_BOAT_CAPSIZED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_ALLOW_RAMMING_SOOP_OR_RAMP( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_ALLOW_RAMMING_SOOP_OR_RAMP(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SCRIPT_RAMP_IMPULSE_SCALE( int vehicle, float impulseScale) { invoke<void )
	{
		VEHICLE::SET_SCRIPT_RAMP_IMPULSE_SCALE(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_DOOR_VALID( int vehicle, int doorId) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_DOOR_VALID(vehicle, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_SCRIPT_ROCKET_BOOST_RECHARGE_TIME( int vehicle, float seconds) { invoke<void )
	{
		VEHICLE::SET_SCRIPT_ROCKET_BOOST_RECHARGE_TIME(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_HAS_ROCKET_BOOST( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_HAS_ROCKET_BOOST(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_IS_ROCKET_BOOST_ACTIVE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_ROCKET_BOOST_ACTIVE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_ROCKET_BOOST_ACTIVE( int vehicle, bool active) { invoke<void )
	{
		VEHICLE::SET_ROCKET_BOOST_ACTIVE(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_HAS_RETRACTABLE_WHEELS( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_HAS_RETRACTABLE_WHEELS(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_WHEELS_RETRACTED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_WHEELS_RETRACTED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_WHEELS_EXTENDED_INSTANTLY( int vehicle) { invoke<void )
	{
		VEHICLE::SET_WHEELS_EXTENDED_INSTANTLY(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_WHEELS_RETRACTED_INSTANTLY( int vehicle) { invoke<void )
	{
		VEHICLE::SET_WHEELS_RETRACTED_INSTANTLY(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_CAR_HAS_JUMP( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_CAR_HAS_JUMP(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_USE_HIGHER_CAR_JUMP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_USE_HIGHER_CAR_JUMP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CLEAR_FREEZE_WAITING_ON_COLLISION_ONCE_PLAYER_ENTERS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_CLEAR_FREEZE_WAITING_ON_COLLISION_ONCE_PLAYER_ENTERS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WEAPON_RESTRICTED_AMMO( int vehicle, int weaponIndex, int capacity) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WEAPON_RESTRICTED_AMMO(vehicle, weaponIndex, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_WEAPON_RESTRICTED_AMMO( int vehicle, int weaponIndex) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_WEAPON_RESTRICTED_AMMO(vehicle, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_HAS_PARACHUTE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_HAS_PARACHUTE(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_VEHICLE_CAN_DEPLOY_PARACHUTE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_VEHICLE_CAN_DEPLOY_PARACHUTE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_START_PARACHUTING( int vehicle, bool active) { invoke<void )
	{
		VEHICLE::VEHICLE_START_PARACHUTING(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_IS_VEHICLE_PARACHUTE_DEPLOYED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::IS_VEHICLE_PARACHUTE_DEPLOYED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_RAMP_AND_RAMMING_CARS_TAKE_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_RAMP_AND_RAMMING_CARS_TAKE_DAMAGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_ENABLE_RAMP_CAR_SIDE_IMPULSE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_ENABLE_RAMP_CAR_SIDE_IMPULSE(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_ENABLE_NORMALISE_RAMP_CAR_VERTICAL_VELOCTIY( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_ENABLE_NORMALISE_RAMP_CAR_VERTICAL_VELOCTIY(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_JET_WASH_FORCE_ENABLED( Any p0) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_JET_WASH_FORCE_ENABLED(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_WEAPON_CAN_TARGET_OBJECTS( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_WEAPON_CAN_TARGET_OBJECTS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_USE_BOOST_BUTTON_FOR_WHEEL_RETRACT( bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_USE_BOOST_BUTTON_FOR_WHEEL_RETRACT(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_PARACHUTE_MODEL_OVERRIDE( int vehicle, unsigned modelHash) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_PARACHUTE_MODEL_OVERRIDE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_VEHICLE_SET_PARACHUTE_MODEL_TINT_INDEX( int vehicle, int textureVariation) { invoke<void )
	{
		VEHICLE::VEHICLE_SET_PARACHUTE_MODEL_TINT_INDEX(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_VEHICLE_SET_OVERRIDE_EXTENABLE_SIDE_RATIO( Any p0, Any p1) { return invoke<int )
	{
		auto retval = VEHICLE::VEHICLE_SET_OVERRIDE_EXTENABLE_SIDE_RATIO(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_VEHICLE_SET_EXTENABLE_SIDE_TARGET_RATIO( Any p0, Any p1) { return invoke<int )
	{
		auto retval = VEHICLE::VEHICLE_SET_EXTENABLE_SIDE_TARGET_RATIO(p0, invoke<int);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_VEHICLE_SET_OVERRIDE_SIDE_RATIO( Any p0, Any p1) { return invoke<int )
	{
		auto retval = VEHICLE::VEHICLE_SET_OVERRIDE_SIDE_RATIO(p0, invoke<int);
		return retval;
	}

	std::tuple<int, Any vehsStruct) { return> LUA_NATIVE_VEHICLE_GET_ALL_VEHICLES( Any vehsStruct) { return invoke<int )
	{
		std::tuple<int, Any vehsStruct) { return> return_values;
		std::get<0>(return_values) = VEHICLE::GET_ALL_VEHICLES(&invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_VEHICLE_SET_CARGOBOB_EXTA_PICKUP_RANGE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_CARGOBOB_EXTA_PICKUP_RANGE(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_OVERRIDE_VEHICLE_DOOR_TORQUE( Any p0, Any p1, Any p2) { invoke<void )
	{
		VEHICLE::SET_OVERRIDE_VEHICLE_DOOR_TORQUE(p0, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_WHEELIE_ENABLED( int vehicle, bool enabled) { invoke<void )
	{
		VEHICLE::SET_WHEELIE_ENABLED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_HELI_EXPLODE_FROM_BODY_DAMAGE( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_DISABLE_HELI_EXPLODE_FROM_BODY_DAMAGE(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_EXPLODE_FROM_BODY_DAMAGE_ON_COLLISION( int vehicle, float value) { invoke<void )
	{
		VEHICLE::SET_DISABLE_EXPLODE_FROM_BODY_DAMAGE_ON_COLLISION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRAILER_ATTACHMENT_ENABLED( Any p0, Any p1) { invoke<void )
	{
		VEHICLE::SET_TRAILER_ATTACHMENT_ENABLED(p0, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_ROCKET_BOOST_FILL( int vehicle, float percentage) { invoke<void )
	{
		VEHICLE::SET_ROCKET_BOOST_FILL(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_GLIDER_ACTIVE( int vehicle, bool state) { invoke<void )
	{
		VEHICLE::SET_GLIDER_ACTIVE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SHOULD_RESET_TURRET_IN_SCRIPTED_CAMERAS( int vehicle, bool shouldReset) { invoke<void )
	{
		VEHICLE::SET_SHOULD_RESET_TURRET_IN_SCRIPTED_CAMERAS(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DISABLE_COLLISION_UPON_CREATION( int vehicle, bool disable) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DISABLE_COLLISION_UPON_CREATION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_GROUND_EFFECT_REDUCES_DRAG( bool toggle) { invoke<void )
	{
		VEHICLE::SET_GROUND_EFFECT_REDUCES_DRAG(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_MAP_COLLISION( int vehicle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_MAP_COLLISION(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_PED_STAND_ON_TOP( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_PED_STAND_ON_TOP(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DAMAGE_SCALES( int vehicle, Any p1, Any p2, Any p3, Any p4) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DAMAGE_SCALES(vehicle, p1, p2, p3, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_PLANE_SECTION_DAMAGE_SCALE( int vehicle, Any p1, Any p2) { invoke<void )
	{
		VEHICLE::SET_PLANE_SECTION_DAMAGE_SCALE(vehicle, p1, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_CAN_PICKUP_ENTITY_THAT_HAS_PICK_UP_DISABLED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_HELI_CAN_PICKUP_ENTITY_THAT_HAS_PICK_UP_DISABLED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_BOMB_AMMO( int vehicle, int bombCount) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_BOMB_AMMO(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_BOMB_AMMO( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_BOMB_AMMO(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_COUNTERMEASURE_AMMO( int vehicle, int counterMeasureCount) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_COUNTERMEASURE_AMMO(vehicle, invoke<void);
	}

	int LUA_NATIVE_VEHICLE_GET_VEHICLE_COUNTERMEASURE_AMMO( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_VEHICLE_COUNTERMEASURE_AMMO(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_HELI_COMBAT_OFFSET( int vehicle, float x, float y, float z) { invoke<void )
	{
		VEHICLE::SET_HELI_COMBAT_OFFSET(vehicle, x, y, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_CAN_VEHICLE_BE_PLACED_HERE( int vehicle, float x, float y, float z, float rotX, float rotY, float rotZ, int p7, Any p8) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_CAN_VEHICLE_BE_PLACED_HERE(vehicle, x, y, z, rotX, rotY, rotZ, p7, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_AUTOMATIC_CRASH_TASK( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_AUTOMATIC_CRASH_TASK(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SPECIAL_FLIGHT_MODE_RATIO( int vehicle, float ratio) { invoke<void )
	{
		VEHICLE::SET_SPECIAL_FLIGHT_MODE_RATIO(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO( int vehicle, float targetRatio) { invoke<void )
	{
		VEHICLE::SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_SPECIAL_FLIGHT_MODE_ALLOWED( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_SPECIAL_FLIGHT_MODE_ALLOWED(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_HOVER_MODE_FLIGHT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_HOVER_MODE_FLIGHT(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_OUTRIGGERS_DEPLOYED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_OUTRIGGERS_DEPLOYED(invoke<BOOL);
		return retval;
	}

	Vector3 LUA_NATIVE_VEHICLE_FIND_SPAWN_COORDINATES_FOR_HELI( int ped) { return invoke<Vector3 )
	{
		auto retval = VEHICLE::FIND_SPAWN_COORDINATES_FOR_HELI(invoke<Vector3);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DEPLOY_FOLDING_WINGS( int vehicle, bool deploy, bool p2) { invoke<void )
	{
		VEHICLE::SET_DEPLOY_FOLDING_WINGS(vehicle, deploy, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_ARE_FOLDING_WINGS_DEPLOYED( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_FOLDING_WINGS_DEPLOYED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DEPLOY_MISSILE_BAYS_( int vehicle, bool deploy) { invoke<void )
	{
		VEHICLE::SET_DEPLOY_MISSILE_BAYS_(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_ARE_MISSILE_BAYS_DEPLOYED_( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::ARE_MISSILE_BAYS_DEPLOYED_(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DIP_STRAIGHT_DOWN_WHEN_CRASHING_PLANE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DIP_STRAIGHT_DOWN_WHEN_CRASHING_PLANE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TURRET_HIDDEN( int vehicle, int index, bool toggle) { invoke<void )
	{
		VEHICLE::SET_TURRET_HIDDEN(vehicle, index, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_HOVER_MODE_WING_RATIO( int vehicle, float ratio) { invoke<void )
	{
		VEHICLE::SET_HOVER_MODE_WING_RATIO(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_TURRET_MOVEMENT( int vehicle, int turretId) { invoke<void )
	{
		VEHICLE::SET_DISABLE_TURRET_MOVEMENT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_FORCE_FIX_LINK_MATRICES( int vehicle) { invoke<void )
	{
		VEHICLE::SET_FORCE_FIX_LINK_MATRICES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRANSFORM_RATE_FOR_ANIMATION( int vehicle, float transformRate) { invoke<void )
	{
		VEHICLE::SET_TRANSFORM_RATE_FOR_ANIMATION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TRANSFORM_TO_SUBMARINE_USES_ALTERNATE_INPUT( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_TRANSFORM_TO_SUBMARINE_USES_ALTERNATE_INPUT(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_COMBAT_MODE( bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_COMBAT_MODE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_DETONATION_MODE( bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_DETONATION_MODE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_VEHICLE_SHUNT_ON_STICK( bool toggle) { invoke<void )
	{
		VEHICLE::SET_VEHICLE_SHUNT_ON_STICK(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_VEHICLE_SHUNTING( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_VEHICLE_SHUNTING(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_VEHICLE_GET_HAS_VEHICLE_BEEN_HIT_BY_SHUNT( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_HAS_VEHICLE_BEEN_HIT_BY_SHUNT(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_VEHICLE_GET_LAST_SHUNT_VEHICLE( int vehicle) { return invoke<int )
	{
		auto retval = VEHICLE::GET_LAST_SHUNT_VEHICLE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_VEHICLE_EXPLOSIONS_DAMAGE( bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_VEHICLE_EXPLOSIONS_DAMAGE(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_OVERRIDE_NITROUS_LEVEL( int vehicle, bool toggle, float level, float power, float rechargeTime, bool disableSound) { invoke<void )
	{
		VEHICLE::SET_OVERRIDE_NITROUS_LEVEL(vehicle, toggle, level, power, rechargeTime, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_INCREASE_WHEEL_CRUSH_DAMAGE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_INCREASE_WHEEL_CRUSH_DAMAGE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_WEAPON_BLADE_FORCES( bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_WEAPON_BLADE_FORCES(invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_USE_DOUBLE_CLICK_FOR_CAR_JUMP( bool toggle) { invoke<void )
	{
		VEHICLE::SET_USE_DOUBLE_CLICK_FOR_CAR_JUMP(invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_DOES_VEHICLE_HAVE_TOMBSTONE( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_DOES_VEHICLE_HAVE_TOMBSTONE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_HIDE_TOMBSTONE( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::HIDE_TOMBSTONE(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_IS_VEHICLE_DISABLED_BY_EMP( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_IS_VEHICLE_DISABLED_BY_EMP(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_DISABLE_RETRACTING_WEAPON_BLADES( bool toggle) { invoke<void )
	{
		VEHICLE::SET_DISABLE_RETRACTING_WEAPON_BLADES(invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_TYRE_HEALTH( int vehicle, int wheelIndex) { return invoke<float )
	{
		auto retval = VEHICLE::GET_TYRE_HEALTH(vehicle, invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_TYRE_HEALTH( int vehicle, int wheelIndex, float health) { invoke<void )
	{
		VEHICLE::SET_TYRE_HEALTH(vehicle, wheelIndex, invoke<void);
	}

	float LUA_NATIVE_VEHICLE_GET_TYRE_WEAR_RATE( int vehicle, int wheelIndex) { return invoke<float )
	{
		auto retval = VEHICLE::GET_TYRE_WEAR_RATE(vehicle, invoke<float);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_SET_TYRE_WEAR_RATE( int vehicle, int wheelIndex, float multiplier) { invoke<void )
	{
		VEHICLE::SET_TYRE_WEAR_RATE(vehicle, wheelIndex, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TYRE_WEAR_RATE_SCALE( int vehicle, int wheelIndex, float multiplier) { invoke<void )
	{
		VEHICLE::SET_TYRE_WEAR_RATE_SCALE(vehicle, wheelIndex, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_TYRE_MAXIMUM_GRIP_DIFFERENCE_DUE_TO_WEAR_RATE( int vehicle, int wheelIndex, float multiplier) { invoke<void )
	{
		VEHICLE::SET_TYRE_MAXIMUM_GRIP_DIFFERENCE_DUE_TO_WEAR_RATE(vehicle, wheelIndex, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_AIRCRAFT_IGNORE_HIGHTMAP_OPTIMISATION( int vehicle, int p1) { invoke<void )
	{
		VEHICLE::SET_AIRCRAFT_IGNORE_HIGHTMAP_OPTIMISATION(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_REDUCED_SUSPENSION_FORCE( int vehicle, bool enable) { invoke<void )
	{
		VEHICLE::SET_REDUCED_SUSPENSION_FORCE(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_DRIFT_TYRES( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::SET_DRIFT_TYRES(vehicle, invoke<void);
	}

	bool LUA_NATIVE_VEHICLE_GET_DRIFT_TYRES_SET( int vehicle) { return invoke<BOOL )
	{
		auto retval = (bool)VEHICLE::GET_DRIFT_TYRES_SET(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_VEHICLE_NETWORK_USE_HIGH_PRECISION_TRAIN_BLENDING( int vehicle, bool toggle) { invoke<void )
	{
		VEHICLE::NETWORK_USE_HIGH_PRECISION_TRAIN_BLENDING(vehicle, invoke<void);
	}

	void LUA_NATIVE_VEHICLE_SET_CHECK_FOR_ENOUGH_ROOM_FOR_PED( int vehicle, bool p1) { invoke<void )
	{
		VEHICLE::SET_CHECK_FOR_ENOUGH_ROOM_FOR_PED(vehicle, invoke<void);
	}

	std::tuple<bool, float height) { return> LUA_NATIVE_WATER_GET_WATER_HEIGHT( float x, float y, float z, float height) { return invoke<BOOL )
	{
		std::tuple<bool, float height) { return> return_values;
		std::get<0>(return_values) = (bool)WATER::GET_WATER_HEIGHT(x, y, z, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, float height) { return> LUA_NATIVE_WATER_GET_WATER_HEIGHT_NO_WAVES( float x, float y, float z, float height) { return invoke<BOOL )
	{
		std::tuple<bool, float height) { return> return_values;
		std::get<0>(return_values) = (bool)WATER::GET_WATER_HEIGHT_NO_WAVES(x, y, z, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Vector3 result) { return> LUA_NATIVE_WATER_TEST_PROBE_AGAINST_WATER( float x1, float y1, float z1, float x2, float y2, float z2, Vector3 result) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 result) { return> return_values;
		std::get<0>(return_values) = (bool)WATER::TEST_PROBE_AGAINST_WATER(x1, y1, z1, x2, y2, z2, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<int, float waterHeight) { return> LUA_NATIVE_WATER_TEST_PROBE_AGAINST_ALL_WATER( float x1, float y1, float z1, float x2, float y2, float z2, int flags, float waterHeight) { return invoke<int )
	{
		std::tuple<int, float waterHeight) { return> return_values;
		std::get<0>(return_values) = WATER::TEST_PROBE_AGAINST_ALL_WATER(x1, y1, z1, x2, y2, z2, flags, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	std::tuple<int, float waterHeight) { return> LUA_NATIVE_WATER_TEST_VERTICAL_PROBE_AGAINST_ALL_WATER( float x, float y, float z, int flags, float waterHeight) { return invoke<int )
	{
		std::tuple<int, float waterHeight) { return> return_values;
		std::get<0>(return_values) = WATER::TEST_VERTICAL_PROBE_AGAINST_ALL_WATER(x, y, z, flags, &invoke<int);
		std::get<1>(return_values) = invoke<int;

		return return_values;
	}

	void LUA_NATIVE_WATER_MODIFY_WATER( float x, float y, float radius, float height) { invoke<void )
	{
		WATER::MODIFY_WATER(x, y, radius, invoke<void);
	}

	int LUA_NATIVE_WATER_ADD_EXTRA_CALMING_QUAD( float xLow, float yLow, float xHigh, float yHigh, float height) { return invoke<int )
	{
		auto retval = WATER::ADD_EXTRA_CALMING_QUAD(xLow, yLow, xHigh, yHigh, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WATER_REMOVE_EXTRA_CALMING_QUAD( int calmingQuad) { invoke<void )
	{
		WATER::REMOVE_EXTRA_CALMING_QUAD(invoke<void);
	}

	void LUA_NATIVE_WATER_SET_DEEP_OCEAN_SCALER( float intensity) { invoke<void )
	{
		WATER::SET_DEEP_OCEAN_SCALER(invoke<void);
	}

	float LUA_NATIVE_WATER_GET_DEEP_OCEAN_SCALER(  )
	{
		auto retval = WATER::GET_DEEP_OCEAN_SCALER();
		return retval;
	}

	void LUA_NATIVE_WATER_SET_CALMED_WAVE_HEIGHT_SCALER( float height) { invoke<void )
	{
		WATER::SET_CALMED_WAVE_HEIGHT_SCALER(invoke<void);
	}

	void LUA_NATIVE_WATER_RESET_DEEP_OCEAN_SCALER(  )
	{
		WATER::RESET_DEEP_OCEAN_SCALER();
	}

	void LUA_NATIVE_WEAPON_ENABLE_LASER_SIGHT_RENDERING( bool toggle) { invoke<void )
	{
		WEAPON::ENABLE_LASER_SIGHT_RENDERING(invoke<void);
	}

	unsigned LUA_NATIVE_WEAPON_GET_WEAPON_COMPONENT_TYPE_MODEL( unsigned componentHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_WEAPON_COMPONENT_TYPE_MODEL(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_WEAPONTYPE_MODEL( unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_WEAPONTYPE_MODEL(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_WEAPONTYPE_SLOT( unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_WEAPONTYPE_SLOT(invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_WEAPONTYPE_GROUP( unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_WEAPONTYPE_GROUP(invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_COMPONENT_VARIANT_EXTRA_COUNT( unsigned componentHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_COMPONENT_VARIANT_EXTRA_COUNT(invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_WEAPON_COMPONENT_VARIANT_EXTRA_MODEL( unsigned componentHash, int extraComponentIndex) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_WEAPON_COMPONENT_VARIANT_EXTRA_MODEL(componentHash, invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_CURRENT_PED_WEAPON( int ped, unsigned weaponHash, bool bForceInHand) { invoke<void )
	{
		WEAPON::SET_CURRENT_PED_WEAPON(ped, weaponHash, invoke<void);
	}

	std::tuple<bool, unsigned> LUA_NATIVE_WEAPON_GET_CURRENT_PED_WEAPON( int ped, unsigned weaponHash, bool p2) { return invoke<BOOL )
	{
		std::tuple<bool, unsigned> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_CURRENT_PED_WEAPON(ped, &weaponHash, invoke<BOOL);
		std::get<1>(return_values) = weaponHash;

		return return_values;
	}

	int LUA_NATIVE_WEAPON_GET_CURRENT_PED_WEAPON_ENTITY_INDEX( int ped, Any p1) { return invoke<int )
	{
		auto retval = WEAPON::GET_CURRENT_PED_WEAPON_ENTITY_INDEX(ped, invoke<int);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_BEST_PED_WEAPON( int ped, bool p1) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_BEST_PED_WEAPON(ped, invoke<unsigned);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_SET_CURRENT_PED_VEHICLE_WEAPON( int ped, unsigned weaponHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::SET_CURRENT_PED_VEHICLE_WEAPON(ped, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, unsigned weaponHash) { return> LUA_NATIVE_WEAPON_GET_CURRENT_PED_VEHICLE_WEAPON( int ped, unsigned weaponHash) { return invoke<BOOL )
	{
		std::tuple<bool, unsigned weaponHash) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_CURRENT_PED_VEHICLE_WEAPON(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_WEAPON_SET_PED_CYCLE_VEHICLE_WEAPONS_ONLY( int ped) { invoke<void )
	{
		WEAPON::SET_PED_CYCLE_VEHICLE_WEAPONS_ONLY(invoke<void);
	}

	bool LUA_NATIVE_WEAPON_IS_PED_ARMED( int ped, int typeFlags) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_PED_ARMED(ped, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_IS_WEAPON_VALID( unsigned weaponHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_WEAPON_VALID(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_HAS_PED_GOT_WEAPON( int ped, unsigned weaponHash, bool p2) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_PED_GOT_WEAPON(ped, weaponHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_IS_PED_WEAPON_READY_TO_SHOOT( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_PED_WEAPON_READY_TO_SHOOT(invoke<BOOL);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_PED_WEAPONTYPE_IN_SLOT( int ped, unsigned weaponSlot) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_PED_WEAPONTYPE_IN_SLOT(ped, invoke<unsigned);
		return retval;
	}

	int LUA_NATIVE_WEAPON_GET_AMMO_IN_PED_WEAPON( int ped, unsigned weaponhash) { return invoke<int )
	{
		auto retval = WEAPON::GET_AMMO_IN_PED_WEAPON(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_ADD_AMMO_TO_PED( int ped, unsigned weaponHash, int ammo) { invoke<void )
	{
		WEAPON::ADD_AMMO_TO_PED(ped, weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_AMMO( int ped, unsigned weaponHash, int ammo, bool p3) { invoke<void )
	{
		WEAPON::SET_PED_AMMO(ped, weaponHash, ammo, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_INFINITE_AMMO( int ped, bool toggle, unsigned weaponHash) { invoke<void )
	{
		WEAPON::SET_PED_INFINITE_AMMO(ped, toggle, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_INFINITE_AMMO_CLIP( int ped, bool toggle) { invoke<void )
	{
		WEAPON::SET_PED_INFINITE_AMMO_CLIP(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_STUN_GUN_FINITE_AMMO( Any p0, Any p1) { invoke<void )
	{
		WEAPON::SET_PED_STUN_GUN_FINITE_AMMO(p0, invoke<void);
	}

	void LUA_NATIVE_WEAPON_GIVE_WEAPON_TO_PED( int ped, unsigned weaponHash, int ammoCount, bool isHidden, bool bForceInHand) { invoke<void )
	{
		WEAPON::GIVE_WEAPON_TO_PED(ped, weaponHash, ammoCount, isHidden, invoke<void);
	}

	void LUA_NATIVE_WEAPON_GIVE_DELAYED_WEAPON_TO_PED( int ped, unsigned weaponHash, int ammoCount, bool bForceInHand) { invoke<void )
	{
		WEAPON::GIVE_DELAYED_WEAPON_TO_PED(ped, weaponHash, ammoCount, invoke<void);
	}

	void LUA_NATIVE_WEAPON_REMOVE_ALL_PED_WEAPONS( int ped, bool p1) { invoke<void )
	{
		WEAPON::REMOVE_ALL_PED_WEAPONS(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_REMOVE_WEAPON_FROM_PED( int ped, unsigned weaponHash) { invoke<void )
	{
		WEAPON::REMOVE_WEAPON_FROM_PED(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_HIDE_PED_WEAPON_FOR_SCRIPTED_CUTSCENE( int ped, bool toggle) { invoke<void )
	{
		WEAPON::HIDE_PED_WEAPON_FOR_SCRIPTED_CUTSCENE(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_CURRENT_WEAPON_VISIBLE( int ped, bool visible, bool deselectWeapon, bool p3, bool p4) { invoke<void )
	{
		WEAPON::SET_PED_CURRENT_WEAPON_VISIBLE(ped, visible, deselectWeapon, p3, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_DROPS_WEAPONS_WHEN_DEAD( int ped, bool toggle) { invoke<void )
	{
		WEAPON::SET_PED_DROPS_WEAPONS_WHEN_DEAD(ped, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_HAS_PED_BEEN_DAMAGED_BY_WEAPON( int ped, unsigned weaponHash, int weaponType) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_PED_BEEN_DAMAGED_BY_WEAPON(ped, weaponHash, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_CLEAR_PED_LAST_WEAPON_DAMAGE( int ped) { invoke<void )
	{
		WEAPON::CLEAR_PED_LAST_WEAPON_DAMAGE(invoke<void);
	}

	bool LUA_NATIVE_WEAPON_HAS_ENTITY_BEEN_DAMAGED_BY_WEAPON( int entity, unsigned weaponHash, int weaponType) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_ENTITY_BEEN_DAMAGED_BY_WEAPON(entity, weaponHash, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_CLEAR_ENTITY_LAST_WEAPON_DAMAGE( int entity) { invoke<void )
	{
		WEAPON::CLEAR_ENTITY_LAST_WEAPON_DAMAGE(invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_DROPS_WEAPON( int ped) { invoke<void )
	{
		WEAPON::SET_PED_DROPS_WEAPON(invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_DROPS_INVENTORY_WEAPON( int ped, unsigned weaponHash, float xOffset, float yOffset, float zOffset, int ammoCount) { invoke<void )
	{
		WEAPON::SET_PED_DROPS_INVENTORY_WEAPON(ped, weaponHash, xOffset, yOffset, zOffset, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_MAX_AMMO_IN_CLIP( int ped, unsigned weaponHash, bool p2) { return invoke<int )
	{
		auto retval = WEAPON::GET_MAX_AMMO_IN_CLIP(ped, weaponHash, invoke<int);
		return retval;
	}

	std::tuple<bool, int ammo) { return> LUA_NATIVE_WEAPON_GET_AMMO_IN_CLIP( int ped, unsigned weaponHash, int ammo) { return invoke<BOOL )
	{
		std::tuple<bool, int ammo) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_AMMO_IN_CLIP(ped, weaponHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	bool LUA_NATIVE_WEAPON_SET_AMMO_IN_CLIP( int ped, unsigned weaponHash, int ammo) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::SET_AMMO_IN_CLIP(ped, weaponHash, invoke<BOOL);
		return retval;
	}

	std::tuple<bool, int ammo) { return> LUA_NATIVE_WEAPON_GET_MAX_AMMO( int ped, unsigned weaponHash, int ammo) { return invoke<BOOL )
	{
		std::tuple<bool, int ammo) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_MAX_AMMO(ped, weaponHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, int ammo) { return> LUA_NATIVE_WEAPON_GET_MAX_AMMO_BY_TYPE( int ped, unsigned ammoTypeHash, int ammo) { return invoke<BOOL )
	{
		std::tuple<bool, int ammo) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_MAX_AMMO_BY_TYPE(ped, ammoTypeHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_WEAPON_ADD_PED_AMMO_BY_TYPE( int ped, unsigned ammoTypeHash, int ammo) { invoke<void )
	{
		WEAPON::ADD_PED_AMMO_BY_TYPE(ped, ammoTypeHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_AMMO_BY_TYPE( int ped, unsigned ammoTypeHash, int ammo) { invoke<void )
	{
		WEAPON::SET_PED_AMMO_BY_TYPE(ped, ammoTypeHash, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_PED_AMMO_BY_TYPE( int ped, unsigned ammoTypeHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_PED_AMMO_BY_TYPE(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_PED_AMMO_TO_DROP( int ped, int p1) { invoke<void )
	{
		WEAPON::SET_PED_AMMO_TO_DROP(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PICKUP_AMMO_AMOUNT_SCALER( float p0) { invoke<void )
	{
		WEAPON::SET_PICKUP_AMMO_AMOUNT_SCALER(invoke<void);
	}

	unsigned LUA_NATIVE_WEAPON_GET_PED_AMMO_TYPE_FROM_WEAPON( int ped, unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_PED_AMMO_TYPE_FROM_WEAPON(ped, invoke<unsigned);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_PED_ORIGINAL_AMMO_TYPE_FROM_WEAPON( int ped, unsigned weaponHash) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_PED_ORIGINAL_AMMO_TYPE_FROM_WEAPON(ped, invoke<unsigned);
		return retval;
	}

	std::tuple<bool, Vector3 coords) { return> LUA_NATIVE_WEAPON_GET_PED_LAST_WEAPON_IMPACT_COORD( int ped, Vector3 coords) { return invoke<BOOL )
	{
		std::tuple<bool, Vector3 coords) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_PED_LAST_WEAPON_IMPACT_COORD(ped, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_WEAPON_SET_PED_GADGET( int ped, unsigned gadgetHash, bool p2) { invoke<void )
	{
		WEAPON::SET_PED_GADGET(ped, gadgetHash, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_GET_IS_PED_GADGET_EQUIPPED( int ped, unsigned gadgetHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::GET_IS_PED_GADGET_EQUIPPED(ped, invoke<BOOL);
		return retval;
	}

	unsigned LUA_NATIVE_WEAPON_GET_SELECTED_PED_WEAPON( int ped) { return invoke<unsigned )
	{
		auto retval = WEAPON::GET_SELECTED_PED_WEAPON(invoke<unsigned);
		return retval;
	}

	void LUA_NATIVE_WEAPON_EXPLODE_PROJECTILES( int ped, unsigned weaponHash, bool p2) { invoke<void )
	{
		WEAPON::EXPLODE_PROJECTILES(ped, weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_REMOVE_ALL_PROJECTILES_OF_TYPE( unsigned weaponHash, bool explode) { invoke<void )
	{
		WEAPON::REMOVE_ALL_PROJECTILES_OF_TYPE(weaponHash, invoke<void);
	}

	float LUA_NATIVE_WEAPON_GET_LOCKON_DISTANCE_OF_CURRENT_PED_WEAPON( int ped) { return invoke<float )
	{
		auto retval = WEAPON::GET_LOCKON_DISTANCE_OF_CURRENT_PED_WEAPON(invoke<float);
		return retval;
	}

	float LUA_NATIVE_WEAPON_GET_MAX_RANGE_OF_CURRENT_PED_WEAPON( int ped) { return invoke<float )
	{
		auto retval = WEAPON::GET_MAX_RANGE_OF_CURRENT_PED_WEAPON(invoke<float);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_HAS_VEHICLE_GOT_PROJECTILE_ATTACHED( int driver, int vehicle, unsigned weaponHash, Any p3) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_VEHICLE_GOT_PROJECTILE_ATTACHED(driver, vehicle, weaponHash, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_GIVE_WEAPON_COMPONENT_TO_PED( int ped, unsigned weaponHash, unsigned componentHash) { invoke<void )
	{
		WEAPON::GIVE_WEAPON_COMPONENT_TO_PED(ped, weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_REMOVE_WEAPON_COMPONENT_FROM_PED( int ped, unsigned weaponHash, unsigned componentHash) { invoke<void )
	{
		WEAPON::REMOVE_WEAPON_COMPONENT_FROM_PED(ped, weaponHash, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_HAS_PED_GOT_WEAPON_COMPONENT( int ped, unsigned weaponHash, unsigned componentHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_PED_GOT_WEAPON_COMPONENT(ped, weaponHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_IS_PED_WEAPON_COMPONENT_ACTIVE( int ped, unsigned weaponHash, unsigned componentHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_PED_WEAPON_COMPONENT_ACTIVE(ped, weaponHash, invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_REFILL_AMMO_INSTANTLY( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::REFILL_AMMO_INSTANTLY(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_MAKE_PED_RELOAD( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::MAKE_PED_RELOAD(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_REQUEST_WEAPON_ASSET( unsigned weaponHash, int p1, int p2) { invoke<void )
	{
		WEAPON::REQUEST_WEAPON_ASSET(weaponHash, p1, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_HAS_WEAPON_ASSET_LOADED( unsigned weaponHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_WEAPON_ASSET_LOADED(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_REMOVE_WEAPON_ASSET( unsigned weaponHash) { invoke<void )
	{
		WEAPON::REMOVE_WEAPON_ASSET(invoke<void);
	}

	Object LUA_NATIVE_WEAPON_CREATE_WEAPON_OBJECT( unsigned weaponHash, int ammoCount, float x, float y, float z, bool showWorldModel, float scale, Any p7, Any p8, Any p9) { return invoke<Object )
	{
		auto retval = WEAPON::CREATE_WEAPON_OBJECT(weaponHash, ammoCount, x, y, z, showWorldModel, scale, p7, p8, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_WEAPON_GIVE_WEAPON_COMPONENT_TO_WEAPON_OBJECT( Object weaponObject, unsigned componentHash) { invoke<void )
	{
		WEAPON::GIVE_WEAPON_COMPONENT_TO_WEAPON_OBJECT(weaponObject, invoke<void);
	}

	void LUA_NATIVE_WEAPON_REMOVE_WEAPON_COMPONENT_FROM_WEAPON_OBJECT( Object object, unsigned componentHash) { invoke<void )
	{
		WEAPON::REMOVE_WEAPON_COMPONENT_FROM_WEAPON_OBJECT(object, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_HAS_WEAPON_GOT_WEAPON_COMPONENT( Object weapon, unsigned componentHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::HAS_WEAPON_GOT_WEAPON_COMPONENT(weapon, invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_GIVE_WEAPON_OBJECT_TO_PED( Object weaponObject, int ped) { invoke<void )
	{
		WEAPON::GIVE_WEAPON_OBJECT_TO_PED(weaponObject, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_DOES_WEAPON_TAKE_WEAPON_COMPONENT( unsigned weaponHash, unsigned componentHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::DOES_WEAPON_TAKE_WEAPON_COMPONENT(weaponHash, invoke<BOOL);
		return retval;
	}

	Object LUA_NATIVE_WEAPON_GET_WEAPON_OBJECT_FROM_PED( int ped, bool p1) { return invoke<Object )
	{
		auto retval = WEAPON::GET_WEAPON_OBJECT_FROM_PED(ped, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_WEAPON_GIVE_LOADOUT_TO_PED( int ped, unsigned loadoutHash) { invoke<void )
	{
		WEAPON::GIVE_LOADOUT_TO_PED(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_PED_WEAPON_TINT_INDEX( int ped, unsigned weaponHash, int tintIndex) { invoke<void )
	{
		WEAPON::SET_PED_WEAPON_TINT_INDEX(ped, weaponHash, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_PED_WEAPON_TINT_INDEX( int ped, unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_PED_WEAPON_TINT_INDEX(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_OBJECT_TINT_INDEX( Object weapon, int tintIndex) { invoke<void )
	{
		WEAPON::SET_WEAPON_OBJECT_TINT_INDEX(weapon, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_OBJECT_TINT_INDEX( Object weapon) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_OBJECT_TINT_INDEX(invoke<int);
		return retval;
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_TINT_COUNT( unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_TINT_COUNT(invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_PED_WEAPON_COMPONENT_TINT_INDEX( int ped, unsigned weaponHash, unsigned camoComponentHash, int colorIndex) { invoke<void )
	{
		WEAPON::SET_PED_WEAPON_COMPONENT_TINT_INDEX(ped, weaponHash, camoComponentHash, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_PED_WEAPON_COMPONENT_TINT_INDEX( int ped, unsigned weaponHash, unsigned camoComponentHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_PED_WEAPON_COMPONENT_TINT_INDEX(ped, weaponHash, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_OBJECT_COMPONENT_TINT_INDEX( Object weaponObject, unsigned camoComponentHash, int colorIndex) { invoke<void )
	{
		WEAPON::SET_WEAPON_OBJECT_COMPONENT_TINT_INDEX(weaponObject, camoComponentHash, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_OBJECT_COMPONENT_TINT_INDEX( Object weaponObject, unsigned camoComponentHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_OBJECT_COMPONENT_TINT_INDEX(weaponObject, invoke<int);
		return retval;
	}

	int LUA_NATIVE_WEAPON_GET_PED_WEAPON_CAMO_INDEX( int ped, unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_PED_WEAPON_CAMO_INDEX(ped, invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_OBJECT_CAMO_INDEX( Object weaponObject, int p1) { invoke<void )
	{
		WEAPON::SET_WEAPON_OBJECT_CAMO_INDEX(weaponObject, invoke<void);
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_WEAPON_GET_WEAPON_HUD_STATS( unsigned weaponHash, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_WEAPON_HUD_STATS(weaponHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	std::tuple<bool, Any outData) { return> LUA_NATIVE_WEAPON_GET_WEAPON_COMPONENT_HUD_STATS( unsigned componentHash, Any outData) { return invoke<BOOL )
	{
		std::tuple<bool, Any outData) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::GET_WEAPON_COMPONENT_HUD_STATS(componentHash, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	float LUA_NATIVE_WEAPON_GET_WEAPON_DAMAGE( unsigned weaponHash, unsigned componentHash) { return invoke<float )
	{
		auto retval = WEAPON::GET_WEAPON_DAMAGE(weaponHash, invoke<float);
		return retval;
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_CLIP_SIZE( unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_CLIP_SIZE(invoke<int);
		return retval;
	}

	float LUA_NATIVE_WEAPON_GET_WEAPON_TIME_BETWEEN_SHOTS( unsigned weaponHash) { return invoke<float )
	{
		auto retval = WEAPON::GET_WEAPON_TIME_BETWEEN_SHOTS(invoke<float);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_PED_CHANCE_OF_FIRING_BLANKS( int ped, float xBias, float yBias) { invoke<void )
	{
		WEAPON::SET_PED_CHANCE_OF_FIRING_BLANKS(ped, xBias, invoke<void);
	}

	Object LUA_NATIVE_WEAPON_SET_PED_SHOOT_ORDNANCE_WEAPON( int ped, float p1) { return invoke<Object )
	{
		auto retval = WEAPON::SET_PED_SHOOT_ORDNANCE_WEAPON(ped, invoke<Object);
		return retval;
	}

	void LUA_NATIVE_WEAPON_REQUEST_WEAPON_HIGH_DETAIL_MODEL( int weaponObject) { invoke<void )
	{
		WEAPON::REQUEST_WEAPON_HIGH_DETAIL_MODEL(invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_DAMAGE_MODIFIER( unsigned weaponHash, float damageMultiplier) { invoke<void )
	{
		WEAPON::SET_WEAPON_DAMAGE_MODIFIER(weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_AOE_MODIFIER( unsigned weaponHash, float multiplier) { invoke<void )
	{
		WEAPON::SET_WEAPON_AOE_MODIFIER(weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_EFFECT_DURATION_MODIFIER( unsigned p0, float p1) { invoke<void )
	{
		WEAPON::SET_WEAPON_EFFECT_DURATION_MODIFIER(p0, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_IS_PED_CURRENT_WEAPON_SILENCED( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_PED_CURRENT_WEAPON_SILENCED(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_IS_FLASH_LIGHT_ON( int ped) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::IS_FLASH_LIGHT_ON(invoke<BOOL);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_SET_FLASH_LIGHT_FADE_DISTANCE( float distance) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::SET_FLASH_LIGHT_FADE_DISTANCE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_FLASH_LIGHT_ACTIVE_HISTORY( int ped, bool toggle) { invoke<void )
	{
		WEAPON::SET_FLASH_LIGHT_ACTIVE_HISTORY(ped, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_WEAPON_ANIMATION_OVERRIDE( int ped, unsigned animStyle) { invoke<void )
	{
		WEAPON::SET_WEAPON_ANIMATION_OVERRIDE(ped, invoke<void);
	}

	int LUA_NATIVE_WEAPON_GET_WEAPON_DAMAGE_TYPE( unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::GET_WEAPON_DAMAGE_TYPE(invoke<int);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_EQIPPED_WEAPON_START_SPINNING_AT_FULL_SPEED( int ped) { invoke<void )
	{
		WEAPON::SET_EQIPPED_WEAPON_START_SPINNING_AT_FULL_SPEED(invoke<void);
	}

	bool LUA_NATIVE_WEAPON_CAN_USE_WEAPON_ON_PARACHUTE( unsigned weaponHash) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::CAN_USE_WEAPON_ON_PARACHUTE(invoke<BOOL);
		return retval;
	}

	int LUA_NATIVE_WEAPON_CREATE_AIR_DEFENCE_SPHERE( float x, float y, float z, float radius, float p4, float p5, float p6, unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::CREATE_AIR_DEFENCE_SPHERE(x, y, z, radius, p4, p5, p6, invoke<int);
		return retval;
	}

	int LUA_NATIVE_WEAPON_CREATE_AIR_DEFENCE_ANGLED_AREA( float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float radius, unsigned weaponHash) { return invoke<int )
	{
		auto retval = WEAPON::CREATE_AIR_DEFENCE_ANGLED_AREA(p0, p1, p2, p3, p4, p5, p6, p7, p8, radius, invoke<int);
		return retval;
	}

	bool LUA_NATIVE_WEAPON_REMOVE_AIR_DEFENCE_SPHERE( int zoneId) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::REMOVE_AIR_DEFENCE_SPHERE(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_REMOVE_ALL_AIR_DEFENCE_SPHERES(  )
	{
		WEAPON::REMOVE_ALL_AIR_DEFENCE_SPHERES();
	}

	void LUA_NATIVE_WEAPON_SET_PLAYER_TARGETTABLE_FOR_AIR_DEFENCE_SPHERE( int player, int zoneId, bool enable) { invoke<void )
	{
		WEAPON::SET_PLAYER_TARGETTABLE_FOR_AIR_DEFENCE_SPHERE(player, zoneId, invoke<void);
	}

	std::tuple<bool, int outZoneId) { return> LUA_NATIVE_WEAPON_IS_AIR_DEFENCE_SPHERE_IN_AREA( float x, float y, float z, float radius, int outZoneId) { return invoke<BOOL )
	{
		std::tuple<bool, int outZoneId) { return> return_values;
		std::get<0>(return_values) = (bool)WEAPON::IS_AIR_DEFENCE_SPHERE_IN_AREA(x, y, z, radius, &invoke<BOOL);
		std::get<1>(return_values) = invoke<BOOL;

		return return_values;
	}

	void LUA_NATIVE_WEAPON_FIRE_AIR_DEFENCE_SPHERE_WEAPON_AT_POSITION( int zoneId, float x, float y, float z) { invoke<void )
	{
		WEAPON::FIRE_AIR_DEFENCE_SPHERE_WEAPON_AT_POSITION(zoneId, x, y, invoke<void);
	}

	bool LUA_NATIVE_WEAPON_DOES_AIR_DEFENCE_SPHERE_EXIST( int zoneId) { return invoke<BOOL )
	{
		auto retval = (bool)WEAPON::DOES_AIR_DEFENCE_SPHERE_EXIST(invoke<BOOL);
		return retval;
	}

	void LUA_NATIVE_WEAPON_SET_CAN_PED_SELECT_INVENTORY_WEAPON( int ped, unsigned weaponHash, bool toggle) { invoke<void )
	{
		WEAPON::SET_CAN_PED_SELECT_INVENTORY_WEAPON(ped, weaponHash, invoke<void);
	}

	void LUA_NATIVE_WEAPON_SET_CAN_PED_SELECT_ALL_WEAPONS( int ped, bool toggle) { invoke<void )
	{
		WEAPON::SET_CAN_PED_SELECT_ALL_WEAPONS(ped, invoke<void);
	}

	int LUA_NATIVE_ZONE_GET_ZONE_AT_COORDS( float x, float y, float z) { return invoke<int )
	{
		auto retval = ZONE::GET_ZONE_AT_COORDS(x, y, invoke<int);
		return retval;
	}

	int LUA_NATIVE_ZONE_GET_ZONE_FROM_NAME_ID( const char* zoneName) { return invoke<int )
	{
		auto retval = ZONE::GET_ZONE_FROM_NAME_ID(invoke<int);
		return retval;
	}

	int LUA_NATIVE_ZONE_GET_ZONE_POPSCHEDULE( int zoneId) { return invoke<int )
	{
		auto retval = ZONE::GET_ZONE_POPSCHEDULE(invoke<int);
		return retval;
	}

	const char* LUA_NATIVE_ZONE_GET_NAME_OF_ZONE( float x, float y, float z) { return invoke<const char* )
	{
		auto retval = ZONE::GET_NAME_OF_ZONE(x, y, char*);
		return retval;
	}

	void LUA_NATIVE_ZONE_SET_ZONE_ENABLED( int zoneId, bool toggle) { invoke<void )
	{
		ZONE::SET_ZONE_ENABLED(zoneId, invoke<void);
	}

	int LUA_NATIVE_ZONE_GET_ZONE_SCUMMINESS( int zoneId) { return invoke<int )
	{
		auto retval = ZONE::GET_ZONE_SCUMMINESS(invoke<int);
		return retval;
	}

	void LUA_NATIVE_ZONE_OVERRIDE_POPSCHEDULE_VEHICLE_MODEL( int scheduleId, unsigned vehicleHash) { invoke<void )
	{
		ZONE::OVERRIDE_POPSCHEDULE_VEHICLE_MODEL(scheduleId, invoke<void);
	}

	void LUA_NATIVE_ZONE_CLEAR_POPSCHEDULE_OVERRIDE_VEHICLE_MODEL( int scheduleId) { invoke<void )
	{
		ZONE::CLEAR_POPSCHEDULE_OVERRIDE_VEHICLE_MODEL(invoke<void);
	}

	unsigned LUA_NATIVE_ZONE_GET_HASH_OF_MAP_AREA_AT_COORDS( float x, float y, float z) { return invoke<unsigned )
	{
		auto retval = ZONE::GET_HASH_OF_MAP_AREA_AT_COORDS(x, y, invoke<unsigned);
		return retval;
	}

}
